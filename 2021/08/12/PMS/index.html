<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>PMS | 淋竹调</title><meta name="keywords" content="淋竹"><meta name="author" content="淋竹"><meta name="copyright" content="淋竹"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="PMS PowerManagerService是负责管理、协调设备电源管理的系统服务之一，它在Framework层建立起一个策略控制方案，向下决策HAL层以及kernel层来控制设备待机状态、控制显示屏、背光灯、距离或光线传感器等硬件设备的状态。向上提供给应用程序相应的操作接口，如听音乐保持系统唤醒、应用通知唤醒屏幕等场景。 该类继承自SystemService，具有生命周期方法，由System">
<meta property="og:type" content="article">
<meta property="og:title" content="PMS">
<meta property="og:url" content="https://www.llscme.fun/2021/08/12/PMS/index.html">
<meta property="og:site_name" content="淋竹调">
<meta property="og:description" content="PMS PowerManagerService是负责管理、协调设备电源管理的系统服务之一，它在Framework层建立起一个策略控制方案，向下决策HAL层以及kernel层来控制设备待机状态、控制显示屏、背光灯、距离或光线传感器等硬件设备的状态。向上提供给应用程序相应的操作接口，如听音乐保持系统唤醒、应用通知唤醒屏幕等场景。 该类继承自SystemService，具有生命周期方法，由System">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422121222.JPG">
<meta property="article:published_time" content="2021-08-12T13:10:17.150Z">
<meta property="article:modified_time" content="2021-08-12T13:10:17.150Z">
<meta property="article:author" content="淋竹">
<meta property="article:tag" content="淋竹">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422121222.JPG"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422120839.png"><link rel="canonical" href="https://www.llscme.fun/2021/08/12/PMS/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#EED2EE&quot;,&quot;text_selection&quot;:&quot;#B0E2FF&quot;,&quot;link_color&quot;:&quot;#9F79EE&quot;,&quot;blockquote_padding_color&quot;:&quot;#9F79EE&quot;,&quot;blockquote_background_color&quot;:&quot;#9F79EE&quot;}}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7d879721321dd98e3ed28243df2a93b";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-08-12 21:10:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}const fontSizeVal = saveToLocal.get('global-font-size')
if (fontSizeVal !== undefined) {
  document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
}})()</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422121222.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">186</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/self-talking/"><i class="fa-fw fa fa-calendar"></i><span> 笔迹</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-star"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> 时光相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 动人乐声</span></a></li><li><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-envelope"></i><span> 与子成说</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="no-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">淋竹调</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-heart"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/self-talking/"><i class="fa-fw fa fa-calendar"></i><span> 笔迹</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-star"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 爱好</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera"></i><span> 时光相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 动人乐声</span></a></li><li><a class="site-page" href="/timeline/"><i class="fa-fw fa fa-envelope"></i><span> 与子成说</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">PMS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-12T13:10:17.150Z" title="发表于 2021-08-12 21:10:17">2021-08-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-12T13:10:17.150Z" title="更新于 2021-08-12 21:10:17">2021-08-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/PMS/">PMS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="pms"><a class="markdownIt-Anchor" href="#pms"></a> PMS</h1>
<p>PowerManagerService是负责管理、协调设备电源管理的系统服务之一，它在Framework层建立起一个策略控制方案，向下决策HAL层以及kernel层来控制设备待机状态、控制显示屏、背光灯、距离或光线传感器等硬件设备的状态。向上提供给应用程序相应的操作接口，如听音乐保持系统唤醒、应用通知唤醒屏幕等场景。</p>
<p>该类继承自SystemService，具有生命周期方法，由SystemServer启动并注册到系统服务中，通过Binder和其他组件进行交互。</p>
<p><strong>生命周期方法：</strong>（1）Constructor：通过反射调用，获取实例；（2）<code>onStart()</code>方法：开启对应的SystemService；（3）<code>onBootPhase()</code>方法：在SystemService服务启动过程中指定服务的启动阶段，每个阶段的工作。</p>
<h2 id="1-pms的启动"><a class="markdownIt-Anchor" href="#1-pms的启动"></a> 1、PMS的启动</h2>
<p>PMS和SystemService的其他子类一样由SystemServer通过反射的方式启动。首先，在SystemServer的<code>main()</code>方法中调用自身的<code>run()</code>方法，并在run()方法中启动三类服务：引导服务、核心服务和其他服务，引导服务就包括了PMS。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SystemServer的main()中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SystemServer的run()方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startBootstrapServices();<span class="comment">//启动引导服务</span></span><br><span class="line">        startCoreServices();<span class="comment">//启动核心服务</span></span><br><span class="line">        startOtherServices();<span class="comment">//启动其他服务</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动引导服务时，PMS随之启动，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">//通过SystemManagerService的startService()方法进行启动，在startService()中，获取了PowerManagerService的Class对象，然后使用反射机制，通过Class对象获取PMS的构造函数，从而获得了一个PMS对象。</span></span><br><span class="line">    mPowerManagerService = mSystemServiceManager.</span><br><span class="line">                startService(PowerManagerService.class);</span><br><span class="line">    <span class="comment">//AMS中初始化PowerManager</span></span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//startService()方法</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends SystemService&gt; <span class="function">T <span class="title">startService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">final</span> T service;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射创建 PowerManagerService</span></span><br><span class="line">            Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);</span><br><span class="line">            service = constructor.newInstance(mContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException ex) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        startService(service);</span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> SystemService service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将服务添加到服务列表里</span></span><br><span class="line">    mServices.add(service);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 启动服务，最终回调到 onStart 方法</span></span><br><span class="line">        service.onStart();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException ex) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>startService()</code>方法可以看到对于PMS，先执行了其构造方法，接着执行了<code>onStart()</code>方法。构造方法如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PowerManagerService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">//获取一个系统级别的HandlerThread，继承于Thread</span></span><br><span class="line">    mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG,</span><br><span class="line">            Process.THREAD_PRIORITY_DISPLAY, <span class="keyword">false</span> );</span><br><span class="line">    mHandlerThread.start();<span class="comment">//开启线程</span></span><br><span class="line">    <span class="comment">//根据Looper实例化一个Handler</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> PowerManagerHandler(mHandlerThread.getLooper());</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    	<span class="comment">//获取当应用申请wakelock后让CUP保持激活状态的Suspendlocker实例</span></span><br><span class="line">        mWakeLockSuspendBlocker = </span><br><span class="line">             createSuspendBlockerLocked(<span class="string">&quot;PowerManagerService.WakeLocks&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当显示屏开启、显示屏准备就绪或者有用户活动后让CPU保持激活状态的Suspendlocker</span></span><br><span class="line">        mDisplaySuspendBlocker = </span><br><span class="line">            createSuspendBlockerLocked(<span class="string">&quot;PowerManagerService.Display&quot;</span>);</span><br><span class="line">        <span class="comment">//申请PowerManagerService.Display类型的suspendBloker锁</span></span><br><span class="line">        mDisplaySuspendBlocker.acquire();</span><br><span class="line">       <span class="comment">//持有Display锁的bool值</span></span><br><span class="line">        mHoldingDisplaySuspendBlocker = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//AutoSuspend模式是否开启</span></span><br><span class="line">        mHalAutoSuspendModeEnabled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//是否处于交互模式</span></span><br><span class="line">        mHalInteractiveModeEnabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//设置wakefulness为亮屏状态</span></span><br><span class="line">        mWakefulness = WAKEFULNESS_AWAKE;</span><br><span class="line">		<span class="comment">//本地方法</span></span><br><span class="line">        nativeInit();<span class="comment">//初始化</span></span><br><span class="line">        nativeSetAutoSuspend(<span class="keyword">false</span>);<span class="comment">//设置是否开启anto suspend模式</span></span><br><span class="line">        nativeSetInteractive(<span class="keyword">true</span>);<span class="comment">//设置是否处于交互模式</span></span><br><span class="line">        nativeSetFeature(POWER_FEATURE_DOUBLE_TAP_TO_WAKE, <span class="number">0</span>);</span><br><span class="line">        getPowerHintSceneIdConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SuspendBlocker是一种锁机制，只用于系统内部，上层申请的wakelock锁在PMS中都会反映为SuspendBlocker锁，这里获取的两个Suspend锁在申请wakelock时会用到，最后，调用了本地方法，这几个方法会通过JNI层调用到HAL层。</span></span><br></pre></td></tr></table></figure>
<p>构造方法执行完后执行<code>onstart()</code>方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在该方法中，首先对服务进行Binder注册（使得其他模块可以通过Binder机制获取该实例）和本地注册（在System进程才能获取到该实例），最后设置Watchdog监听。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发布到系统服务中</span></span><br><span class="line">    publishBinderService(Context.POWER_SERVICE, <span class="keyword">new</span> BinderService());</span><br><span class="line">    <span class="comment">//发布到本地服务</span></span><br><span class="line">    publishLocalService(PowerManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">	<span class="comment">//设置Watchdog监听</span></span><br><span class="line">    Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line">    Watchdog.getInstance().addThread(mHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对服务进行远程注册，是通过Binder机制实现的，实际上，从代码中可以出，注册的并不是PMS本身，而是其内部类BinderService，BinderService继承自IPowerManager.Stub，IPowerManager.Stub继承自Binder并且实现了IPowerManager，因此可以知道，BinderService作为Binder的服务端，可以和客户端进行交互；注册的过程在ServiceManager中进行的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addService</span><span class="params">(String name, IBinder service, <span class="keyword">boolean</span> allowIsolated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getIServiceManager().addService(name, service, allowIsolated);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;error in addService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经ServiceManager注册后，就可以根据Context.POWER_SERVICE在其他服务中获取对应的IBinder了，以PMS为例，当从其他应用中获取了PMS服务后，就可以调用PMS.BinderService中的方法。所以，PMS中的BinderService相当于服务端，其中的方法可以供其他应用进行调用，从而完成和PMS的交互。</p>
<p>通过Binder进行注册是为了供其他应用或系统服务和PMS进行交互。同样的，本地注册表示只能在System进程内部调用，和BinderService一样，本地注册也并非注册的是PMS，而是另一个内部类LocalService，LocalService继承自PowerManagerInternal（带有Internal的类一般都在System进程内使用）；Binder注册是在SystemManager中进行注册的，本地注册则是在LocalServices中进行注册，其注册方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addService</span><span class="params">(Class&lt;T&gt; type, T service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sLocalServiceObjects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sLocalServiceObjects.containsKey(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Overriding service registration&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sLocalServiceObjects.put(type, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地注册完后，就可以在System进程内，通过PowerManagerInternal.class获取PMS.LocalService对象，从而完成交互了。</p>
<p>在远程注册和本地注册都完成以后，给PMS设置了watchDog监听，<code>onStart()</code>方法调用完毕。此时，继续回到SytemServer中，<code>startBootstrapServices()</code>方法中启动PMS部分执行完成了，然后根据SystemService的生命周期，会开始执行<code>onBootPhase()</code>，这个方法的功能是为所有的已启动的服务指定启动阶段，从而可以在指定的启动阶段来做指定的工作。源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Starts the specified boot phase for all system services that have been started   </span></span><br><span class="line"><span class="comment"> * up to this point.</span></span><br><span class="line"><span class="comment"> * @param phase The boot phase to start.*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startBootPhase</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase &lt;= mCurrentPhase) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Next phase must be larger than previous&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentPhase = phase;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> serviceLen = mServices.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; serviceLen; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> SystemService service = mServices.get(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                service.onBootPhase(mCurrentPhase);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SystemServiceManager的<code>startBootPhase()</code>中，调用SystemService的<code>onBootPhase(int)</code>方法，此时每个SystemService都会执行其对应的onBootPhase()方法。通过在SystemServiceManager中传入不同的形参，回调所有SystemService的onBootPhase()方法，并根据形参的不同，在方法实现中完成不同的工作，在SystemService中定义了五个阶段：</p>
<ul>
<li><code>SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY</code>:这是一个依赖项，只在DisplayManagerService中进行了对应处理；</li>
<li><code>SystemService.PHASE_LOCK_SETTINGS_READY</code>:经过这个引导阶段后，服务才可以接收到wakelock相关设置数据；</li>
<li><code>SystemService.PHASE_SYSTEM_SERVICES_READY</code>:经过这个引导阶段后，服务才可以安全地使用核心系统服务；</li>
<li><code>SystemService.PHASE_ACTIVITY_MANAGER_READY</code>:经过这个引导阶段后，服务可以发送广播</li>
<li><code>SystemService.PHASE_THIRD_PARTY_APPS_CAN_START</code>:经过这个引导阶段后，服务可以启动第三方应用，第三方应用也可以通过Binder来调用服务。</li>
<li><code>SystemService.PHASE_BOOT_COMPLETED</code>:经过这个引导阶段后，说明服务启动完成，这时用户就可以和设备进行交互。</li>
</ul>
<p>因此，只要在其他模块中调用了<code>SystemServiceManager.startBootPhase()</code>方法，都会触发各自的<code>onBootPhase()</code>。PMS的<code>onBootPhase()</code>方法只对引导阶段的2个阶段做了处理，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBootPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (phase == PHASE_THIRD_PARTY_APPS_CAN_START) &#123;</span><br><span class="line">        	<span class="comment">//统计启动的apk个数</span></span><br><span class="line">            incrementBootCount();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase == PHASE_BOOT_COMPLETED) &#123;</span><br><span class="line">            mBootCompleted = <span class="keyword">true</span>;</span><br><span class="line">            PMSFactory.getInstance().createPowerManagerServiceUtils(mContext)</span><br><span class="line">                                .setBootCompleted(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//mDirty置位，mDirty是一个二进制的标记位，用来表示电源状态哪一部分发生了改变，通过对其进行置位（|操作）、清零（~操作）得到二进制数各个位的值（0或1）。</span></span><br><span class="line">            mDirty |= DIRTY_BOOT_COMPLETED;</span><br><span class="line">            <span class="comment">//更新用户活动时间</span></span><br><span class="line">            userActivityNoUpdateLocked(</span><br><span class="line">                    now, PowerManager.USER_ACTIVITY_EVENT_OTHER, </span><br><span class="line">                              <span class="number">0</span>, Process.SYSTEM_UID);</span><br><span class="line">            <span class="comment">//更新电源状态信息</span></span><br><span class="line">            updatePowerStateLocked();</span><br><span class="line">            ......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onBootPhase()</code>方法执行完，生命周期方法也执行完毕，引导服务也启动完成。</p>
<p>对于PMS，在<code>SystemServer.startOtherServices()</code>中还进行了一步操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mPowerManagerService.systemReady(mActivityManagerService.getAppOpsService());</span><br></pre></td></tr></table></figure>
<p>即PMS依次执行完构造方法、<code>onStart()</code>、<code>onBootPhase()</code>(会调用多次)，之后执行<code>systemReady()</code>方法。</p>
<p><strong>systemReady方法的作用：</strong></p>
<p>1、获取各类本地服务和远程服务，如屏保（DreamManagerService）、窗口（PhoneWindowManager）、电池状态监听服务（BatteryService）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">    mSystemReady = <span class="keyword">true</span>;</span><br><span class="line">    mAppOps = appOps;</span><br><span class="line">    <span class="comment">//和DreamManagerService交互</span></span><br><span class="line">    mDreamManager = getLocalService(DreamManagerInternal.class);</span><br><span class="line">    <span class="comment">//和DisplayManagerService交互</span></span><br><span class="line">    mDisplayManagerInternal = getLocalService(DisplayManagerInternal.class);</span><br><span class="line">    <span class="comment">//和WindowManagerService交互</span></span><br><span class="line">    mPolicy = getLocalService(WindowManagerPolicy.class);</span><br><span class="line">    <span class="comment">//和BatteryService交互</span></span><br><span class="line">    mBatteryManagerInternal = getLocalService(BatteryManagerInternal.class);</span><br><span class="line">    <span class="comment">//获取屏幕亮度</span></span><br><span class="line">    PowerManager pm = (PowerManager) </span><br><span class="line">            mContext.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">    mScreenBrightnessSettingMinimum = pm.getMinimumScreenBrightnessSetting();</span><br><span class="line">    mScreenBrightnessSettingMaximum = pm.getMaximumScreenBrightnessSetting();</span><br><span class="line">    mScreenBrightnessSettingDefault = pm.getDefaultScreenBrightnessSetting();</span><br><span class="line">    mScreenBrightnessForVrSettingDefault = </span><br><span class="line">            pm.getDefaultScreenBrightnessForVrSetting();</span><br><span class="line">    SensorManager sensorManager = <span class="keyword">new</span> SystemSensorManager(mContext, </span><br><span class="line">            mHandler.getLooper());</span><br><span class="line">    <span class="comment">//获取BatteryStatsService</span></span><br><span class="line">    mBatteryStats = BatteryStatsService.getService();</span><br><span class="line">    <span class="comment">//mNotifier用于PMS和其他系统服务间的交互,以及广播的发送</span></span><br><span class="line">    mNotifier = <span class="keyword">new</span> Notifier(Looper.getMainLooper(), mContext, mBatteryStats,</span><br><span class="line">            mAppOps, </span><br><span class="line">            createSuspendBlockerLocked(<span class="string">&quot;PowerManagerService.Broadcasts&quot;</span>),</span><br><span class="line">            mPolicy);</span><br><span class="line">    <span class="comment">//无线充电相关</span></span><br><span class="line">    mWirelessChargerDetector = <span class="keyword">new</span> WirelessChargerDetector(sensorManager,</span><br><span class="line">            createSuspendBlockerLocked</span><br><span class="line">            (<span class="string">&quot;PowerManagerService.WirelessChargerDetector&quot;</span>),</span><br><span class="line">            mHandler);</span><br><span class="line">    <span class="comment">//监听Stetings中值的变化</span></span><br><span class="line">    mSettingsObserver = <span class="keyword">new</span> SettingsObserver(mHandler);</span><br><span class="line">    <span class="comment">//和LightsManager交互</span></span><br><span class="line">    mLightsManager = getLocalService(LightsManager.class);</span><br><span class="line">    mAttentionLight = </span><br><span class="line">             mLightsManager.getLight(LightsManager.LIGHT_ID_ATTENTION);</span><br><span class="line">    <span class="comment">//mDisplayPowerCallbacks提供PMS和Display的接口，当DisplayPowerController发生改变，通过该接口回调PMS中的实现</span></span><br><span class="line">    <span class="comment">//initPowerManagement()方法中实例化了DisplayPowerController,</span></span><br><span class="line">    <span class="comment">//DPC是和显示有关,如亮灭屏、背光调节</span></span><br><span class="line">    mDisplayManagerInternal.initPowerManagement(mDisplayPowerCallbacks, mHandler, sensorManager);</span><br></pre></td></tr></table></figure>
<p>2、注册用于和其他System交互的广播。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register for broadcasts from other components of the system.</span></span><br><span class="line"><span class="comment">// 注册BatteryService中ACTION_BATTERY_CHANGED广播</span></span><br><span class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">filter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);</span><br><span class="line">mContext.registerReceiver(<span class="keyword">new</span> BatteryReceiver(), filter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"><span class="comment">//Dream相关</span></span><br><span class="line">filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(Intent.ACTION_DREAMING_STARTED);</span><br><span class="line">filter.addAction(Intent.ACTION_DREAMING_STOPPED); </span><br><span class="line">mContext.registerReceiver(<span class="keyword">new</span> DreamReceiver(), filter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(Intent.ACTION_USER_SWITCHED);</span><br><span class="line">mContext.registerReceiver(<span class="keyword">new</span> UserSwitchedReceiver(), filter, <span class="keyword">null</span>, mHandler);</span><br><span class="line"><span class="comment">//Dock相关</span></span><br><span class="line">filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(Intent.ACTION_DOCK_EVENT);</span><br><span class="line">mContext.registerReceiver(<span class="keyword">new</span> DockReceiver(), filter, <span class="keyword">null</span>, mHandler);</span><br></pre></td></tr></table></figure>
<p>3、调用<code>updateSettingsLocked()</code>方法更新Setting中值的变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateSettingsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">    <span class="comment">//屏保是否支持</span></span><br><span class="line">    mDreamsEnabledSetting = (Settings.Secure.getIntForUser(resolver,</span><br><span class="line">            Settings.Secure.SCREENSAVER_ENABLED,</span><br><span class="line">            mDreamsEnabledByDefaultConfig ? <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">            UserHandle.USER_CURRENT) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//休眠时是否启用屏保</span></span><br><span class="line">    mDreamsActivateOnSleepSetting = (Settings.Secure.getIntForUser(resolver,</span><br><span class="line">            Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP,</span><br><span class="line">            mDreamsActivatedOnSleepByDefaultConfig ? <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">            UserHandle.USER_CURRENT) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//插入基座时屏保是否激活</span></span><br><span class="line">    mDreamsActivateOnDockSetting = (Settings.Secure.getIntForUser(resolver,</span><br><span class="line">            Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK,</span><br><span class="line">            mDreamsActivatedOnDockByDefaultConfig ? <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">            UserHandle.USER_CURRENT) != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//设备在一段时间不活动后进入休眠或者屏保状态的时间，15*1000ms</span></span><br><span class="line">    mScreenOffTimeoutSetting = Settings.System.getIntForUser(resolver,</span><br><span class="line">            Settings.System.SCREEN_OFF_TIMEOUT, </span><br><span class="line">            DEFAULT_SCREEN_OFF_TIMEOUT,</span><br><span class="line">            UserHandle.USER_CURRENT);</span><br><span class="line">    <span class="comment">/*设备在一段时间不活动后完全进入休眠状态之前的超时时间，</span></span><br><span class="line"><span class="comment">    该值必须大于SCREEN_OFF_TIMEOUT，否则设置了屏保后来不及显示屏保就sleep*/</span></span><br><span class="line">    mSleepTimeoutSetting = Settings.Secure.getIntForUser(resolver,</span><br><span class="line">            Settings.Secure.SLEEP_TIMEOUT, DEFAULT_SLEEP_TIMEOUT,</span><br><span class="line">            UserHandle.USER_CURRENT);</span><br><span class="line">    <span class="comment">//充电时屏幕一直开启</span></span><br><span class="line">    mStayOnWhilePluggedInSetting = Settings.Global.getInt(resolver,</span><br><span class="line">            Settings.Global.STAY_ON_WHILE_PLUGGED_IN, </span><br><span class="line">            BatteryManager.BATTERY_PLUGGED_AC);</span><br><span class="line">    <span class="comment">//是否支持剧院模式</span></span><br><span class="line">    mTheaterModeEnabled = Settings.Global.getInt(mContext.getContentResolver(),</span><br><span class="line">            Settings.Global.THEATER_MODE_ON, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//屏幕保持常亮</span></span><br><span class="line">    mAlwaysOnEnabled = mAmbientDisplayConfiguration.</span><br><span class="line">            alwaysOnEnabled(UserHandle.USER_CURRENT);</span><br><span class="line">    <span class="comment">//双击唤醒屏幕设置</span></span><br><span class="line">    <span class="keyword">if</span> (mSupportsDoubleTapWakeConfig) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> doubleTapWakeEnabled = Settings.Secure.getIntForUser(resolver,</span><br><span class="line">                Settings.Secure.DOUBLE_TAP_TO_WAKE, </span><br><span class="line">                DEFAULT_DOUBLE_TAP_TO_WAKE,</span><br><span class="line">                        UserHandle.USER_CURRENT) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (doubleTapWakeEnabled != mDoubleTapWakeEnabled) &#123;</span><br><span class="line">            mDoubleTapWakeEnabled = doubleTapWakeEnabled;</span><br><span class="line">            nativeSetFeature(POWER_FEATURE_DOUBLE_TAP_TO_WAKE, </span><br><span class="line">            mDoubleTapWakeEnabled ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String retailDemoValue = UserManager.isDeviceInDemoMode(mContext) ?</span><br><span class="line">            <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    ...... </span><br><span class="line">    <span class="comment">//屏幕亮度</span></span><br><span class="line">    mScreenBrightnessSetting = Settings.System.getIntForUser(resolver,</span><br><span class="line">            Settings.System.SCREEN_BRIGHTNESS, mScreenBrightnessSettingDefault,</span><br><span class="line">            UserHandle.USER_CURRENT);</span><br><span class="line">    <span class="comment">//自动调节亮度值(&gt;0.0 &lt;1.0)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> oldScreenAutoBrightnessAdjustmentSetting =</span><br><span class="line">            mScreenAutoBrightnessAdjustmentSetting;</span><br><span class="line">    mScreenAutoBrightnessAdjustmentSetting = </span><br><span class="line">        Settings.System.getFloatForUser(resolver,</span><br><span class="line">            Settings.System.SCREEN_AUTO_BRIGHTNESS_ADJ, <span class="number">0.0f</span>,</span><br><span class="line">            UserHandle.USER_CURRENT);</span><br><span class="line">    <span class="comment">//重置临时亮度值</span></span><br><span class="line">    <span class="keyword">if</span> (oldScreenBrightnessSetting != getCurrentBrightnessSettingLocked()) &#123;</span><br><span class="line">        mTemporaryScreenBrightnessSettingOverride = -<span class="number">1</span>;<span class="comment">//临时亮度值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldScreenAutoBrightnessAdjustmentSetting != </span><br><span class="line">    mScreenAutoBrightnessAdjustmentSetting) &#123;</span><br><span class="line">        mTemporaryScreenAutoBrightnessAdjustmentSettingOverride = Float.NaN;<span class="comment">//临时自动亮度调节比例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//亮度调节模式，自动1，正常0</span></span><br><span class="line">    mScreenBrightnessModeSetting = Settings.System.getIntForUser(resolver,</span><br><span class="line">            Settings.System.SCREEN_BRIGHTNESS_MODE,</span><br><span class="line">            Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, </span><br><span class="line">        UserHandle.USER_CURRENT);</span><br><span class="line">    <span class="comment">//低电量模式是否可用，1表示true</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> lowPowerModeEnabled = Settings.Global.getInt(resolver,</span><br><span class="line">            Settings.Global.LOW_POWER_MODE, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (lowPowerModeEnabled != mLowPowerModeSetting</span><br><span class="line">            || autoLowPowerModeConfigured != mAutoLowPowerModeConfigured) &#123;</span><br><span class="line">        mLowPowerModeSetting = lowPowerModeEnabled;</span><br><span class="line">        mAutoLowPowerModeConfigured = autoLowPowerModeConfigured;</span><br><span class="line">        <span class="comment">//更新低电量模式</span></span><br><span class="line">        updateLowPowerModeLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//标志位置位</span></span><br><span class="line">    mDirty |= DIRTY_SETTINGS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、调用<code>readConfigurationLocked()</code>方法读取配置文件中的默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readConfigurationLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Resources resources = mContext.getResources();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * auto_suspend模式是否和display分离</span></span><br><span class="line"><span class="comment">     * 如果为false，则在亮屏前调用autosuspend_disable(),灭屏后调用</span></span><br><span class="line"><span class="comment">     * autosuspend_enable();</span></span><br><span class="line"><span class="comment">     * 如果为ture，则调用autosuspend_display()和autosuspend_enable()独立于display </span></span><br><span class="line"><span class="comment">     * on/off.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mDecoupleHalAutoSuspendModeFromDisplayConfig = resources.getBoolean(</span><br><span class="line">                 com.android.internal.R.bool.</span><br><span class="line">                 config_powerDecoupleAutoSuspendModeFromDisplay);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * interactive模式是否和display分离</span></span><br><span class="line"><span class="comment">     * 如果为false，则在亮屏前调用setInteractive(..., true),灭屏后调用</span></span><br><span class="line"><span class="comment">     * setInteractive(...,false);</span></span><br><span class="line"><span class="comment">     * 如果为ture，则调用setInteractive(...)独立于display on/off.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mDecoupleHalInteractiveModeFromDisplayConfig = resources.getBoolean(        </span><br><span class="line">          com.android.internal.R.bool</span><br><span class="line">           .config_powerDecoupleInteractiveModeFromDisplay);</span><br><span class="line">    <span class="comment">//插拔USB是否亮屏</span></span><br><span class="line">    mWakeUpWhenPluggedOrUnpluggedConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_unplugTurnsOnScreen);</span><br><span class="line">    <span class="comment">//设备处于剧院模式时，插拔USB是否亮屏</span></span><br><span class="line">    mWakeUpWhenPluggedOrUnpluggedInTheaterModeConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_allowTheaterModeWakeFromUnplug);</span><br><span class="line">    <span class="comment">//是否允许设备由于接近传感器而关闭屏幕时CPU挂起，进入suspend状态</span></span><br><span class="line">    mSuspendWhenScreenOffDueToProximityConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.</span><br><span class="line">                config_suspendWhenScreenOffDueToProximity);</span><br><span class="line">    <span class="comment">//是否支持屏保</span></span><br><span class="line">    mDreamsSupportedConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_dreamsSupported);</span><br><span class="line">    <span class="comment">//是否屏保默认打开--false</span></span><br><span class="line">    mDreamsEnabledByDefaultConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_dreamsEnabledByDefault);</span><br><span class="line">    <span class="comment">//充电和睡眠时屏保是否激活</span></span><br><span class="line">    mDreamsActivatedOnSleepByDefaultConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_dreamsActivatedOnSleepByDefault);</span><br><span class="line">    <span class="comment">//Dock时屏保是否激活</span></span><br><span class="line">    mDreamsActivatedOnDockByDefaultConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_dreamsActivatedOnDockByDefault);</span><br><span class="line">    <span class="comment">//放电时是否允许进入屏保</span></span><br><span class="line">    mDreamsEnabledOnBatteryConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_dreamsEnabledOnBattery);</span><br><span class="line">    <span class="comment">//充电时允许屏保的最低电量，使用-1禁用此功能</span></span><br><span class="line">    mDreamsBatteryLevelMinimumWhenPoweredConfig = resources.getInteger(</span><br><span class="line">            com.android.internal.R.integer.</span><br><span class="line">             config_dreamsBatteryLevelMinimumWhenPowered);</span><br><span class="line">    <span class="comment">//放电时允许屏保的最低电量，使用-1禁用此功能，默认15</span></span><br><span class="line">    mDreamsBatteryLevelMinimumWhenNotPoweredConfig = resources.getInteger(</span><br><span class="line">            com.android.internal.R.integer.</span><br><span class="line">             config_dreamsBatteryLevelMinimumWhenNotPowered);</span><br><span class="line">    <span class="comment">//电亮下降到该百分点，当用户活动超时后不进入屏保，默认5</span></span><br><span class="line">    mDreamsBatteryLevelDrainCutoffConfig = resources.getInteger(</span><br><span class="line">            com.android.internal.R.integer.config_dreamsBatteryLevelDrainCutoff);</span><br><span class="line">    <span class="comment">//如果为true，则直到关闭屏幕并执行屏幕关闭动画之后，才开始Doze，默认false</span></span><br><span class="line">    mDozeAfterScreenOffConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_dozeAfterScreenOff);</span><br><span class="line">    <span class="comment">//用户活动超时的最小时间，默认10000ms,必须大于0</span></span><br><span class="line">    mMinimumScreenOffTimeoutConfig = resources.getInteger(</span><br><span class="line">            com.android.internal.R.integer.config_minimumScreenOffTimeout);</span><br><span class="line">    <span class="comment">//用户活动超时进入且关闭屏幕前屏幕变暗的最大时间，默认7000ms，必须大于0</span></span><br><span class="line">    mMaximumScreenDimDurationConfig = resources.getInteger(</span><br><span class="line">            com.android.internal.R.integer.config_maximumScreenDimDuration);</span><br><span class="line">    <span class="comment">//屏幕变暗的时长比例，如果用于超时时间过短，则在7000ms的基础上按还比例减少，默认20%</span></span><br><span class="line">    mMaximumScreenDimRatioConfig = resources.getFraction(</span><br><span class="line">            com.android.internal.R.fraction.config_maximumScreenDimRatio, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//是否支持双击唤醒屏幕</span></span><br><span class="line">    mSupportsDoubleTapWakeConfig = resources.getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_supportDoubleTapWake);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、注册SettingsObserver监听</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register for settings changes.</span></span><br><span class="line">resolver.registerContentObserver(Settings.Secure.getUriFor(</span><br><span class="line">        Settings.Secure.SCREENSAVER_ENABLED),</span><br><span class="line">        <span class="keyword">false</span>, mSettingsObserver, UserHandle.USER_ALL);</span><br><span class="line">resolver.registerContentObserver(Settings.Secure.getUriFor(</span><br><span class="line">        Settings.Secure.SCREENSAVER_ACTIVATE_ON_SLEEP),</span><br><span class="line">        <span class="keyword">false</span>, mSettingsObserver, UserHandle.USER_ALL);</span><br><span class="line">resolver.registerContentObserver(Settings.Secure.getUriFor(</span><br><span class="line">        Settings.Secure.SCREENSAVER_ACTIVATE_ON_DOCK),</span><br><span class="line">        <span class="keyword">false</span>, mSettingsObserver, UserHandle.USER_ALL);</span><br><span class="line">resolver.registerContentObserver(Settings.System.getUriFor(</span><br><span class="line">        Settings.System.SCREEN_OFF_TIMEOUT),</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure>
<p>至此，PMS启动过程分析完毕，相关时序图如下所示：</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/image2021-8-10_20-27-50.png" alt="" /></p>
<h3 id="11-核心方法"><a class="markdownIt-Anchor" href="#11-核心方法"></a> 1.1、核心方法</h3>
<h3 id="updatepowerstatelocked"><a class="markdownIt-Anchor" href="#updatepowerstatelocked"></a> <code>updatePowerStateLocked()</code></h3>
<p><code>updatePowerStateLocked()</code>方法是PMS中的核心方法，用以更新电源状态的改变，并进行重新计算。PMS中使用一个int值mDirty作为标志位判断电源状态是否发生改变，当发生亮灭屏、电池状态改变、暗屏、WakeLock锁申请/释放等都会调用该方法，在该方法中调用其他同级方法进行更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePowerStateLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mSystemReady || mDirty == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 第一步:更新基本状态</span></span><br><span class="line">            updateIsPoweredLocked(mDirty);<span class="comment">//更新电池信息</span></span><br><span class="line">            updateStayOnLocked(mDirty);<span class="comment">//更新是否常亮状态</span></span><br><span class="line">            updateScreenBrightnessBoostLocked(mDirty);<span class="comment">//更新亮度是否需要增强</span></span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 第二步: 更新wakelock和用户活动</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();<span class="comment">//记录当前时间</span></span><br><span class="line">            <span class="keyword">int</span> dirtyPhase2 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dirtyPhase1 = mDirty;</span><br><span class="line">                dirtyPhase2 |= dirtyPhase1;</span><br><span class="line">                mDirty = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">                updateWakeLockSummaryLocked(dirtyPhase1);<span class="comment">//更新统计wakelock的标记值mWakeLockSummary</span></span><br><span class="line">                updateUserActivitySummaryLocked(now, dirtyPhase1);<span class="comment">//更新统计userActivity的标记值mUserActivitySummary和休眠到达时间</span></span><br><span class="line">                <span class="keyword">if</span> (!updateWakefulnessLocked(dirtyPhase1)) &#123;<span class="comment">//更新屏幕唤醒状态，状态改变返回true</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 第三步：更新display power state</span></span><br><span class="line">            <span class="keyword">boolean</span> displayBecameReady = updateDisplayPowerStateLocked(dirtyPhase2);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 第四步：更新屏保dream state</span></span><br><span class="line">            updateDreamLocked(dirtyPhase2, displayBecameReady);</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 第五步：如果wakefulness改变，做最后的收尾工作。</span></span><br><span class="line">            finishWakefulnessChangeIfNeededLocked();</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//第六步:更新Suspend锁</span></span><br><span class="line">            updateSuspendBlockerLocked();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            Trace.tranceEnd(Trace.TRACE_TAG_POWER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>下面对上述相关方法进行具体叙述：</p>
<h4 id="updateispoweredlocked"><a class="markdownIt-Anchor" href="#updateispoweredlocked"></a> <code>updateIsPoweredLocked()</code></h4>
<p>功能：（1）USB插拔亮屏入口点；（2）更新低电量模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Updates the value of mIsPowered.</span></span><br><span class="line"><span class="comment">* Sets DIRTY_IS_POWERED if a change occurred.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateIsPoweredLocked</span><span class="params">(<span class="keyword">int</span> dirty)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> ((dirty &amp; DIRTY_BATTERY_STATE) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> wasPowered = mIsPowered;<span class="comment">//是否充电</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> oldPlugType = mPlugType;<span class="comment">//充电类型</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> oldLevelLow = mBatteryLevelLow;<span class="comment">//是否处于低电量</span></span><br><span class="line"><span class="comment">/*---------------------BatteryService交互Begin-----------------------------*/</span></span><br><span class="line">    <span class="comment">//通过BatteryService的本地服务BatteryManagerInternal和BatteryService进行交互，刷新电池信息，并记录上次的电池数据。</span></span><br><span class="line">mIsPowered = mBatteryManagerInternal.isPowered(BatteryManager.</span><br><span class="line">                         BATTERY_PLUGGED_ANY);</span><br><span class="line">mPlugType = mBatteryManagerInternal.getPlugType();</span><br><span class="line">mBatteryLevel = mBatteryManagerInternal.getBatteryLevel();</span><br><span class="line">mBatteryLevelLow = mBatteryManagerInternal.getBatteryLevelLow();</span><br><span class="line"><span class="comment">/*---------------------BatteryService交互 End-----------------------------*/</span></span><br><span class="line"><span class="comment">//充电器插拔事件或者充电器类型改变，则设置 DIRTY_IS_POWERED 标志位</span></span><br><span class="line"><span class="keyword">if</span> (wasPowered != mIsPowered || oldPlugType != mPlugType) &#123;</span><br><span class="line">    mDirty |= DIRTY_IS_POWERED;</span><br><span class="line">    <span class="comment">//是否连接无线充电</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dockedOnWirelessCharger = </span><br><span class="line">           mWirelessChargerDetector.update(</span><br><span class="line">            mIsPowered, mPlugType, mBatteryLevel);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">//插拔充电线是否唤醒屏幕</span></span><br><span class="line">    <span class="keyword">if</span> (shouldWakeUpWhenPluggedOrUnpluggedLocked(wasPowered, </span><br><span class="line">              oldPlugType, dockedOnWirelessCharger)) &#123;</span><br><span class="line">        <span class="comment">//屏幕唤醒</span></span><br><span class="line">        wakeUpNoUpdateLocked(now, </span><br><span class="line">              <span class="string">&quot;android.server.power:POWER&quot;</span>, Process.SYSTEM_UID,</span><br><span class="line">               mContext.getOpPackageName(), Process.SYSTEM_UID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新用户活动</span></span><br><span class="line">    userActivityNoUpdateLocked(</span><br><span class="line">            now, PowerManager.USER_ACTIVITY_EVENT_OTHER, <span class="number">0</span>, </span><br><span class="line">            Process.SYSTEM_UID);</span><br><span class="line">    <span class="comment">//当无线充电器开始充电时给出提示音，在 mNotifier 中进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (dockedOnWirelessCharger) &#123;</span><br><span class="line">        mNotifier.onWirelessChargingStarted();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果电源发生插拔时或者低电量标志位发生变化</span></span><br><span class="line"><span class="keyword">if</span> (wasPowered != mIsPowered || oldLevelLow != mBatteryLevelLow) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldLevelLow != mBatteryLevelLow &amp;&amp; !mBatteryLevelLow) &#123;</span><br><span class="line">        <span class="comment">//当设备从低电量转换为非低电量，则设置自动打盹为 false</span></span><br><span class="line">        mAutoLowPowerModeSnoozing = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新低电量模式</span></span><br><span class="line">    updateLowPowerModeLocked();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码中可知在满足mDirty&amp;DIRTY_BATTERY_STATE != 0时才会执行该方法，满足此条件的情况有两处：</p>
<ol>
<li>
<p>在调用<code>systemReady()</code>方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(IAppOpsService appOps)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    mDirty |= DIRTY_BATTERY_STATE;</span><br><span class="line">    updatePowerStateLocked();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在监听电量状态改变的广播中。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听ACTION_BATTERY_CHANGED</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BatteryReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//设置mDirty |= DIRTY_BATTERY_STAT</span></span><br><span class="line">        handleBatteryStateChangedLocked();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结来说，该方法在电池状态发生变化时将被调用执行。</p>
<h4 id="updatestayonlocked"><a class="markdownIt-Anchor" href="#updatestayonlocked"></a> <code>updateStayOnLocked()</code></h4>
<p>该方法主要用于判断系统是否在Settings中设置了充电时保持屏幕亮屏后，根据是否充电来决定亮屏与否。方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateStayOnLocked</span><span class="params">(<span class="keyword">int</span> dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((dirty &amp; (DIRTY_BATTERY_STATE | DIRTY_SETTINGS)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wasStayOn = mStayOn;</span><br><span class="line">    <span class="comment">//充电时亮屏&amp;&amp;DevicePolicyManager中未设置最大关闭时间</span></span><br><span class="line">        <span class="comment">//mStayOnWhilePluggedInSetting是从SettingsProvider中读取的值，表示是否设置了充电时保持屏幕常亮。若要使mStayOn为true,其先决条件是mStayOnWhilePluggedInSetting为true，同时DevicePolicyManager没有进行最大超时时间的约束，若符合则设备在充电时mStayOn为true。</span></span><br><span class="line">       <span class="keyword">if</span> (mStayOnWhilePluggedInSetting != <span class="number">0</span> &amp;&amp; </span><br><span class="line">            !isMaximumScreenOffTimeoutFromDeviceAdminEnforcedLocked()) &#123;</span><br><span class="line">            <span class="comment">//保持亮屏取决于是否充电</span></span><br><span class="line">            mStayOn = </span><br><span class="line">                mBatteryManagerInternal.isPowered(mStayOnWhilePluggedInSetting);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mStayOn = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mStayOn != wasStayOn) &#123;</span><br><span class="line">            <span class="comment">//如果mStayOn值改变，mDirty置位</span></span><br><span class="line">            mDirty |= DIRTY_STAY_ON;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="updatescreenbrightnessboostlocked"><a class="markdownIt-Anchor" href="#updatescreenbrightnessboostlocked"></a> <code>updateScreenBrightnessBoostLocked()</code></h4>
<p>该方法在PhoneWindowManager中触发，和亮度增强有关。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateScreenBrightnessBoostLocked</span><span class="params">(<span class="keyword">int</span> dirty)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((dirty &amp; DIRTY_SCREEN_BRIGHTNESS_BOOST) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mScreenBrightnessBoostInProgress) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                <span class="comment">//删除屏幕亮度提升超时广播</span></span><br><span class="line">                mHandler.removeMessages(MSG_SCREEN_BRIGHTNESS_BOOST_TIMEOUT);</span><br><span class="line">                <span class="keyword">if</span> (mLastScreenBrightnessBoostTime &gt; mLastSleepTime) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> boostTimeout = mLastScreenBrightnessBoostTime +</span><br><span class="line">                            SCREEN_BRIGHTNESS_BOOST_TIMEOUT;</span><br><span class="line">                    <span class="comment">//如果超时还没有发生，则重新发送广播</span></span><br><span class="line">                    <span class="keyword">if</span> (boostTimeout &gt; now) &#123;</span><br><span class="line">                        Message msg = mHandler.obtainMessage(MSG_SCREEN_BRIGHTNESS_BOOST_TIMEOUT);</span><br><span class="line">                        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                        mHandler.sendMessageAtTime(msg, boostTimeout);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//进行到这里有两个条件</span></span><br><span class="line">            <span class="comment">//mLastScreenBrightnessBoostTime &lt;= mLastSleepTime 说明还在睡眠中</span></span><br><span class="line">            <span class="comment">//boostTimeout &lt;= now 说明亮度提升超时发生</span></span><br><span class="line">                mScreenBrightnessBoostInProgress = <span class="keyword">false</span>;</span><br><span class="line">                mNotifier.onScreenBrightnessBoostChanged();</span><br><span class="line">                userActivityNoUpdateLocked(now,</span><br><span class="line">                        PowerManager.USER_ACTIVITY_EVENT_OTHER, <span class="number">0</span>, Process.SYSTEM_UID);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="updatewakelocksummarylocked"><a class="markdownIt-Anchor" href="#updatewakelocksummarylocked"></a> <code>updateWakeLockSummaryLocked()</code></h4>
<p>该方法会对所有的WakeLock锁进行统计，过滤所有的wakelock锁状态，并更新mWakeLockSummary的值以汇总所有活动的唤醒锁的状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateWakeLockSummaryLocked</span><span class="params">(<span class="keyword">int</span> dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((dirty &amp; (DIRTY_WAKE_LOCKS | DIRTY_WAKEFULNESS)) != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//mWakeLockSummary是一个用来记录所有WakeLock锁状态的标识值，该值在请求Display状时会用到。</span></span><br><span class="line">    mWakeLockSummary = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//numWakeLocks 保存了用户创建的所有 wakelock</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numWakeLocks = mWakeLocks.size();</span><br><span class="line">    <span class="comment">//在waklock集合中遍历wakelock</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numWakeLocks; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> WakeLock wakeLock = mWakeLocks.get(i);</span><br><span class="line">        <span class="keyword">switch</span> (wakeLock.mFlags &amp; PowerManager.WAKE_LOCK_LEVEL_MASK) &#123;</span><br><span class="line">            <span class="keyword">case</span> PowerManager.PARTIAL_WAKE_LOCK:</span><br><span class="line">                <span class="keyword">if</span> (!wakeLock.mDisabled) &#123;</span><br><span class="line">                    <span class="comment">// We only respect this if the wake lock is not disabled.</span></span><br><span class="line">                    <span class="comment">//如果存在PARTIAL_WAKE_LOCK并且该wakelock可用,</span></span><br><span class="line">                    <span class="comment">//通过置位进行记录，下同</span></span><br><span class="line">                    mWakeLockSummary |= WAKE_LOCK_CPU;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PowerManager.FULL_WAKE_LOCK:</span><br><span class="line">                mWakeLockSummary |= WAKE_LOCK_SCREEN_BRIGHT | </span><br><span class="line">                WAKE_LOCK_BUTTON_BRIGHT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PowerManager.SCREEN_BRIGHT_WAKE_LOCK:</span><br><span class="line">                mWakeLockSummary |= WAKE_LOCK_SCREEN_BRIGHT;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PowerManager.SCREEN_DIM_WAKE_LOCK:</span><br><span class="line">                mWakeLockSummary |= WAKE_LOCK_SCREEN_DIM;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PowerManager.PROXIMITY_SCREEN_OFF_WAKE_LOCK:</span><br><span class="line">                mWakeLockSummary |= </span><br><span class="line">                WAKE_LOCK_PROXIMITY_SCREEN_OFF;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PowerManager.DOZE_WAKE_LOCK:</span><br><span class="line">                mWakeLockSummary |= WAKE_LOCK_DOZE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PowerManager.DRAW_WAKE_LOCK:</span><br><span class="line">                mWakeLockSummary |= WAKE_LOCK_DRAW;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Cancel wake locks that make no sense based on the current state.</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设备不处于DOZE状态时，通过置位操作忽略相关类型wakelock</span></span><br><span class="line"><span class="comment">     * PowerManager.DOZE_WAKE_LOCK和WAKE_LOCK_DRAW锁仅仅</span></span><br><span class="line"><span class="comment">     * 在Doze状态下有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mWakefulness != WAKEFULNESS_DOZING) &#123;</span><br><span class="line">        mWakeLockSummary &amp;= ~(WAKE_LOCK_DOZE | WAKE_LOCK_DRAW);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果处于Doze状态，忽略三类Wakelock.</span></span><br><span class="line"><span class="comment">     * 如果处于睡眠状态，忽略四类wakelock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_ASLEEP</span><br><span class="line">            || (mWakeLockSummary &amp; WAKE_LOCK_DOZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        mWakeLockSummary &amp;= ~(WAKE_LOCK_SCREEN_BRIGHT | </span><br><span class="line">               WAKE_LOCK_SCREEN_DIM| WAKE_LOCK_BUTTON_BRIGHT);</span><br><span class="line">        <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_ASLEEP) &#123;</span><br><span class="line">            mWakeLockSummary &amp;= ~WAKE_LOCK_PROXIMITY_SCREEN_OFF;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据当前状态推断必要的wakelock</span></span><br><span class="line">    <span class="comment">//处于awake或dream(不处于asleep/doze)</span></span><br><span class="line">    <span class="keyword">if</span> ((mWakeLockSummary &amp; (WAKE_LOCK_SCREEN_BRIGHT | </span><br><span class="line">            WAKE_LOCK_SCREEN_DIM)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//处于awake状态，WAKE_LOCK_STAY_AWAKE只用于awake状态时</span></span><br><span class="line">        <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_AWAKE) &#123;</span><br><span class="line">            mWakeLockSummary |= WAKE_LOCK_CPU | </span><br><span class="line">            WAKE_LOCK_STAY_AWAKE;</span><br><span class="line">            <span class="comment">//处于屏保状态(dream)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_DREAMING) &#123;</span><br><span class="line">            mWakeLockSummary |= WAKE_LOCK_CPU;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((mWakeLockSummary &amp; WAKE_LOCK_DRAW) != <span class="number">0</span>) &#123;</span><br><span class="line">        mWakeLockSummary |= WAKE_LOCK_CPU;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="updateuseractivitysummarylocked"><a class="markdownIt-Anchor" href="#updateuseractivitysummarylocked"></a> <code>updateUserActivitySummaryLocked()</code></h4>
<p>该方法用来更新用户活动时间，当设备和用户有交互时，会根据当前时间和休眠时长、Dim时长、所处状态来计算下次休眠的时间，从而完成用户活动超时时的操作。关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateUserActivitySummaryLocked</span><span class="params">(<span class="keyword">long</span> now, <span class="keyword">int</span> dirty)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Update the status of the user activity timeout timer.</span></span><br><span class="line">    <span class="keyword">if</span> ((dirty &amp; (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY</span><br><span class="line">        | DIRTY_WAKEFULNESS | DIRTY_SETTINGS)) != <span class="number">0</span>) &#123;</span><br><span class="line">    mHandler.removeMessages(MSG_USER_ACTIVITY_TIMEOUT);</span><br><span class="line">    <span class="keyword">long</span> nextTimeout = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果处于休眠状态，则不会执行该方法</span></span><br><span class="line">    <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_AWAKE</span><br><span class="line">            || mWakefulness == WAKEFULNESS_DREAMING</span><br><span class="line">            || mWakefulness == WAKEFULNESS_DOZING) &#123;</span><br><span class="line">        <span class="comment">//设备完全进入休眠所需时间，该值为-1表示禁用此值，默认-1</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sleepTimeout = getSleepTimeoutLocked();</span><br><span class="line">        <span class="comment">//用户超时时间，既经过一段时间不活动进入休眠或屏保的时间，特殊情况外，该值为Settings中的休眠时长</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> screenOffTimeout = getScreenOffTimeoutLocked(sleepTimeout);</span><br><span class="line">        <span class="comment">//Dim(暗淡)时长，即亮屏不操作，变暗多久休眠</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> screenDimDuration =  </span><br><span class="line">          getScreenDimDurationLocked(screenOffTimeout);</span><br><span class="line">        <span class="comment">//通过WindowManager的用户交互</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> userInactiveOverride = </span><br><span class="line">            mUserInactiveOverrideFromWindowManager;</span><br><span class="line">        mUserActivitySummary = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//1.亮屏；2.亮屏后进行用户活动</span></span><br><span class="line">        <span class="keyword">if</span> (mLastUserActivityTime &gt;= mLastWakeTime) &#123;</span><br><span class="line">            <span class="comment">//下次睡眠时间=上次用户活动时间+休眠时间-Dim时间</span></span><br><span class="line">            nextTimeout = mLastUserActivityTime</span><br><span class="line">                + screenOffTimeout - screenDimDuration;</span><br><span class="line">            <span class="comment">//如果满足当前时间&lt;下次屏幕超时时间，说明此时设备为亮屏状态，则将用户活动状态置为表示亮屏的USER_ACTIVITY_SCREEN_BRIGHT</span></span><br><span class="line">            <span class="keyword">if</span> (now &lt; nextTimeout) &#123;</span><br><span class="line">                mUserActivitySummary = USER_ACTIVITY_SCREEN_BRIGHT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果当前时间&gt;下次活动时间，此时应有两种情况：已经休眠和Dim</span></span><br><span class="line">                nextTimeout = mLastUserActivityTime + screenOffTimeout;</span><br><span class="line">                <span class="comment">//如果当前时间&lt;上次活动时间+屏幕超时时间，这个值约为3s,说明此时设备为Dim状态，则将用户活动状态置为表示Dim的USER_ACTIVITY_SCREEN_DIM</span></span><br><span class="line">                <span class="keyword">if</span> (now &lt; nextTimeout) &#123;</span><br><span class="line">                    mUserActivitySummary = USER_ACTIVITY_SCREEN_DIM;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        .....</span><br><span class="line">        <span class="comment">//发送定时Handler，到达时间后再次进行updatePowerStateLocked()</span></span><br><span class="line">        <span class="keyword">if</span> (mUserActivitySummary != <span class="number">0</span> &amp;&amp; nextTimeout &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Message msg = </span><br><span class="line">                 mHandler.obtainMessage(MSG_USER_ACTIVITY_TIMEOUT);</span><br><span class="line">                 msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                 mHandler.sendMessageAtTime(msg, nextTimeout);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          mUserActivitySummary = <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="updatewakefulnesslocked"><a class="markdownIt-Anchor" href="#updatewakefulnesslocked"></a> <code>updateWakefulnessLocked()</code></h4>
<p>在updatePowerStateLocked()方法中，设置了一个死循环，并且上述分析的两个方法都在死循环中执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dirtyPhase1 = mDirty;</span><br><span class="line">                dirtyPhase2 |= dirtyPhase1;</span><br><span class="line">                mDirty = <span class="number">0</span>;</span><br><span class="line">updateWakeLockSummaryLocked(dirtyPhase1);<span class="comment">//更新统计wakelock的标记值mWakeLockSummary</span></span><br><span class="line">            updateUserActivitySummaryLocked(now, dirtyPhase1);<span class="comment">//更新统计userActivity的标记值mUserActivitySummary和休眠到达时间</span></span><br><span class="line">            <span class="keyword">if</span> (!updateWakefulnessLocked(dirtyPhase1)) &#123;<span class="comment">//更新屏幕唤醒状态，状态改变返回true</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>而<code>updateWakefulnessLocked()</code>方法是退出循环的关键，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateWakefulnessLocked</span><span class="params">(<span class="keyword">int</span> dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> ((dirty &amp; (DIRTY_WAKE_LOCKS | DIRTY_USER_ACTIVITY | </span><br><span class="line">        DIRTY_BOOT_COMPLETED</span><br><span class="line">        | DIRTY_WAKEFULNESS | DIRTY_STAY_ON | </span><br><span class="line">        DIRTY_PROXIMITY_POSITIVE</span><br><span class="line">        | DIRTY_DOCK_STATE)) != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//当前屏幕保持唤醒&amp;&amp;设备将要退出唤醒状态(睡眠or屏保)</span></span><br><span class="line">           <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_AWAKE &amp;&amp; isItBedTimeYetLocked()) &#123;</span><br><span class="line">               <span class="comment">//isItBedTimeYetLocked()方法判断当前设备是否将要进入睡眠状态。</span></span><br><span class="line">               Slog.d(TAG, <span class="string">&quot;updateWakefulnessLocked: Bed time...&quot;</span>);</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> time = SystemClock.uptimeMillis();</span><br><span class="line">               <span class="comment">//是否在休眠时启用屏保</span></span><br><span class="line">               <span class="keyword">if</span> (shouldNapAtBedTimeLocked()) &#123;</span><br><span class="line">                  <span class="comment">//进入屏保，返回true</span></span><br><span class="line">                  changed = napNoUpdateLocked(time, Process.SYSTEM_UID);</span><br><span class="line">                  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     <span class="comment">//进入睡眠，返回true</span></span><br><span class="line">                     changed = goToSleepNoUpdateLocked(time,</span><br><span class="line">                     PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, <span class="number">0</span>, </span><br><span class="line">                     Process.SYSTEM_UID);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法用于更新设备的wakefulness，同时，这个方法是亮屏到屏保/睡眠的决策点。<code>wakefulness</code>是用来表示当前设备状态的一个值，系统定义的wakefulness值共有四种，分别表示不同的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//睡眠状态，此时灭屏</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAKEFULNESS_ASLEEP = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//屏幕亮</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAKEFULNESS_AWAKE = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//屏保</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAKEFULNESS_DREAMING = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//处于DOZE模式时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAKEFULNESS_DOZING = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p><code>isItBedTimeYetLocked()</code>方法，该方法判断当前设备是否将要进入睡眠状态，返回值为对<code>isBeKeptAwakeLocke()</code>方法返回值取反，由<code>mStayOn(是否屏幕常亮)、wakelockSummary、userActivitySummary、mProximityPositive</code>等决定，只要满足其中之一为ture,则说明无法进入睡眠，也就说，要满足进入睡眠，相关属性值都为false。<code>isBeKeptAwakeLocke()</code>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBeingKeptAwakeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> mStayOn<span class="comment">//屏幕是否保持常亮</span></span><br><span class="line">    || mProximityPositive<span class="comment">//接近传感器接近屏幕时为true</span></span><br><span class="line">    <span class="comment">//处于awake状态</span></span><br><span class="line">    || (mWakeLockSummary &amp; WAKE_LOCK_STAY_AWAKE) != <span class="number">0</span></span><br><span class="line">    <span class="comment">//屏幕处于亮屏或者dim状态</span></span><br><span class="line">    || (mUserActivitySummary &amp; (USER_ACTIVITY_SCREEN_BRIGHT</span><br><span class="line">            | USER_ACTIVITY_SCREEN_DIM)) != <span class="number">0</span>            </span><br><span class="line">    || mScreenBrightnessBoostInProgress;<span class="comment">//处于亮度增强中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>shoudNapAtBedTimeLocked()</code>方法用来判断设备是否进入屏保模式，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shouldNapAtBedTimeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//屏保是否开启</span></span><br><span class="line"><span class="keyword">return</span> mDreamsActivateOnSleepSetting <span class="comment">//屏保是否开启</span></span><br><span class="line">    || (mDreamsActivateOnDockSetting <span class="comment">//插入基座时是否开启屏保</span></span><br><span class="line">            &amp;&amp; mDockState != Intent.EXTRA_DOCK_STATE_UNDOCKED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上看来，之所以将<code>updateWakeLockSummaryLocked()</code>、<code>updateUserActivitySummaryLocked()</code>、<code>updateWakefulnessLocked()</code>三个方法放入<code>for(;;)</code>循环中，是因为它们共同决定了设备的状态，前两个方法是汇总状态，后一个方法是根据前两个方法汇总的值进行判断是否要改变当前的设备唤醒状态。</p>
<h4 id="updatedisplaypowerstatelocked"><a class="markdownIt-Anchor" href="#updatedisplaypowerstatelocked"></a> <code>updateDisplayPowerStateLocked()</code></h4>
<p>该方法用于更新设备显示状态，在这个方法中会计算出最终需要显示的亮度值和其他值，然后将这些值封装到DisplayPowerRequest对象中，向DisplayManagerService请求Display状态，完成屏幕亮度显示。</p>
<p>决定亮度的相关值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WindowManager覆盖的亮度值，如播放视频时调节亮度，-1表示禁止使用(未发现使用到)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScreenBrightnessOverrideFromWindowManager = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//SystemUI中设置的临时亮度值，自动亮度时无效，该值之所以是临时的，是因为当调节亮度进度条时，会调用到updateDisplayPowerLocked(),这里给它赋值；当手指放开时，调用updateSettingLocked(),这里又将它置为-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mTemporaryScreenBrightnessSettingOverride = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//Settings.System.SCREEN_BRIGHTNESS中的值，即反映给用户的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScreenBrightnessSetting;</span><br><span class="line"><span class="comment">//限定值,config.xml中配置</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScreenBrightnessSettingMinimum;<span class="comment">//0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScreenBrightnessSettingMaximum;<span class="comment">//255</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScreenBrightnessSettingDefault;<span class="comment">//102</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mScreenBrightnessForVrSettingDefault;<span class="comment">//86</span></span><br><span class="line"><span class="comment">//自动调节亮度调整值,-1～1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> mScreenAutoBrightnessAdjustmentSetting;</span><br><span class="line"><span class="comment">//Settings中的默认值，一般和config.xml中的默认值相同，也可能不同</span></span><br><span class="line">Settings.System.SCREEN_BRIGHTNESS</span><br></pre></td></tr></table></figure>
<p>最终显示的亮度值和所处的状态有关，如在自动亮度调节打开时、VR模式时、或者从一个视频播放窗口中调节亮度时，都对应有不同的值。<br />
在<code>updateDisplayPowerStateLocked()</code>方法中，用到了一个<code>DisplayPowerRequest</code>类的对象，这个类是<code>DisplayManageInternal</code>类中的一个内部类，专门用于<code>PowerManagerService</code>和<code>DisplayPowerController</code>交互。PMS中会将当前亮度、屏幕状态等多个值封装在这个对象中，然后调用<code>requestPowerState()</code>请求<code>DisplayPowerController</code>,从而完成显示更新。</p>
<p><code>DisplayPowerRequest</code>中定义的属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以理解为Display的‘策略‘，该值非常重要，决定了请求后屏幕的状态，有四个值:off，doze,dim,bright.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> policy;</span><br><span class="line"><span class="comment">// 如果为true，则PSensor会覆盖屏幕状态，当物体靠近时将其临时关闭直到物体移开。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> useProximitySensor;</span><br><span class="line"><span class="comment">// 屏幕亮度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> screenBrightness;</span><br><span class="line"><span class="comment">// 自动调节亮度值，-1(dimmer)至1(brighter)之间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">float</span> screenAutoBrightnessAdjustment;</span><br><span class="line"><span class="comment">// 如果screenBrightness和screenAutoBrightnessAdjustment 由用户设置，则为true</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> brightnessSetByUser;</span><br><span class="line"><span class="comment">// 是否使用了自动调节亮度</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> useAutoBrightness;</span><br><span class="line"><span class="comment">// 是否使用了低电量模式，该模式下亮度会减半</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> lowPowerMode;</span><br><span class="line"><span class="comment">// 在低电量模式下调整屏幕亮度的系数，0（screen off）至1(no change)之间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">float</span> screenLowPowerBrightnessFactor;</span><br><span class="line"><span class="comment">// 是否启动了亮度增强</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> boostScreenBrightness;</span><br><span class="line"><span class="comment">// 如果为true，则会在屏幕亮起时阻止屏幕完全亮起，窗口管理器策略在准备键盘保护程// 时阻止屏幕，以防止用户看到中间更新。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">boolean</span> blockScreenOn;</span><br><span class="line"><span class="comment">// 设备处于Doze状态下时覆盖的屏幕亮度和屏幕状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> dozeScreenBrightness;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> dozeScreenState;</span><br></pre></td></tr></table></figure>
<p>具体来说，<code>updateDisplayPowerStateLocked()</code>方法会封装应该DisplayPowerRequest对象请求交给DisplayManagerService处理，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateDisplayPowerStateLocked</span><span class="params">(<span class="keyword">int</span> dirty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> oldDisplayReady = mDisplayReady;</span><br><span class="line">    mDisplayPowerRequest.policy = getDesiredScreenPolicyLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//------------亮度值计算 -----------</span></span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 封装到DisplayPowerRequest中</span></span><br><span class="line">        mDisplayPowerRequest.screenBrightness = screenBrightness;</span><br><span class="line">        ......</span><br><span class="line">        <span class="comment">// 传给DisplayManagerService中处理</span></span><br><span class="line">        mDisplayManagerInternal.requestPowerState(mDisplayPowerRequest,</span><br><span class="line">                mRequestWaitForNegativeProximity);</span><br><span class="line">        ....</span><br><span class="line">    <span class="keyword">return</span> mDisplayReady &amp;&amp; !oldDisplayReady;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>getDesiredScreenPolicyLocked()</code>方法：</p>
<p>在请求 DisplayManagerService 时，会将所有的信息封装到 DisplayPowerRequest 对象中，其中需要注意 policy 值。policy 作为 DisplayPowerRequset 的属性，有四种值，分别为 off、doze、dim、bright、vr。在向 DisplayManagerService 请求时，会根据当前 PowerManagerService 中的唤醒状态和统计的 wakelock 来决定要请求的 Display 状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDesiredScreenPolicyLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//asleep时，policy值为0</span></span><br><span class="line">    <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_ASLEEP || sQuiescent) &#123;</span><br><span class="line">        <span class="keyword">return</span> DisplayPowerRequest.POLICY_OFF;<span class="comment">//0 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_DOZING) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mWakeLockSummary &amp; WAKE_LOCK_DOZE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> DisplayPowerRequest.POLICY_DOZE;<span class="comment">//1 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mDozeAfterScreenOffConfig) &#123;</span><br><span class="line">            <span class="keyword">return</span> DisplayPowerRequest.POLICY_OFF;<span class="comment">//2 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> ((mWakeLockSummary &amp; WAKE_LOCK_SCREEN_BRIGHT) != <span class="number">0</span></span><br><span class="line">            || (mUserActivitySummary &amp; USER_ACTIVITY_SCREEN_BRIGHT) != <span class="number">0</span></span><br><span class="line">            || !mBootCompleted</span><br><span class="line">            || mScreenBrightnessBoostInProgress) &#123;</span><br><span class="line">        <span class="keyword">return</span> DisplayPowerRequest.POLICY_BRIGHT;<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DisplayPowerRequest.POLICY_DIM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>requestPowerState()方法：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/display/DisplayManagerService.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestPowerState</span><span class="params">(DisplayPowerRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">boolean</span> waitForNegativeProximity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDisplayPowerController.requestPowerState(request,</span><br><span class="line">                                                     waitForNegativeProximity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DisplayPowerController.requestPowerState()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//frameworks/base/services/core/java/com/android/server/display/DisplayPowerController.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">requestPowerState</span><span class="params">(DisplayPowerRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">boolean</span> waitForNegativeProximity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (waitForNegativeProximity</span><br><span class="line">            &amp;&amp; !mPendingWaitForNegativeProximityLocked) &#123;</span><br><span class="line">            mPendingWaitForNegativeProximityLocked = <span class="keyword">true</span>;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//开机后第一次进入</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingRequestLocked == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mPendingRequestLocked = <span class="keyword">new</span> DisplayPowerRequest(request);</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mPendingRequestLocked.equals(request)) &#123;</span><br><span class="line">            <span class="comment">//如果该次请求和上次请求不同，说明已经改变，需要更新 Display</span></span><br><span class="line">            mPendingRequestLocked.copyFrom(request);</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * changed 为 true，说明有改变发生，这个改变交给 Handler 异步去处理，此时说</span></span><br><span class="line"><span class="comment">         * 明显示没有准备好，mDisplayReadyLocked = false</span></span><br><span class="line"><span class="comment">         * 直到改变处理成功，mDisplayReadyLocked 又被置为 true，</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            mDisplayReadyLocked = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//mPendingRequestChangedLocked：用于标识电源请求状态或者 PSensor 标签是否改变</span></span><br><span class="line">        <span class="keyword">if</span> (changed &amp;&amp; !mPendingRequestChangedLocked) &#123;</span><br><span class="line">            mPendingRequestChangedLocked = <span class="keyword">true</span>;</span><br><span class="line">            sendUpdatePowerStateLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mDisplayReadyLocked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该方法中，会判断请求时携带的DisplayPowerRequest对象是否和上一次请求的request对象相同，如果相同，则返回值mDisplayReadyLocked为true，如果不同则表示发生了改变，会异步请求新的Display状态，并返回false，表示Display状态正在更新中，直到更新完成mDisplayReadyLocked置为true。之后调用<code>PMS.onStateChange()</code>方法通知PMS Display状态更新完成。</p>
<p><code>sendUpdatePowerStateLocked()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendUpdatePowerStateLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mPendingUpdatePowerStateLocked) &#123;</span><br><span class="line">            mPendingUpdatePowerStateLocked = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//发送更新电源状态消息</span></span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_UPDATE_POWER_STATE);</span><br><span class="line">            mHandler.sendMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> MSG_UPDATE_POWER_STATE:</span><br><span class="line">                    updatePowerState();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h4 id="updatedreamlocked"><a class="markdownIt-Anchor" href="#updatedreamlocked"></a> <code>updateDreamLocked()</code></h4>
<p>该方法用来更新Dream（屏保）状态，比如是否继续屏保、Doze或者休眠。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateDreamLocked</span><span class="params">(<span class="keyword">int</span> dirty, <span class="keyword">boolean</span> displayBecameReady)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((dirty &amp; (DIRTY_WAKEFULNESS</span><br><span class="line">            | DIRTY_USER_ACTIVITY</span><br><span class="line">            | DIRTY_WAKE_LOCKS</span><br><span class="line">            | DIRTY_BOOT_COMPLETED</span><br><span class="line">            | DIRTY_SETTINGS</span><br><span class="line">            | DIRTY_IS_POWERED</span><br><span class="line">            | DIRTY_STAY_ON</span><br><span class="line">            | DIRTY_PROXIMITY_POSITIVE</span><br><span class="line">            | DIRTY_BATTERY_STATE)) != <span class="number">0</span> || displayBecameReady) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDisplayReady) &#123;<span class="comment">//mDisplayReady为上个方法请求Display时的返回值，表示Display是否就绪。</span></span><br><span class="line">            <span class="comment">//通过Handler异步发送一个消息</span></span><br><span class="line">            scheduleSandmanLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>scheduleSandmanLocked()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleSandmanLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSandmanScheduled) &#123;</span><br><span class="line">        <span class="comment">//由于是异步处理，因此表示是否已经调用该方法且没有被handler处理,如果为true就不会进入该方法了</span></span><br><span class="line">        mSandmanScheduled = <span class="keyword">true</span>;</span><br><span class="line">        Message msg = mHandler.obtainMessage(MSG_SANDMAN);</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        mHandler.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_SANDMAN:</span><br><span class="line">    handleSandman();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><code>handleSandman()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSandman</span><span class="params">()</span> </span>&#123; <span class="comment">// runs on handler thread</span></span><br><span class="line">    <span class="comment">//是否开始进入屏保</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> startDreaming;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> wakefulness;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//为false后下次updateDreamLocked()可处理</span></span><br><span class="line">        mSandmanScheduled = <span class="keyword">false</span>;</span><br><span class="line">        wakefulness = mWakefulness;</span><br><span class="line">        <span class="comment">//在进入asleep状态后该值为true,用于判断是否处于Dream状态</span></span><br><span class="line">        <span class="keyword">if</span> (mSandmanSummoned &amp;&amp; mDisplayReady) &#123;</span><br><span class="line">            <span class="comment">//当前状态能否进入Dream || 当前wakefulness状态为Doze</span></span><br><span class="line">            startDreaming = canDreamLocked() || canDozeLocked();</span><br><span class="line">            mSandmanSummoned = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startDreaming = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//表示是否正在屏保</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isDreaming;</span><br><span class="line">    <span class="keyword">if</span> (mDreamManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//重启屏保</span></span><br><span class="line">        <span class="keyword">if</span> (startDreaming) &#123;</span><br><span class="line">            mDreamManager.stopDream(<span class="keyword">false</span> <span class="comment">/*immediate*/</span>);</span><br><span class="line">            mDreamManager.startDream(wakefulness == WAKEFULNESS_DOZING);</span><br><span class="line">        &#125;</span><br><span class="line">        isDreaming = mDreamManager.isDreaming();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isDreaming = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//记录进入屏保时的电池电量</span></span><br><span class="line">        <span class="keyword">if</span> (startDreaming &amp;&amp; isDreaming) &#123;</span><br><span class="line">            mBatteryLevelWhenDreamStarted = mBatteryLevel;</span><br><span class="line">            <span class="keyword">if</span> (wakefulness == WAKEFULNESS_DOZING) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">&quot;Dozing...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">&quot;Dreaming...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果mSandmanSummoned改变或者wakefulness状态改变，则return等待下次处理</span></span><br><span class="line">        <span class="keyword">if</span> (mSandmanSummoned || mWakefulness != wakefulness) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// wait for next cycle</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//决定是否继续Dream</span></span><br><span class="line">        <span class="keyword">if</span> (wakefulness == WAKEFULNESS_DREAMING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDreaming &amp;&amp; canDreamLocked()) &#123;</span><br><span class="line">                <span class="comment">//表示从开启屏保开始电池电量下降这个值就退出屏保，-1表示禁用该值</span></span><br><span class="line">                <span class="keyword">if</span> (mDreamsBatteryLevelDrainCutoffConfig &gt;= <span class="number">0</span></span><br><span class="line">                        &amp;&amp; mBatteryLevel &lt; mBatteryLevelWhenDreamStarted</span><br><span class="line">                                - mDreamsBatteryLevelDrainCutoffConfig</span><br><span class="line">                        &amp;&amp; !isBeingKeptAwakeLocked()) &#123;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span>; <span class="comment">// continue dreaming</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//退出屏保，进入Doze状态</span></span><br><span class="line">            <span class="keyword">if</span> (isItBedTimeYetLocked()) &#123;</span><br><span class="line">                goToSleepNoUpdateLocked(SystemClock.uptimeMillis(),</span><br><span class="line">                        PowerManager.GO_TO_SLEEP_REASON_TIMEOUT, <span class="number">0</span>, </span><br><span class="line">                        Process.SYSTEM_UID);</span><br><span class="line">                updatePowerStateLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//唤醒设备，reason为android.server.power:DREAM</span></span><br><span class="line">                wakeUpNoUpdateLocked(SystemClock.uptimeMillis(), </span><br><span class="line">                        <span class="string">&quot;android.server.power:DREAM&quot;</span>,</span><br><span class="line">                        Process.SYSTEM_UID, mContext.getOpPackageName(), </span><br><span class="line">                        Process.SYSTEM_UID);</span><br><span class="line">                updatePowerStateLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//如果处于Doze状态,在power键灭屏时，首次会将wakefulness设置为该值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (wakefulness == WAKEFULNESS_DOZING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDreaming) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// continue dozing</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进入asleep状态</span></span><br><span class="line">            reallyGoToSleepNoUpdateLocked(SystemClock.uptimeMillis(), </span><br><span class="line">                 Process.SYSTEM_UID);</span><br><span class="line">            updatePowerStateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果正处在Dream，则只要触发updatePowerStateLocked(),立即退出Dream</span></span><br><span class="line">    <span class="keyword">if</span> (isDreaming) &#123;</span><br><span class="line">        mDreamManager.stopDream(<span class="keyword">false</span> <span class="comment">/*immediate*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="finishwakefulnesschangeifneededlocked"><a class="markdownIt-Anchor" href="#finishwakefulnesschangeifneededlocked"></a> <code>finishWakefulnessChangeIfNeededLocked()</code></h4>
<p>该方法主要做<code>updateWakefulnessLocked()</code>方法的结束工作，当屏幕状态改变后，才会执行该方法。</p>
<p>**屏幕状态：**唤醒（awake）、休眠（asleep）、屏保（dream）、打盹（doze）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishWakefulnessChangeIfNeededLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWakefulnessChanging &amp;&amp; mDisplayReady) &#123;</span><br><span class="line">        <span class="comment">//如果当前处于Doze状态，不进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_DOZING</span><br><span class="line">                &amp;&amp; (mWakeLockSummary &amp; WAKE_LOCK_DOZE) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// wait until dream has enabled dozing</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_DOZING || mWakefulness == </span><br><span class="line">                WAKEFULNESS_ASLEEP) &#123;</span><br><span class="line">            logSleepTimeoutRecapturedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mWakefulness == WAKEFULNESS_AWAKE) &#123;</span><br><span class="line">            logScreenOn();<span class="comment">//打印整个亮屏流程的耗时</span></span><br><span class="line">        &#125;</span><br><span class="line">        mWakefulnessChanging = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//通过Notifier进行wakefulness改变后的处理</span></span><br><span class="line">        mNotifier.onWakefulnessChangeFinished();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="updatesuspendblockerlocked"><a class="markdownIt-Anchor" href="#updatesuspendblockerlocked"></a> <code>updateSuspendBlockerLocked()</code></h4>
<p>该方法用以更新SuspendBlocker锁的状态。通过Suspend锁向Hal层写入节点，Kernal层读取节点，从而唤醒或休眠CPU。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">淋竹</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.llscme.fun/2021/08/12/PMS/">https://www.llscme.fun/2021/08/12/PMS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.llscme.fun" target="_blank">淋竹调</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422121222.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422121644.JPG" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422121644.JPG" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422121656.JPG" target="_blank"><img class="post-qr-code-img" src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422121656.JPG" alt="支付寶"/></a><div class="post-qr-code-desc">支付寶</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/08/12/WakeLock%20%E9%94%81%E6%9C%BA%E5%88%B6/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/post.PNG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">WakeLock锁机制</div></div></a></div><div class="next-post pull-right"><a href="/2021/08/12/Android%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/post.PNG" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android第一行代码阅读笔记</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200422121222.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">淋竹</div><div class="author-info__description">冥然兀坐，万籁有声</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">186</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://www.douban.com/people/144948848/" target="_blank" title=""><i class="fas fa-cannabis"></i></a><a class="social-icon" href="mailto:3318417130@qq.com" target="_blank" title="Email"><i class="fa fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fa fa-rss"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#pms"><span class="toc-number">1.</span> <span class="toc-text"> PMS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-pms%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 1、PMS的启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1.1、核心方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#updatepowerstatelocked"><span class="toc-number">1.1.2.</span> <span class="toc-text"> updatePowerStateLocked()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#updateispoweredlocked"><span class="toc-number">1.1.2.1.</span> <span class="toc-text"> updateIsPoweredLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updatestayonlocked"><span class="toc-number">1.1.2.2.</span> <span class="toc-text"> updateStayOnLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updatescreenbrightnessboostlocked"><span class="toc-number">1.1.2.3.</span> <span class="toc-text"> updateScreenBrightnessBoostLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updatewakelocksummarylocked"><span class="toc-number">1.1.2.4.</span> <span class="toc-text"> updateWakeLockSummaryLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateuseractivitysummarylocked"><span class="toc-number">1.1.2.5.</span> <span class="toc-text"> updateUserActivitySummaryLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updatewakefulnesslocked"><span class="toc-number">1.1.2.6.</span> <span class="toc-text"> updateWakefulnessLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updatedisplaypowerstatelocked"><span class="toc-number">1.1.2.7.</span> <span class="toc-text"> updateDisplayPowerStateLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updatedreamlocked"><span class="toc-number">1.1.2.8.</span> <span class="toc-text"> updateDreamLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finishwakefulnesschangeifneededlocked"><span class="toc-number">1.1.2.9.</span> <span class="toc-text"> finishWakefulnessChangeIfNeededLocked()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updatesuspendblockerlocked"><span class="toc-number">1.1.2.10.</span> <span class="toc-text"> updateSuspendBlockerLocked()</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/08/12/Git/" title="Git">Git</a><time datetime="2021-08-12T13:10:17.152Z" title="发表于 2021-08-12 21:10:17">2021-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/08/12/PMS%E4%BA%AE%E7%81%AD%E5%B1%8F%E6%B5%81%E7%A8%8B/" title="PMS亮灭屏流程">PMS亮灭屏流程</a><time datetime="2021-08-12T13:10:17.151Z" title="发表于 2021-08-12 21:10:17">2021-08-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/08/12/WakeLock%20%E9%94%81%E6%9C%BA%E5%88%B6/" title="WakeLock锁机制">WakeLock锁机制</a><time datetime="2021-08-12T13:10:17.150Z" title="发表于 2021-08-12 21:10:17">2021-08-12</time></div></div></div></div></div></div></main><footer id="footer" style="background: black"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 淋竹</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    let initData = {
      el: '#vcomment',
      appId: 'ro2oJ2Di6Fom23rR8oQOBipn-MdYXbMMI',
      appKey: 'vMbUHw76aCpeeBF9hs3NCcsj',
      placeholder: '来了就坐一会吧，喝杯茶说说话^_^',
      avatar: 'mp',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }
    
    if (false) {
      const otherData = false
      initData = Object.assign(initData, otherData)
    }
    
    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>(function(d, w, c) {
    w.ChatraID = '52XccyiPykL6RRQ8b';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (false) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (false) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script>(function(){
  const bp = document.createElement('script');
  const curProtocol = window.location.protocol.split(':')[0];
  if (curProtocol === 'https') {
    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
  bp.dataset.pjax = ''
  const s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(bp, s);
})()</script></div></body></html>