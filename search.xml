<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客创建与迁移</title>
    <url>/2021/07/25/Hexo%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%E4%B8%8E%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="hexo博客创建与迁移"><a class="markdownIt-Anchor" href="#hexo博客创建与迁移"></a> Hexo博客创建与迁移</h1>
<h2 id="创建篇"><a class="markdownIt-Anchor" href="#创建篇"></a> 创建篇</h2>
<h3 id="1-git环境配置"><a class="markdownIt-Anchor" href="#1-git环境配置"></a> 1、git环境配置</h3>
<p><strong>1.1、git下载链接：<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgit-scm.com%2Fdownloads">git-scm.com/downloads</a></strong></p>
<p>由于博客基于Github pages/gitee搭建，因此需要git环境推送博客文章。</p>
<p>打开git bash，运行如下命令配置GitHub。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>1.2、链接到远程环境</strong></p>
<p>在git bash运行如下命令生成密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>回车三次，即生成密钥，分别是秘钥和公钥，这里我们需要用到公钥，它被保存在了<code>C/Users/xxx/.ssh/id_rsa.pub</code> (windows)或者<code>~/.ssh/id_rsa.pub</code>(linux)中，找到并打开<code>id_rsa.pub</code>文件。</p>
<p>登录github，在网页的右上角，点击三角形，进入<code>Setting</code>页面，随后进入<code>SSH and GPG keys</code>一栏，点击<code>New SSH key</code>。在<code>Title</code>框内给这个key取个名字，然后把<code>id_rsa.pub</code>的内容复制进去并保存。</p>
<p><strong>1.3、测试连接</strong></p>
<p>在linux的终端或者windows的git bash中输入<code>ssh -T git@github.com</code>，在看到提示后输入<code>yes</code>，如果在之后弹出的内容中提示的用户名是你的，说明SSH key已经匹配成功了，接下来就可以使用github了</p>
<h3 id="2-创建个人网站仓库"><a class="markdownIt-Anchor" href="#2-创建个人网站仓库"></a> 2、创建个人网站仓库</h3>
<p>登录github，点击<code>New repository</code>创建新仓库，命名为<code>用户名.github.io</code>，注意这里<strong>一定</strong>要用你github账号的<strong>用户名</strong></p>
<h3 id="3-获取个人网站域名可选"><a class="markdownIt-Anchor" href="#3-获取个人网站域名可选"></a> 3、获取个人网站域名（可选）</h3>
<p>这一步不是必须，即使你没有注册自己的域名，也可以在配置完成后，通过访问<code>xxx.github.io</code>来查看自己的blog。但是域名是一个网站的入口，好记且有个人标识的域名，你值得拥有。比较简便的注册域名的途径是<a href="https://wanwang.aliyun.com/domain/">阿里云</a>和<a href="https://dnspod.cloud.tencent.com/">腾讯云</a>。</p>
<h3 id="4-hexo安装与部署"><a class="markdownIt-Anchor" href="#4-hexo安装与部署"></a> 4、Hexo安装与部署</h3>
<p><strong>4.1、Node.js安装</strong></p>
<p>我们选用的是Hexo，一款基于<code>Node.js</code>的静态博客框架，因此需要安装<code>Node.js</code></p>
<ul>
<li>
<p>Windows：　从<a href="https://nodejs.org/en/download/">这里</a>下载安装包并安装。该安装包除了<code>Node.js</code>还会一并安装<code>npm</code>，安装完成后，可以通过在命令行（注意不是git bash）输入<code>node -v</code>和<code>npm -v</code>检查<code>Node.js</code>及<code>npm</code>是否安装成功，如果显示版本数字，则表示已经安装成功。</p>
<p>添加国内镜像源：如果没有梯子的话，可以使用阿里的国内镜像进行加速。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Linux：</p>
<p>安装<code>npm</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install npm</span><br></pre></td></tr></table></figure>
<p>升级<code>npm</code>为最新版：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install npm@latest -g</span><br></pre></td></tr></table></figure>
<p>安装用于安装<code>Node.js</code>的模块<code>n</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo npm install -g n</span><br></pre></td></tr></table></figure>
<p>然后通过<code>n</code>模块安装稳定版本的<code>Node.js</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo n stable</span><br></pre></td></tr></table></figure>
<p>用与Windows同样的方法，检查<code>Node.js</code>和<code>npm</code>是否安装成功</p>
</li>
</ul>
<p><strong>4.2 、安装Hexo</strong></p>
<p>在windows的命令行窗口（或git cmd）或linux的终端中输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p><strong>4.3、初始化博客</strong></p>
<p>在Hexo安装完成后，用<code>cd</code>前往你想要放blog文件的文件夹，初始化blog，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init </span><br></pre></td></tr></table></figure>
<p>随后生成静态文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<p>启动本地服务器预览：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>之后在浏览器中访问<code>localhost:4000</code></p>
<p><strong>4.4、部署到github pages</strong></p>
<p>在初始化blog的文件夹中，找到站点配置文件<code>_config.yml</code>，把这个文件打开，翻到最后修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/blog/_config.yml <span class="built_in">type</span>: git</span><br><span class="line">repo: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure>
<p>最后安装git部署插件，运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>此时在命令行中依次输入三个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean </span><br><span class="line">$ hexo g </span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<p>随后用浏览器访问<code>xxx.github.io</code>，如果看到与本地服务器同行的页面，就说明你的blog现在可以在网络中被访问了</p>
<h3 id="5-域名绑定"><a class="markdownIt-Anchor" href="#5-域名绑定"></a> 5、域名绑定</h3>
<p>腾讯云/阿里云 添加相应的解析记录。</p>
<p>第一条解析记录类型为Ａ，主机记录填@，记录值为你的github个人主页(<a href="http://xxx.github.io/">xxx.github.io</a>)的ip地址（<a href="http://xxx.xxx.xxx.xxx/">xxx.xxx.xxx.xxx</a>）。要获取该地址，你可以在命令行或终端中输入<code>ping xxx.github.io</code>来查看</p>
<p>第二条解析记录类型为CNAME，主机记录为www，记录值为你的github个人主页网址。</p>
<p>第二步，登录github，进入你创建的<code>xxx.github.io</code>仓库，点击仓库的<code>setting</code>，在<code>Options</code>一栏中往下翻，找到<code>Github Page</code>，在<code>Custom domain</code>中填入自己注册好的域名，然后点击<code>save</code>保存</p>
<h2 id="迁移篇"><a class="markdownIt-Anchor" href="#迁移篇"></a> 迁移篇</h2>
<h3 id="1-配置基础环境"><a class="markdownIt-Anchor" href="#1-配置基础环境"></a> 1、配置基础环境</h3>
<p>要配置基础环境，需要做以下几个步骤</p>
<ol>
<li>安装<code>git</code>，并生成密钥，保存到github账号中</li>
<li>下载并安装<code>Node.js</code>（<code>npm</code>会自己跟着装好）</li>
<li>使用<code>npm</code>安装<code>hexo</code> ，具体指令为<code>npm install -g hexo-cli</code></li>
</ol>
<p>具体如上创建篇。</p>
<p>❗️ 注意，安装完<code>hexo</code>之后不用<code>hexo init</code></p>
<h3 id="2-迁移相关文件"><a class="markdownIt-Anchor" href="#2-迁移相关文件"></a> 2、迁移相关文件</h3>
<p>需要迁移的文件只有：</p>
<ol>
<li>博客配置文件<code>./_config.yml</code></li>
<li>主题配置文件夹<code>./theme/</code></li>
<li>文章及相关内容的文件夹<code>./source/</code></li>
<li>模板文件夹<code>./scaffolds/</code></li>
<li>记录博客所有的插件的文件<code>./package.json</code></li>
</ol>
<h3 id="3-在新电脑中重新部署"><a class="markdownIt-Anchor" href="#3-在新电脑中重新部署"></a> 3、在新电脑中重新部署</h3>
<p>还记得上一步中拷贝的<code>./package.json</code>嘛，只要在同一文件目录下运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure>
<p>就会自动读取<code>package.json</code>文件中记录的插件列表，然后挨个安装，这样你在旧设备中安装的插件，在新设备中，都安装好了</p>
<p>之后的一切就照常，修改文章，生成静态文件，部署到git</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<h2 id="图床配置"><a class="markdownIt-Anchor" href="#图床配置"></a> 图床配置</h2>
<p>1、下载PicGo图床工具：<a href="%5Bhttps://picgo.github.io/PicGo-Doc/zh/guide/#%E7%89%B9%E8%89%B2%E5%8A%9F%E8%83%BD%5D(https://picgo.github.io/PicGo-Doc/zh/guide/#%E7%89%B9%E8%89%B2%E5%8A%9F%E8%83%BD)">下载</a></p>
<p>2、打开PicGo，插件设置搜索Gitee，安装并配置如下。</p>
<img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/giteeuploader.PNG" style="zoom: 67%;" />
<p><em>参考文献</em></p>
<p>1、<a href="https://swayye.xyz/2018/12/28/%E5%BB%BA%E7%AB%99%E5%8E%86%E7%A8%8B%EF%BC%9A%E5%AE%89%E8%A3%85%E5%8F%8A%E9%83%A8%E7%BD%B2%E7%AF%87/">建站历程：安装及部署篇</a></p>
<p>2、<a href="https://blog.csdn.net/chenguolinblog/article/details/19929509">Linux下Git和GitHub使用方法总结</a></p>
<p>3、<a href="https://segmentfault.com/a/1190000007542620">在ubuntu上安装最新稳定版本的node及npm</a></p>
<p>4、<a href="https://zhuanlan.zhihu.com/p/26625249">GitHub+Hexo 搭建个人网站详细教程</a></p>
<p>5、<a href="https://www.jianshu.com/p/f2285d63b3a8">在github上搭建hexo个人博客（Linux-Ubuntu）</a></p>
]]></content>
      <categories>
        <category>环境搭建杂记</category>
      </categories>
  </entry>
  <entry>
    <title>验证回文字符串Ⅱ</title>
    <url>/2021/07/24/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%85%A1/</url>
    <content><![CDATA[<h1 id="验证回文字符串ii"><a class="markdownIt-Anchor" href="#验证回文字符串ii"></a> 验证回文字符串Ⅱ</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=s.length()-<span class="number">1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(j))&#123;<span class="comment">//不回文，右删除或右删除一位继续判断是否回文。</span></span><br><span class="line">                <span class="keyword">return</span> isPalindrome(s,i+<span class="number">1</span>,j)||isPalindrome(s,i,j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//回文</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i++)!=s.charAt(j--))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>非递减数列</title>
    <url>/2021/07/24/%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="非递减数列"><a class="markdownIt-Anchor" href="#非递减数列"></a> 非递减数列</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给你一个长度为 <code>n</code> 的整数数组，请你判断在 <strong>最多</strong> 改变 <code>1</code> 个元素的情况下，该数组能否变成一个非递减数列。</p>
<p>我们是这样定义一个非递减数列的： 对于数组中所有的 <code>i</code> <code>(0 &lt;= i &lt;= n-2)</code>，总满足 <code>nums[i] &lt;= nums[i + 1]</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [4,2,3]</span><br><span class="line">输出: true</span><br><span class="line">解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</span><br><span class="line"></span><br><span class="line">输入: nums = [4,2,1]</span><br><span class="line">输出: false</span><br><span class="line">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</span><br></pre></td></tr></table></figure>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPossi</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length&amp;&amp;cnt&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]&gt;=nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出现了非递减，调整</span></span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(i-<span class="number">2</span>&gt;=<span class="number">0</span>&amp;&amp;nums[i-<span class="number">2</span>]&gt;nums[i])&#123;<span class="comment">//举例：6,9,5(i)----6，9，9</span></span><br><span class="line">            nums[i]=nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            nums[i-<span class="number">1</span>]=nums[i];<span class="comment">//5，3（i），8-----3，3，8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt&lt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>除自身以外数组的乘积</title>
    <url>/2021/07/24/%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="除自身以外数组的乘积"><a class="markdownIt-Anchor" href="#除自身以外数组的乘积"></a> 除自身以外数组的乘积</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。<br />
输入: [1,2,3,4]<br />
输出: [24,12,8,6]</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>对于给定索引 i，我们将使用它左边所有数字的乘积乘以右边所有数字的乘积得到除自身以外数组的乘积。</p>
<p>初始化两个空数组 L 和 R。对于给定索引 i，L[i] 代表的是 i 左侧所有数字的乘积，R[i] 代表的是 i 右侧所有数字的乘积。<br />
我们需要用两个循环来填充 L 和 R 数组的值。对于数组 L，L[0] 应该是 1，因为第一个元素的左边没有元素。对于其他元素：L[i] = L[i-1] * nums[i-1]。<br />
同理，对于数组 R，R[length-1] 应为 1。length 指的是输入数组的大小。其他元素：R[i] = R[i+1] * nums[i+1]。<br />
当 R 和 L 数组填充完成，我们只需要在输入数组上迭代，且索引 i 处的值为：L[i] * R[i]。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] L=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] R=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        L[<span class="number">0</span>]=<span class="number">1</span>,R[len-<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            L[i]=L[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">2</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            R[j]=R[j+<span class="number">1</span>]*nums[j+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;len;k++)&#123;</span><br><span class="line">            res[k]=L[k]*R[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>
<p>优化，对R不构建数组,L用res表示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">            res[i]=res[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> R=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=len-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            res[j]*=R;</span><br><span class="line">            R*=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式谈</title>
    <url>/2021/07/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%B0%88/</url>
    <content><![CDATA[<h1 id="设计模式谈"><a class="markdownIt-Anchor" href="#设计模式谈"></a> 设计模式谈</h1>
<h2 id="1-单例模式"><a class="markdownIt-Anchor" href="#1-单例模式"></a> 1、单例模式</h2>
<p>**定义：**确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。【是线程安全的】</p>
<p><strong>使用场景：</strong></p>
<p>1、要求生成唯一序列号的环境。</p>
<p>2、在整个项目中需要一个共享访问点或共享数据。例如一个 Web 页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的。</p>
<p>3、创建一个对象需要的资源过多。如要访问IO和数据库资源。</p>
<p>4、需要定义大量的静态常量和静态方法。（如工具类）</p>
<h2 id="2-工厂模式"><a class="markdownIt-Anchor" href="#2-工厂模式"></a> 2、工厂模式</h2>
<p>**定义：**定义一个用以创建对象的接口，让子类决定实例化哪一个类。</p>
<p>**使用场景：**jdbc连接数据库、硬件访问、降低对象的产生和销毁。</p>
<h2 id="3-抽象工厂模式"><a class="markdownIt-Anchor" href="#3-抽象工厂模式"></a> 3、抽象工厂模式</h2>
<p>**定义：**为<u>创建一组相关或相互依赖的对象</u>提供一个接口，而且无需指定他们的具体类。</p>
<p><strong>使用场景</strong>：</p>
<p>1、一个对象族（或是一组没有任何关系的对象）有着相同的约束。</p>
<p>2、涉及到不同的操作系统。</p>
<h2 id="4-模板方法模式"><a class="markdownIt-Anchor" href="#4-模板方法模式"></a> 4、模板方法模式</h2>
<p>**定义：**定义一个操作中算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的框架即可重定义算法的某个具体步骤。</p>
<p><strong>使用场景</strong>：</p>
<p>1、多个子类有公共的方法，并且逻辑相同。</p>
<p>2、重要复杂的算法可以把核心方法设计成模板方法，周边的相关细节则由功能则由各个子类具体实现。</p>
<p>3、重构时，模板方法是一个经常使用的方式。把相同的方法抽取到父类中，然后通过钩子函数约束其行为。</p>
<h2 id="5-建造者模式"><a class="markdownIt-Anchor" href="#5-建造者模式"></a> 5、建造者模式</h2>
<p>**定义：**将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p><strong>使用场景</strong>：</p>
<p>1、相同的方法、不同的执行顺序，产生不同的事件结果时，可以使用建造者模式。</p>
<p>2、多个部件或零件可以装配到一个对象中，但是产生的运行结果又不相同时，可以使用建造者模式。</p>
<p>3、产品类非常复杂、或者产品类中的调用顺序不同产生了不同的效能，可以使用建造者模式。</p>
<p><strong>建造者模式与工厂模式的异同</strong>：</p>
<p>1、建造者模式最主要的功能是基本方法的调用顺序安排，这些基本方法已经实现了，顺序不同产生的对象也不同。</p>
<p>2、工厂方法重点是创建，创建零件是它的主要职责，组装顺序则不是它关心的。</p>
<h2 id="6-代理模式"><a class="markdownIt-Anchor" href="#6-代理模式"></a> 6、代理模式</h2>
<p>**定义：**为其他对象提供一种代理以控制对这个对象的访问。</p>
<p><strong>普通代理和强制代理</strong>：普通代理就是我们要知道代理的存在，通过代理进行访问；强制代理则是调用者直接调用真实角色，而不用关心代理是否存在，其代理的产生是由真实角色决定的。</p>
<ul>
<li>
<p>普通代理</p>
<p>在该模式下，调用者只知代理而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色想怎么修改就怎么修改，对高层次的模块没有任何的影响，只要你实现了接口所对应的方法，该模式非常适合对扩展性要求较高的场合。</p>
</li>
<li>
<p>强制代理</p>
<p>强制代理的概念就是要从真实角色查找到代理角色，不允许直接访问真实角色。高层模块只要调用 getProxy 就可以访问真实角色的所有方法，它根本就不需要产生一个代理出来，代理的管理已经由真实角色自己完成。</p>
</li>
</ul>
<h2 id="7-原型模式"><a class="markdownIt-Anchor" href="#7-原型模式"></a> 7、原型模式</h2>
<p><strong>定义</strong>：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<p>原型模式实现了Cloneable接口，重写clone方法。优点如下：</p>
<p>（1）性能优良。</p>
<p>原型模式是在内存二进制流的拷贝，要比直接 new 一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。</p>
<p>（2）逃避构造函数的约束。</p>
<p>这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。</p>
<p><strong>使用场景</strong>：</p>
<ol>
<li>
<p>资源优化场景</p>
<p>类初始化需要消耗很多的资源，包括数据、硬件等资源。</p>
</li>
<li>
<p>对性能和安全有要求的场景</p>
<p>通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</p>
</li>
<li>
<p>一个对象多个修改者的场景</p>
<p>一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</p>
</li>
</ol>
<h2 id="8-装饰者模式"><a class="markdownIt-Anchor" href="#8-装饰者模式"></a> 8、装饰者模式</h2>
<p><strong>定义</strong>：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更为灵活。</p>
<p><strong>使用场景：</strong></p>
<p>1、需要扩展一个类的功能，或给一个类增加附加功能。</p>
<p>2、需要动态地给一个对象增加功能，这些功能可以再动态地撤销。</p>
<h2 id="9-策略模式"><a class="markdownIt-Anchor" href="#9-策略模式"></a> 9、策略模式</h2>
<p><strong>定义</strong>：定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p>
<p><strong>使用场景：</strong></p>
<p>● 多个类只有在算法或行为上稍有不同的场景。</p>
<p>● 算法需要自由切换的场景。</p>
<p>● 需要屏蔽算法规则的场景。</p>
<p><strong>注意事项</strong>：具体策略数量超过 4 个，则需要考虑使用混合模式</p>
<h2 id="10-适配器模式"><a class="markdownIt-Anchor" href="#10-适配器模式"></a> 10、适配器模式</h2>
<p>**定义：**将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>
<p><strong>使用场景</strong>：</p>
<p>你有动机修改一个已经投产中的接口时，适配器模式可能是最适合你的模式。比如系统扩展了，需要使用一个已有或新建立的类，但这个类又不符合系统的接口，怎么办？使用适配器模式，这也是我们例子中提到的。</p>
<p><strong>对象适配器和类适配器的区别：</strong></p>
<p>类适配器是类间继承，对象适配器是对象的合成关系，也可以说是类的关联关系，</p>
<p>这是两者的根本区别。（实际项目中对象适配器使用到的场景相对比较多）。</p>
<h2 id="11-迭代器模式"><a class="markdownIt-Anchor" href="#11-迭代器模式"></a> 11、迭代器模式</h2>
<p><strong>定义</strong>：它提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。</p>
<h2 id="12-组合模式"><a class="markdownIt-Anchor" href="#12-组合模式"></a> 12、组合模式</h2>
<p>**定义：**将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p>
<p><strong>使用场景：</strong></p>
<p>● 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。</p>
<p>● 从一个整体中能够独立出部分模块或功能的场景。</p>
<p>**注意：**只要是树形结构，就考虑使用组合模式。</p>
<h2 id="13-观察者模式"><a class="markdownIt-Anchor" href="#13-观察者模式"></a> 13、观察者模式</h2>
<p>**定义：**定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并自动更新。</p>
<p><strong>使用场景：</strong></p>
<p>● 关联行为场景。需要注意的是，关联行为是可拆分的，而不是“组合”关系。</p>
<p>● 事件多级触发场景。</p>
<p>● 跨系统的消息交换场景，如消息队列的处理机制。</p>
<p><strong>注意：</strong></p>
<p>● 广播链的问题</p>
<p>在一个观察者模式中最多出现一个对象既是观察者也是被观察者，也就是说消息最多转发一次（传递两次）。</p>
<p>● 异步处理问题</p>
<p>观察者比较多，而且处理时间比较长，采用异步处理来考虑线程安全和队列的问题。</p>
<h2 id="14-门面模式"><a class="markdownIt-Anchor" href="#14-门面模式"></a> 14、门面模式</h2>
<p>**定义：**要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p>
<p><strong>使用场景：</strong></p>
<p>1、为一个复杂的模块或子系统提供一个供外界访问的接口。</p>
<p>2、子系统相对独立，外界对子系统的访问只要黑箱操作即可。</p>
<p>3、预防低水平人员带来的风险扩散</p>
<p><strong>注意：</strong></p>
<p>1、一个子系统可以有多个门面</p>
<p>2、门面不参与子系统内的业务逻辑</p>
<h2 id="15-备忘录模式"><a class="markdownIt-Anchor" href="#15-备忘录模式"></a> 15、备忘录模式</h2>
<p>**定义：**在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。</p>
<p><strong>使用场景：</strong></p>
<p>● 需要保存和恢复数据的相关状态场景。</p>
<p>● 提供一个可回滚（rollback）的操作。</p>
<p>● 需要监控的副本场景中。</p>
<p>● 数据库连接的事务管理就是用的备忘录模式。</p>
<p><strong>注意：</strong></p>
<p>●备忘录的生命期</p>
<p>●备忘录的性能</p>
<p>不要在频繁建立备份的场景中使用备忘录模式（比如一个 for 循环中）。</p>
<h2 id="16-享元模式"><a class="markdownIt-Anchor" href="#16-享元模式"></a> 16、享元模式</h2>
<p>**定义：**使用共享对象可有效地支持大量的细粒度的对象。</p>
<p>对象的信息分为两个部分：内部状态（intrinsic）与外部状态（extrinsic）。</p>
<p>● 内部状态</p>
<p>内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变。</p>
<p>● 外部状态</p>
<p>外部状态是对象得以依赖的一个标记，是随环境改变而改变的、不可以共享的状态。</p>
<p><strong>使用场景：</strong></p>
<p>● 系统中存在大量的相似对象。</p>
<p>● 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份。</p>
<p>● 需要缓冲池的场景。</p>
<p><strong>注意：</strong></p>
<p>● 享元模式是线程不安全的，只有依靠经验，在需要的地方考虑一下线程安全，在大部分场景下不用考虑。对象池中的享元对象尽量多，多到足够满足为止。</p>
<p>● 性能安全：外部状态最好以 java 的基本类型作为标志，如 String，int，可以提高效率。</p>
<h2 id="17-桥梁模式"><a class="markdownIt-Anchor" href="#17-桥梁模式"></a> 17、桥梁模式</h2>
<p>**定义：**将抽象和实现解耦，使得两者可以独立地变化。</p>
<p><strong>使用场景：</strong></p>
<p>● 不希望或不适用使用继承的场景</p>
<p>● 接口或抽象类不稳定的场景</p>
<p>● 重用性要求较高的场景</p>
<p><strong>注意：</strong></p>
<p>发现类的继承有 N 层时，可以考虑使用桥梁模式。桥梁模式主要考虑如何拆分抽</p>
<p>象和实现。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>让字符串成为回文串的最少插入次数</title>
    <url>/2021/07/24/%E8%AE%A9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%90%E4%B8%BA%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%91%E6%8F%92%E5%85%A5%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="让字符串成为回文串的最少插入次数"><a class="markdownIt-Anchor" href="#让字符串成为回文串的最少插入次数"></a> 让字符串成为回文串的最少插入次数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给你一个字符串 <code>s</code> ，每一次操作你都可以在字符串的任意位置插入任意字符。</p>
<p>请你返回让 <code>s</code> 成为回文串的 <strong>最少操作次数</strong> 。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;mbadm&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：字符串可变为 &quot;mbdadbm&quot; 或者 &quot;mdbabdm&quot; 。</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>回文问题一般都是从字符串的中间向两端扩散，构造回文串也是类似的。</p>
<p><strong>我们定义一个二维的<code>dp</code>数组，<code>dp[i][j]</code>的定义如下：对字符串<code>s[i..j]</code>，最少需要进行<code>dp[i][j]</code>次插入才能变成回文串</strong>。</p>
<p>我们想求整个<code>s</code>的最少插入次数，根据这个定义，也就是想求<code>dp[0][n-1]</code>的大小（<code>n</code>为<code>s</code>的长度）。</p>
<p>同时，base case 也很容易想到，当<code>i == j</code>时<code>dp[i][j] = 0</code>，因为当<code>i == j</code>时<code>s[i..j]</code>就是一个字符，本身就是回文串，所以不需要进行任何插入操作。</p>
<p><strong>状态转移方程</strong></p>
<p><strong>如果我们现在想计算<code>dp[i][j]</code>的值，而且假设我们已经计算出了子问题<code>dp[i+1][j-1]</code>的值了，你能不能想办法推出<code>dp[i][j]</code>的值呢</strong>？</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_jpg/gibkIz0MVqdHMicTxuCrqaIns8nCiakALibCR00FwMD0kpIgbcKUk61qabtyFNj5DlXEBLzEgvPr8kiaG5rs4flK6PQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" /></p>
<p>既然已经算出<code>dp[i+1][j-1]</code>，即知道了<code>s[i+1..j-1]</code>成为回文串的最小插入次数，<strong>那么也就可以认为<code>s[i+1..j-1]</code>已经是一个回文串了，所以通过<code>dp[i+1][j-1]</code>推导<code>dp[i][j]</code>的关键就在于<code>s[i]</code>和<code>s[j]</code>这两个字符</strong>。</p>
<p>这个得分情况讨论，<strong>如果<code>s[i] == s[j]</code>的话</strong>，我们不需要进行任何插入，只要知道如何把<code>s[i+1..j-1]</code>变成回文串即可：</p>
<p>……</p>
<p><a href="https://mp.weixin.qq.com/s/C14WNUpPeBMVSMqh28JdfA">阅读原文</a></p>
<img src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photosfddf.png" style="zoom:50%;" />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinInsert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minInsertion</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=str.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str.charAt(i)==str.charAt(j))&#123;</span><br><span class="line">                    dp[i][j]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j]=Math.min(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str=<span class="string">&quot;aabbaag&quot;</span>;</span><br><span class="line">        MinInsert minInsert=<span class="keyword">new</span> MinInsert();</span><br><span class="line">        System.out.println(minInsert.minInsertion(str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>被围绕的区域</title>
    <url>/2021/07/24/%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="被围绕的区域"><a class="markdownIt-Anchor" href="#被围绕的区域"></a> 被围绕的区域</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。</p>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
<p>示例:</p>
<p>X X X X<br />
X O O X<br />
X X O X<br />
X O X X</p>
<p>运行你的函数后，矩阵变为：</p>
<p>X X X X<br />
X X X X<br />
X X X X<br />
X O X X</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>由题，题目中说被包围的区间不会存在于边界上，所以我们会想到边界上的 O 要特殊处理，只要把边界上的 O 特殊处理了，那么剩下的 O替换成 X 就可以了。问题转化为，如何寻找和边界联通的 O，我们需要考虑如下情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O O X</span><br></pre></td></tr></table></figure>
<p>这时候的 O 是不做替换的。因为和边界是连通的。为了记录这种状态，我们把这种情况下的 O 换成 # 作为占位符，待搜索结束之后，遇到 O 替换为 X（和边界不连通的 O）；遇到 #，替换回 O(和边界连通的 O)。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sounded</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board==<span class="keyword">null</span>||board.length==<span class="number">0</span>)&#123;<span class="comment">//非常重要</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m=board.length;</span><br><span class="line">        <span class="keyword">int</span> n=board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">boolean</span> isEdge=(i==<span class="number">0</span>||i==m-<span class="number">1</span>||j==<span class="number">0</span>||j==n-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(isEdge&amp;&amp;board[i][j]==<span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    dfs(board,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j]=<span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j]=<span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="comment">//注意此处多个或运算符连接需空隔好。</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= board.length  || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="string">&#x27;X&#x27;</span> || board[i][j] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        dfs(board,i+<span class="number">1</span>,j);</span><br><span class="line">        dfs(board,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(board,i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(board,i,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>表示数值的字符串</title>
    <url>/2021/07/24/%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="表示数值的字符串"><a class="markdownIt-Anchor" href="#表示数值的字符串"></a> 表示数值的字符串</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;、“5e2”、&quot;-123&quot;、“3.1416”、“0123&quot;都表示数值，但&quot;12e”、“1a3.14”、“1.2.3”、“±5”、&quot;-1E-16&quot;及&quot;12e+5.4&quot;都不是。</p>
<h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路</h2>
<p>**常规思路：**根据条件判断可能出现的情况，最终返回结果。</p>
<p>**进阶解法：**自动状态机。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">isnumber</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isDigit=<span class="keyword">false</span>,isDot=<span class="keyword">false</span>,is_eE=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ch=s.trim().toCharArray();<span class="comment">//删去字符串前后空格转换为字符数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ch.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch[i]&lt;=<span class="string">&#x27;9&#x27;</span>) isDigit=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch[i]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isDot||is_eE) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//小数点前面不能重复出现小数点或存在e</span></span><br><span class="line">                isDot=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch[i]==<span class="string">&#x27;e&#x27;</span>||ch[i]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isDigit||is_eE) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//e前面必须是数字，且不能重复存在e</span></span><br><span class="line">                is_eE=<span class="keyword">true</span>;</span><br><span class="line">                isDigit=<span class="keyword">false</span>;<span class="comment">//e后面必须为数字</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch[i]==<span class="string">&#x27;+&#x27;</span>||ch[i]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;ch[i-<span class="number">1</span>]!=<span class="string">&#x27;e&#x27;</span>&amp;&amp;ch[i-<span class="number">1</span>]!=<span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isDigit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>荷兰三色旗问题</title>
    <url>/2021/07/24/%E8%8D%B7%E5%85%B0%E4%B8%89%E8%89%B2%E6%97%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="荷兰三色旗问题"><a class="markdownIt-Anchor" href="#荷兰三色旗问题"></a> 荷兰三色旗问题</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">设置三个指针，分别指向首尾和当前位，遍历数组，如果为2则交换到尾部，为0则交换到首部。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColor</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p0=<span class="number">0</span>,p2=nums.length-<span class="number">1</span>,cur=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(cur&lt;=p2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[cur]==<span class="number">0</span>)&#123;</span><br><span class="line">                temp=nums[p0];</span><br><span class="line">                nums[p0++]=nums[cur];</span><br><span class="line">                nums[cur++]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[cur]==<span class="number">2</span>)&#123;</span><br><span class="line">                temp=nums[p2];</span><br><span class="line">                nums[p2++]=nums[cur];</span><br><span class="line">                nums[cur++]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>航班预订统计</title>
    <url>/2021/07/24/%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="航班预订统计"><a class="markdownIt-Anchor" href="#航班预订统计"></a> 航班预订统计</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p>
<p>我们这儿有一份航班预订表，表中第 i 条预订记录 bookings[i] = [i, j, k] 意味着我们在从 i 到 j 的每个航班上预订了 k 个座位。</p>
<p>请你返回一个长度为 n 的数组 answer，按航班编号顺序返回每个航班上预订的座位数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>类似公交车上下车<br />
记录每个位置上车多少人、下车多少人，上车人数和下车人数的差就是当前车站人数变化，这些人到站后下一站则应减少这些人（注意：坐到终点的人，不需要被减少）<br />
把每站之前的上车人数累加则可以得出当前车上人数</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FightBooking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] corpfightBooking(<span class="keyword">int</span>[][] bookings,<span class="keyword">int</span> n)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counters = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] booking : bookings) &#123;</span><br><span class="line">            counters[booking[<span class="number">0</span>] - <span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (booking[<span class="number">1</span>] &lt; n) &#123;</span><br><span class="line">                counters[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            counters[i] += counters[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counters;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>股票买卖Ⅲ</title>
    <url>/2021/07/24/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E2%85%A2/</url>
    <content><![CDATA[<h1 id="股票买卖iii"><a class="markdownIt-Anchor" href="#股票买卖iii"></a> 股票买卖Ⅲ</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。</p>
<p>注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [3,3,5,0,0,3,1,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure>
<h2 id="思路实现"><a class="markdownIt-Anchor" href="#思路实现"></a> 思路实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能进行两次交易，求最大利润。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">buySockets3</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices==<span class="keyword">null</span> || prices.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len= prices.length;</span><br><span class="line">    <span class="keyword">int</span> min = prices[<span class="number">0</span>];            <span class="comment">// 初始化的前半部分最小买入价格</span></span><br><span class="line">    <span class="keyword">int</span> max = prices[len - <span class="number">1</span>];      <span class="comment">// 初始化的后半部分最大卖出价格</span></span><br><span class="line">    <span class="keyword">int</span> maxPro1 = <span class="number">0</span>;                <span class="comment">// 前半部分的每天最大利润</span></span><br><span class="line">    <span class="keyword">int</span> maxPro2 = <span class="number">0</span>;                <span class="comment">// 后半部分的每天最大利润</span></span><br><span class="line">    <span class="keyword">int</span>[] profit1 = <span class="keyword">new</span> <span class="keyword">int</span>[len];   <span class="comment">// 前半部分的利润表</span></span><br><span class="line">    <span class="keyword">int</span>[] profit2 = <span class="keyword">new</span> <span class="keyword">int</span>[len];   <span class="comment">// 后半部分的利润表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        <span class="comment">//前半部分的利润表</span></span><br><span class="line">        <span class="keyword">if</span>(prices[i]&lt;=min)&#123;</span><br><span class="line">            min=prices[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxPro1=Math.max(maxPro1,prices[i]-min);</span><br><span class="line">        &#125;</span><br><span class="line">        profit1[i]=maxPro1;</span><br><span class="line">        <span class="comment">//后半部分的利润表</span></span><br><span class="line">        <span class="keyword">if</span>(prices[prices.length-i-<span class="number">1</span>]&gt;=max)&#123;</span><br><span class="line">            max=prices[prices.length-i-<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxPro2=Math.max(maxPro2,max-prices[prices.length-i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        profit2[prices.length-i-<span class="number">1</span>]=maxPro2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">        res=Math.max(res,profit1[i]+profit2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> minPrice1 = Integer.MAX_VALUE;         </span><br><span class="line">      <span class="keyword">int</span> maxProfit1 = <span class="number">0</span>;                        </span><br><span class="line">      <span class="keyword">int</span> maxProfitAfterBuy = Integer.MIN_VALUE; </span><br><span class="line">      <span class="keyword">int</span> maxProfit2 = <span class="number">0</span>;                        </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">          <span class="comment">// 1.第一次最小购买价格</span></span><br><span class="line">          minPrice1  = Math.min(minPrice1,  price);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 2.第一次卖出的最大利润</span></span><br><span class="line">          maxProfit1 = Math.max(maxProfit1, price - minPrice1);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 3.第二次购买后的剩余净利润</span></span><br><span class="line">          maxProfitAfterBuy  = Math.max(maxProfitAfterBuy,  maxProfit1 - price );</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 4.第二次卖出后，总共获得的最大利润（第3步的净利润 + 第4步卖出的股票钱）</span></span><br><span class="line">          maxProfit2 = Math.max(maxProfit2, price + maxProfitAfterBuy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> maxProfit2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>组合总和Ⅰ</title>
    <url>/2021/07/24/%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h1 id="组合总和i"><a class="markdownIt-Anchor" href="#组合总和i"></a> 组合总和Ⅰ</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的数字可以无限制重复被选取。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路实现"><a class="markdownIt-Anchor" href="#思路实现"></a> 思路实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(combinations,res,candidates,target,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; combinations,List&lt;Integer&gt; res,<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(res));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&lt;=target)&#123;</span><br><span class="line">                res.add(candidates[i]);</span><br><span class="line">                backtrack(combinations,res,candidates,target-candidates[i],i);</span><br><span class="line">                res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="组合总和ii"><a class="markdownIt-Anchor" href="#组合总和ii"></a> 组合总和Ⅱ</h1>
<h2 id="问题陈述-2"><a class="markdownIt-Anchor" href="#问题陈述-2"></a> 问题陈述</h2>
<p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p><strong>candidates 中的每个数字在每个组合中只能使用一次。</strong></p>
<p>说明：</p>
<p>所有数字（包括目标数）都是正整数。<br />
解集不能包含重复的组合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路实现-2"><a class="markdownIt-Anchor" href="#思路实现-2"></a> 思路实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[candidates.length];</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        backtrack(combinations,res,candidates,target,<span class="number">0</span>,visited);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; combinations,List&lt;Integer&gt; res,<span class="keyword">int</span>[] candidates,<span class="keyword">int</span> target,<span class="keyword">int</span> start,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(res));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;candidates.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; candidates[i]==candidates[i-<span class="number">1</span>] &amp;&amp; !visited[i-<span class="number">1</span>] )&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span>(candidates[i]&lt;=target)&#123;</span><br><span class="line">                visited[i]=<span class="keyword">true</span>;</span><br><span class="line">                res.add(candidates[i]);</span><br><span class="line">                backtrack(combinations,res,candidates,target-candidates[i],i+<span class="number">1</span>,visited);</span><br><span class="line">                res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">                visited[i]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="组合总和iii"><a class="markdownIt-Anchor" href="#组合总和iii"></a> 组合总和Ⅲ</h1>
<h2 id="问题陈述-3"><a class="markdownIt-Anchor" href="#问题陈述-3"></a> 问题陈述</h2>
<p>找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。</p>
<p>说明：</p>
<p>所有数字都是正整数。<br />
解集不能包含重复的组合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: k = 3, n = 7</span><br><span class="line">输出: [[1,2,4]]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum3(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(combinations,res,k,n,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; combinations,List&lt;Integer&gt; res,<span class="keyword">int</span> k,<span class="keyword">int</span> n,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> &amp;&amp; n==<span class="number">0</span>)&#123;<span class="comment">//必须先判断此步</span></span><br><span class="line">            combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(res));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> || n==<span class="number">0</span>)&#123;<span class="comment">//第二判断</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line">        </span><br><span class="line">            res.add(i);</span><br><span class="line">            backtrack(combinations,res,k-<span class="number">1</span>,n-i,i+<span class="number">1</span>);</span><br><span class="line">            res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>组合</title>
    <url>/2021/07/24/%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="组合"><a class="markdownIt-Anchor" href="#组合"></a> 组合</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路实现"><a class="markdownIt-Anchor" href="#思路实现"></a> 思路实现</h2>
<p>同样可以用一个决策树进行回溯求解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backtrack(combinations,res,n,k,<span class="number">1</span>);<span class="comment">//n的遍历范围为1~n</span></span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; combinations,List&lt;Integer&gt; res,<span class="keyword">int</span> n,<span class="keyword">int</span> k,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            combinations.add(<span class="keyword">new</span> ArrayList&lt;&gt;(res));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=n-k+<span class="number">1</span>;i++)&#123;<span class="comment">//对于n个数，选择了一位，剩下n-1位。</span></span><br><span class="line">            res.add(i);</span><br><span class="line">            backtrack(combinations,res,n,k-<span class="number">1</span>,i+<span class="number">1</span>);<span class="comment">//k--，i++</span></span><br><span class="line">            res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2021/07/24/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="移动零"><a class="markdownIt-Anchor" href="#移动零"></a> 移动零</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeros</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;<span class="comment">//将所有非零元素移到队首</span></span><br><span class="line">            <span class="keyword">if</span>(num!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[index++]=num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index&lt;nums.length)&#123;<span class="comment">//剩下的就是0啦</span></span><br><span class="line">            nums[index++]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>种花问题</title>
    <url>/2021/07/24/%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="种花问题"><a class="markdownIt-Anchor" href="#种花问题"></a> 种花问题</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">输入: flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>根据题意，需有三个连续的空位才能栽一树花，另外考虑边界情况。贪心的思想。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowered,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;flowered.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flowered[i]==<span class="number">0</span> &amp;&amp; (i==<span class="number">0</span> || flowered[i-<span class="number">1</span>]==<span class="number">0</span>) &amp;&amp; (i==flowered.length-<span class="number">1</span>||flowered[i+<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            flowered[i]=<span class="number">1</span>;<span class="comment">//种下一朵花，继续判断剩下可以种花的地方</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count&gt;=n? <span class="keyword">true</span>:<span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进版：当count==n时即跳出循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowered,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;flowered.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flowered[i]==<span class="number">0</span>&amp;&amp;(i==<span class="number">0</span>||flowered[i-<span class="number">1</span>]==<span class="number">0</span>)&amp;&amp;(i==flowered.length-<span class="number">1</span>||flowered[i+<span class="number">1</span>]==<span class="number">0</span>))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            flowered[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>硬币</title>
    <url>/2021/07/24/%E7%A1%AC%E5%B8%81/</url>
    <content><![CDATA[<h1 id="硬币"><a class="markdownIt-Anchor" href="#硬币"></a> 硬币</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 输入: n = 5</span><br><span class="line"> 输出：2</span><br><span class="line"> 解释: 有两种方式可以凑成总金额:</span><br><span class="line">5=5</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">waysToChange</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span>[] coins=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">25</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//组成面值为0的硬币情况，即不使用任何硬币，也视为一种情况。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> coin:coins)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=coin;i&lt;=n;i++)&#123;</span><br><span class="line">                dp[i]=(dp[i]+dp[i-coin])%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>看见海</title>
    <url>/2021/07/24/%E7%9C%8B%E8%A7%81%E6%B5%B7/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1806926324&auto=1&height=66"></iframe>
<p>彼时只是一个生于内陆的孩童，第一次知道海也许是二年级人教版语文课本里的一首诗，每次讲诗，并不解其意，只是读起来朗朗上口，于是老师让我们读起来，是王之涣的《登鹳雀楼》：</p>
<blockquote>
<p>​    白日依山尽，黄河入海流，欲穷千里目，更上一层楼。</p>
</blockquote>
<p>印象中是第一次听闻海，知道了海大概是一片茫无际涯的大水。后来四年级的时候，学了巴金的《海上日出》，而且课文底页是附图的，对海就十分有了好感，再后来，初一下学期学到林海音的《爸爸的花儿落了》，是夹竹桃，后面看见夹竹桃总要想起来书中的主人公英子，那个因为下雨天赖床不起然后被爸爸拿起鸡毛掸子打起被宋妈抱上洋车的英子，校园里早读书声琅琅，窗外玉簪花在雨中莹润饱满。后面夹竹桃落了，爸爸的病愈加严重，那个齐肩发的女孩英子在台阶上泣不成声的落泪，而此刻弟弟妹妹还在打闹玩耍，她长大了，在校园礼堂为她们六年级毕业生唱完“长亭外，古道边，芳草碧连天”后，然后是一个小小的大人了，也曾在六年级国文课学到一篇文章《我们看海去》：</p>
<blockquote>
<p>​            我们看海去！</p>
<p>​            我们看海去！</p>
<p>​            蓝色的大海上，</p>
<p>​            扬着白色的帆。</p>
<p>​            金红的太阳，</p>
<p>​            从海上升起来，</p>
<p>​            照到海面照到船头。</p>
<p>​            我们看海去！</p>
<p>​            我们看海去！</p>
</blockquote>
<p>而萌生出强烈的想去看海的心愿。</p>
<p>后面，看的书越来越多，知道曹孟德观沧海后发出了“日月之行，若出其中。星汉灿烂，若出其里”的感叹。也知《庄子》里的河伯，在秋天百川灌河的时候以为天下之美尽在己，直至一路东出，得见大海，才兴叹见笑于大方之家……</p>
<p>不知不觉间我的生命走过二十载，有那么一日忽然就来到了巍巍中华大地的黄渤海边，在一个叫大连的城市的星海广场，第一次看见了茫茫大海，碧波汹涌，水天相接。是一个阳光温暖的晴天，广场上聚满了人，一大群海鸥在投食的人群上空展翅翱翔。</p>
<p>那一刻，看见了地上自己短小的影子，看见了一片汪洋，看见了让人忘机的鸥鸟，与人群和谐的共处，那一刻的惊心，只呆呆的看着它们从身边掠过或停下，欢喜到不知身在何方。我心亦如这鸥鸟，如这碧波，荡荡悠悠不知斯生方长。</p>
<p>研究生的两年，在大工，在大连，一座海滨城市，看见海的时日便多起来。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299892.jpg" alt="" /><br />
在中秋节后的一个周末，和一个巧合遇见同爱摄影的朋友去了海之韵和棒棰岛，沿着山海步道从容前行，路边盛开着紫薇花。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299903.jpg" alt="" /></p>
<center>想起来杜甫的一句诗：飘飘何所似，天地一沙鸥</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299922.jpg" alt="" /></p>
<p>在棒棰岛景区里徘徊许久，我们在路边坐着长谈，去看了古莲子长出的荷花，以及偶然一抬头望见梧桐树上的木板屋，不知是哪只鸟儿的家。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299921.jpg" alt="" /></p>
<center>在路边板凳休息的时候，隔篱看见与花浑然一色的蝴蝶。</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299942.jpg" alt="" /></p>
<center>坐着海边看波浪不断的涌上来，有一个小孩子在那连连舀水。</center>
<p>大连的西北面则是渤海，原是比较偏僻的，只因去医院看病的缘故，离得比较近，就一个人步行到了渤海边，后面听人说去过夏家河子那冬天温度低的时候海面会结冰。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299946.jpg" alt="" /></p>
<p>那边有一片礁石地，礁石地里有一个老妇人在捡着什么，我也在找寻着宝物，贝壳、好看的石头又或者幸运的看见海底冲上来的珍珠。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299947.jpg" alt="" /></p>
<p>正是夕阳落山的时候，紫红色的天空倒映在海滩，海滩上静静的却有一人，水面也映着她的影子。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299950.jpg" alt="" /></p>
<p>旁边是一座妈祖阁，那个福建莆田传说为庇佑出海打渔的人们而不幸淹入大海的林默娘，后来成为了沿海人们信奉的妈祖。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299954.jpg" alt="" /></p>
<center>甚是喜欢这一从芦花，古人说“白马入芦花”，又有“芦花深处泊孤舟”。</center>
<p>金石滩边，赶上学期末，课程考试皆已结束，在寒假归家前来到金石滩边，微博上认识一位摄影博主便是这金石滩边鲁迅美术学院的，给我看过她拍的大雪时的海边。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299957.jpg" alt="" /></p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299960.jpg" alt="" /></p>
<center>沙石间清流汩汩，忽然从泥沙里蹦出来一只小螃蟹。</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299962.jpg" alt="" /></p>
<p>那时，看见了最蔚蓝的海，海面泊着无人的孤舟，有那么一刻，想着乘上一叶扁舟，然后江海寄余生。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299964.jpg" alt="" /></p>
<p>那个午后，寂寂无人的海边，一个人呆坐了很久，和一个朋友说起这海。</p>
<p>去看海上落日，我是一个对落日十分痴迷的人，喜欢晚照、喜欢一切苍凉古旧的事物，我不能抑制心底那种与生俱来的悲凉与宿命之感。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299971.jpg" alt="" /></p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78299978.jpg" alt="" /></p>
<p>藏人对神山圣水的敬重与朝谒是我十分崇敬的，于是，在海边捡石砾砌了一个玛尼堆。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300001.jpg" alt="" /></p>
<center>那是木桩吗？不，是一个人。</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300002.jpg" alt="" /></p>
<p>不知怎的，蓦然垂下泪来，许是那日入夜海风太凉，这样的画面在看过的一部电影里也有这一幕，只是剧中人看的是繁星满天。</p>
<p>真正去看一场落日，是一个深秋的时节，我亦生于深秋。靠着栏杆，看着夕阳一点点的落下去，直至月色皎洁。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300003.jpg" alt="" /></p>
<center>最爱这一缕夕阳照在建筑物是赭红色的光影</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300007.jpg" alt="" /></p>
<center>夕阳开始落山</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300029.jpg" alt="" /></p>
<center>渐沉</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300038.jpg" alt="" /></p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300051.jpg" alt="" /></p>
<center>没入</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300052.jpg" alt="" /></p>
<center>余霞</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300063.jpg" alt="" /></p>
<center>新月皎洁</center>
<p>总不肯辜负这秋天，特别是在这北国，秋天一过，草木皆枯零，再难看到一点绿色。于是一个人去了山里，出山的时候又望见了海。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300064.jpg" alt="" /></p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300066.jpg" alt="" /></p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300070.jpg" alt="" /></p>
<center>依山眺海</center>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/p78300071.jpg" alt="" /></p>
<center>被海浪冲上来的海星</center>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
  </entry>
  <entry>
    <title>目标和</title>
    <url>/2021/07/24/%E7%9B%AE%E6%A0%87%E5%92%8C/</url>
    <content><![CDATA[<h1 id="目标和"><a class="markdownIt-Anchor" href="#目标和"></a> 目标和</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个非负整数数组，a1, a2, …, an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p>
<p>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums: [1, 1, 1, 1, 1], S: 3</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">-1+1+1+1+1 = 3</span><br><span class="line">+1-1+1+1+1 = 3</span><br><span class="line">+1+1-1+1+1 = 3</span><br><span class="line">+1+1+1-1+1 = 3</span><br><span class="line">+1+1+1+1-1 = 3</span><br><span class="line"></span><br><span class="line">一共有5种方法让最终目标和为3。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="方法一枚举"><a class="markdownIt-Anchor" href="#方法一枚举"></a> 方法一：枚举</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        calculate(nums,<span class="number">0</span>,<span class="number">0</span>,s);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> num,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i==nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num==s)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             calculate(nums,i+<span class="number">1</span>,num+nums[i],s);</span><br><span class="line">             calculate(nums,i+<span class="number">1</span>,num-nums[i],s);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二回溯"><a class="markdownIt-Anchor" href="#方法二回溯"></a> 方法二：回溯</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    backtrack(nums, <span class="number">0</span>, target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 回溯算法模板 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明恰好凑出 target</span></span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 给 nums[i] 选择 - 号</span></span><br><span class="line">    rest += nums[i];</span><br><span class="line">    <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    rest -= nums[i]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 nums[i] 选择 + 号</span></span><br><span class="line">    rest -= nums[i];</span><br><span class="line">    <span class="comment">// 穷举 nums[i + 1]</span></span><br><span class="line">    backtrack(nums, i + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="comment">// 撤销选择</span></span><br><span class="line">    rest += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>江南好</title>
    <url>/2021/07/24/%E6%B1%9F%E5%8D%97%E5%A5%BD/</url>
    <content><![CDATA[<h1 id="江南好"><a class="markdownIt-Anchor" href="#江南好"></a> 江南好</h1>
<h2 id="白乐天忆江南词"><a class="markdownIt-Anchor" href="#白乐天忆江南词"></a> 白乐天忆江南词</h2>
<p><strong>忆江南三首</strong></p>
<p>其一</p>
<p>江南好，风景旧曾谙；日出江花红胜火，春来江水绿如蓝。能不忆江南？</p>
<p>其二</p>
<p>江南忆，最忆是杭州；山寺月中寻桂子，郡亭枕上看潮头。何日更重游？</p>
<p>其三</p>
<p>江南忆，其次忆吴宫；吴酒一杯春竹叶，吴娃双舞醉芙蓉。早晚复相逢？</p>
<h2 id="青简填忆江南词咏杭州七首"><a class="markdownIt-Anchor" href="#青简填忆江南词咏杭州七首"></a> 青简填忆江南词咏杭州七首</h2>
<p>杭州好，风景四时多。<br />
春日寻芳秋赏月，冬来飞雪夏观荷，<br />
湖上有清歌。</p>
<p>杭州好，雨后碧山深。<br />
千树烟云千笔画，九弯溪水九张琴，<br />
宜作梦中吟。</p>
<p>杭州好，灵隐渡无涯<br />
白乐桥边才买醉，法云村里又求茶，<br />
槛外是吾家。</p>
<p>杭州好，仙境彩云栖。<br />
山径好行留梦去，竹枝堪折带愁吹，<br />
惊起鸟相啼。</p>
<p>杭州好，春日梦三台。<br />
也织芳菲为锦绣，更铺云水作衣裁，<br />
妆罢待谁来。</p>
<p>杭州好，龙井问新茶。<br />
一盏为谁沏雨露，七杯同我饮烟霞，<br />
归去泛仙槎。</p>
<p>杭州好，最忆是西溪。<br />
秋染柿林红胜火，春来梅墅雪如瓷。<br />
无日不逢时。</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
      <tags>
        <tag>江南</tag>
      </tags>
  </entry>
  <entry>
    <title>汉明距离</title>
    <url>/2021/07/24/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="汉明距离"><a class="markdownIt-Anchor" href="#汉明距离"></a> 汉明距离</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br></pre></td></tr></table></figure>
<h2 id="内置函数法"><a class="markdownIt-Anchor" href="#内置函数法"></a> 内置函数法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.bitCount(x ^ y); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="异或逐位判断法"><a class="markdownIt-Anchor" href="#异或逐位判断法"></a> 异或逐位判断法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hanmingDistance</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ps=x^y;</span><br><span class="line">        <span class="keyword">int</span> distance=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ps!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ps%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                distance++;</span><br><span class="line">                 ps=ps&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>每日温度</title>
    <url>/2021/07/24/%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="每日温度"><a class="markdownIt-Anchor" href="#每日温度"></a> 每日温度</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<h2 id="问题求解"><a class="markdownIt-Anchor" href="#问题求解"></a> 问题求解</h2>
<h3 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;T.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;T.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(T[j]&gt;T[i])&#123;</span><br><span class="line">                    res[i]=j-i;</span><br><span class="line">                    <span class="keyword">break</span>;<span class="comment">//此处break后就是第一个升温天气</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈"><a class="markdownIt-Anchor" href="#单调栈"></a> 单调栈</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] ret = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = stack.pop();</span><br><span class="line">            ret[idx] = i - idx;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>正向代理和反向代理</title>
    <url>/2021/07/24/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h1 id="正向代理和反向代理"><a class="markdownIt-Anchor" href="#正向代理和反向代理"></a> 正向代理和反向代理</h1>
<h3 id="正向代理"><a class="markdownIt-Anchor" href="#正向代理"></a> <strong>正向代理</strong></h3>
<p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p>
<p>这种代理其实在生活中是比较常见的，比如访问外国网站技术，其用到的就是代理技术。有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/9bb0wwt9dj.jpeg" alt="" /></p>
<p>这个过程其实和租房子很像。租房子的时候，一般情况下，我们很难联系到房东，因为有些房东为了图方便，只把自己的房屋信息和钥匙交给中介了。而房客想要租房子，只能通过中介才能联系到房东。而对于房东来说，他可能根本不知道真正要租他的房子的人是谁，他只知道是中介在联系他。</p>
<p><strong>所以，正向代理，其实是&quot;代理服务器&quot;代理了&quot;客户端&quot;，去和&quot;目标服务器&quot;进行交互。</strong></p>
<h3 id="正向代理的用途"><a class="markdownIt-Anchor" href="#正向代理的用途"></a> <strong>正向代理的用途</strong></h3>
<p><strong>突破访问限制</strong></p>
<p>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</p>
<p>即，租客可以通过中介，来解决无法联系上房东的问题。</p>
<p><strong>提高访问速度</strong></p>
<p>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</p>
<p>即，中介手里留存了很多房源信息和钥匙，可以直接带租客去看房。</p>
<p><strong>隐藏客户端真实IP</strong></p>
<p>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p>
<p>即，房东并不知道租客的真实身份。PS：但是中介知道了，可能骚扰更多….</p>
<h3 id="反向代理"><a class="markdownIt-Anchor" href="#反向代理"></a> <strong>反向代理</strong></h3>
<p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>我们在租房子的过程中，除了有些房源需要通过中介以外，还有一些是可以直接通过房东来租的。用户直接找到房东租房的这种情况就是我们不使用代理直接访问国内的网站的情况。还有一种情况，就是我们以为我们接触的是房东，其实有时候也有可能并非房主本人，有可能是他的亲戚、朋友，甚至是二房东。但是我们并不知道和我们沟通的并不是真正的房东。这种帮助真正的房主租房的二房东其实就是反向代理服务器。这个过程就是反向代理。</p>
<p>对于常用的场景，就是我们在Web开发中用到的<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>服务器（二房东），客户端（租客）发送请求到负载均衡服务器（二房东）上，负载均衡服务器（二房东）再把请求转发给一台真正的服务器（房东）来执行，再把执行结果返回给客户端（租客）。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/g4y6wi918j.jpeg" alt="" /></p>
<p><strong>所以，反向代理，其实是&quot;代理服务器&quot;代理了&quot;目标服务器&quot;，去和&quot;客户端&quot;进行交互。</strong></p>
<p>通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。</p>
<h3 id="反向代理的用途"><a class="markdownIt-Anchor" href="#反向代理的用途"></a> <strong>反向代理的用途</strong></h3>
<p><strong>隐藏服务器真实IP</strong></p>
<p>使用反向代理，可以对客户端隐藏服务器的IP地址。</p>
<p>即，租客并不房东知道的真实身份。</p>
<p><strong>负载均衡</strong></p>
<p>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</p>
<p>即，二房东发现房主本人很忙，于是找到房主的妻子帮忙处理租房事宜。</p>
<p><strong>提高访问速度</strong></p>
<p>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</p>
<p>即，二房东同样有房屋信息和钥匙。</p>
<p><strong>提供安全保障</strong></p>
<p>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。</p>
<p>即，二房东可以有效的保护房东的安全。</p>
<h3 id="正向代理和反向代理的区别"><a class="markdownIt-Anchor" href="#正向代理和反向代理的区别"></a> <strong>正向代理和反向代理的区别</strong></h3>
<p>虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。</p>
<p>1、<strong>正向代理其实是客户端的代理</strong>，帮助客户端访问其无法访问的服务器资源。<strong>反向代理则是服务器的代理</strong>，帮助服务器做负载均衡，安全防护等。</p>
<p>2、<strong>正向代理一般是客户端架设的</strong>，比如在自己的机器上安装一个代理软件。而<strong>反向代理一般是服务器架设的</strong>，比如在自己的机器集群中部署一个反向代理服务器。</p>
<p>3、<strong>正向代理中，服务器不知道真正的客户端到底是谁</strong>，以为访问自己的就是真实的客户端。而在<strong>反向代理中，客户端不知道真正的服务器是谁</strong>，以为自己访问的就是真实的服务器。</p>
<p>4、正向代理和反向代理的作用和目的不同。<strong>正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</strong></p>
]]></content>
      <categories>
        <category>offer之路</category>
      </categories>
  </entry>
  <entry>
    <title>机器人的运动范围</title>
    <url>/2021/07/24/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="机器人的运动范围"><a class="markdownIt-Anchor" href="#机器人的运动范围"></a> 机器人的运动范围</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？</p>
<h2 id="dfs深度优先遍历"><a class="markdownIt-Anchor" href="#dfs深度优先遍历"></a> DFS深度优先遍历</h2>
<p><strong>深度优先搜索</strong>： 可以理解为暴力法模拟机器人在矩阵中的所有路径。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。<br />
剪枝： 在搜索中，遇到数位和超出目标值、此元素已访问，则应立即返回，称之为 可行性剪枝 。</p>
<p><strong>算法解析：</strong></p>
<p><strong>递归参数</strong>： 当前元素在矩阵中的行列索引 i 和 j ，两者的数位和 si, sj 。<br />
<strong>终止条件</strong>： 当 ① 行列索引越界 或 ② 数位和超出目标值 k 或 ③ 当前元素已访问过 时，返回 0 ，代表不计入可达解。</p>
<p><strong>递推工作</strong>：<br />
<strong>标记当前单元格</strong> ：将索引 (i, j) 存入 Set visited 中，代表此单元格已被访问过。<br />
<strong>搜索下一单元格</strong>： 计算当前元素的 下、右 两个方向元素的数位和，并开启下层递归 。<br />
<strong>回溯返回值</strong>： 返回 1 + 右方搜索的可达解总数 + 下方搜索的可达解总数，代表从本单元格递归搜索的可达解总数（起始点左上角【0，0】位置）。</p>
<p><strong>附：数位增量计算</strong>：</p>
<p>由于机器人每次只能移动一格（即只能从 x运动至 x±1），因此每次只需计算 x到x±1 的数位和增量。本题说明1≤n,m≤100 ，以下公式仅在此范围适用。</p>
<p>设x的数位为s_x, x+1的数位为s_(x+1)。</p>
<p>当(x+1)%10==0时，s_(x+1)=s_x-8,例如 19, 20 的数位和分别为 10, 2；</p>
<p>当(x+1)%10!=0时，s_(x+1)=s_x+1,例如 1, 2的数位和分别为 1, 2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m,n,k;</span><br><span class="line">    <span class="keyword">boolean</span>[][] visited;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.m=m;</span><br><span class="line">        <span class="keyword">this</span>.n=n;</span><br><span class="line">        <span class="keyword">this</span>.k=k;</span><br><span class="line">        <span class="keyword">this</span>.visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> si,<span class="keyword">int</span> sj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=m||j&gt;=n||si+sj&gt;k||visisted[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(i+<span class="number">1</span>,j,(i+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>? si-<span class="number">8</span>:si+<span class="number">1</span>,sj)+dfs(i,j+<span class="number">1</span>,si,(j+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>? sj-<span class="number">8</span>:sj+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs广度优先遍历"><a class="markdownIt-Anchor" href="#bfs广度优先遍历"></a> BFS广度优先遍历</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();<span class="comment">//学习以下两行代码写法</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(queue.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] index=queue.poll();</span><br><span class="line">            <span class="keyword">int</span> i=index[<span class="number">0</span>],j=index[<span class="number">1</span>],si=index[<span class="number">2</span>],sj=index[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=m||j&gt;=n||si+sj&gt;k||visited[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i][j]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i+<span class="number">1</span>,j,(i+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>? si-<span class="number">8</span>:si+<span class="number">1</span>,sj&#125;);</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i,j+<span class="number">1</span>,si,(j+<span class="number">1</span>)%<span class="number">10</span>==<span class="number">0</span>? sj-<span class="number">8</span>:sj+<span class="number">1</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>朋友圈</title>
    <url>/2021/07/24/%E6%9C%8B%E5%8F%8B%E5%9C%88/</url>
    <content><![CDATA[<h1 id="朋友圈"><a class="markdownIt-Anchor" href="#朋友圈"></a> 朋友圈</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p>
<p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[1,1,0],</span><br><span class="line"> [1,1,0],</span><br><span class="line"> [0,0,1]]</span><br><span class="line">输出：2 </span><br><span class="line">解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。</span><br><span class="line">第2个学生自己在一个朋友圈。所以返回 2 。</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>上述矩阵可视为图的邻接数组表示。</p>
<img src="https://pic.leetcode-cn.com/Figures/647_Friend_Circles_1.jpg" style="zoom: 25%;" />
<p>问题即变成寻找无向图的连通分支数。</p>
<p>DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">connectFiends</span><span class="params">(<span class="keyword">int</span>[][] M)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] visited= <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                dfs(M,visited,i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M,<span class="keyword">int</span>[] visited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(M[i][j]==<span class="number">1</span>&amp;&amp;visited[j]==<span class="number">0</span>)&#123;</span><br><span class="line">                visited[j]=<span class="number">1</span>;</span><br><span class="line">                dfs(M,visited,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最长子序列</title>
    <url>/2021/07/24/%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="最长子序列"><a class="markdownIt-Anchor" href="#最长子序列"></a> 最长子序列</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>删除 s 中的一些字符，使得它构成字符串列表 d 中的一个字符串，找出能构成的最长字符串。如果有多个相同长度的结果，返回字典序的最小字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = &quot;abpcplea&quot;, d = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">&quot;apple&quot;</span><br></pre></td></tr></table></figure>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<p>采用双指针:遍历给定字符串,因为找的是子集,与字典中的字符串一个个比.如果相等,它俩下标都加一,再判断<br />
字典中的字符串是否和下标相等了,如果相等,证明找到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s,List&lt;String&gt; d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] sc=s.toCharArray();</span><br><span class="line">        String result=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String ds:d)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result.length() &gt; ds.length() || (result.length() == ds.length() &amp;&amp; result.compareTo(ds) &lt; <span class="number">0</span>))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(isSubStr(sc,ds))&#123;</span><br><span class="line">                result = ds;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubStr</span><span class="params">(<span class="keyword">char</span>[] sc,String ds)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 字典字符串下标</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] dsc = ds.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> s : sc)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s == dsc[i])&#123;</span><br><span class="line">                i ++;</span><br><span class="line">                <span class="comment">// 如果下标和长度相等,就证明找到了</span></span><br><span class="line">                <span class="keyword">if</span>(i == dsc.length)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这还找不到,就证明失败了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最短无序连续子数组</title>
    <url>/2021/07/24/%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="最短无序连续子数组"><a class="markdownIt-Anchor" href="#最短无序连续子数组"></a> 最短无序连续子数组</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个整数数组，你需要寻找一个<strong>连续的子数组</strong>，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>你找到的子数组应是<strong>最短</strong>的，请输出它的长度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。</span><br></pre></td></tr></table></figure>
<h2 id="思路一"><a class="markdownIt-Anchor" href="#思路一"></a> 思路一</h2>
<p>设置左右边界，L初始化为nums.length, R初始化为0。对数组两两比较，如果前面数大于后面数，则L=min(L, i); R=max(R,j)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">int</span> L=nums.length,R=<span class="number">0</span>;</span><br><span class="line">​    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">​      <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">​        <span class="keyword">if</span>(nums[i]&gt;nums[j])&#123;</span><br><span class="line">​          L=Math.min(L,i);</span><br><span class="line">​          R=Math.max(R,j);</span><br><span class="line">​        &#125;</span><br><span class="line">​      &#125;</span><br><span class="line">​    &#125;</span><br><span class="line">​    <span class="keyword">return</span> L&gt;R? <span class="number">0</span>:R-L+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路二"><a class="markdownIt-Anchor" href="#思路二"></a> 思路二</h2>
<p>对数组进行排序，将排序后的数组与原数组比对，发现最左最右边界。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] snums=nums.clone();</span><br><span class="line">        Arrays.sort(snums);</span><br><span class="line">        <span class="keyword">int</span> R=<span class="number">0</span>,L=nums.length;<span class="comment">//注意此处L初始值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;nums.length;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[k]!=snums[k])&#123;</span><br><span class="line">                L=Math.min(L,k);</span><br><span class="line">                R=Math.max(R,k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> L&gt;R? <span class="number">0</span>:R-L+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最小路径和</title>
    <url>/2021/07/24/%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="最小路径和"><a class="markdownIt-Anchor" href="#最小路径和"></a> 最小路径和</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure>
<h2 id="思路实现"><a class="markdownIt-Anchor" href="#思路实现"></a> 思路实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.echo.exam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinPathSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> m=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[][] grid=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                grid[i][j]=in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=minpathsum(grid);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minpathsum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m= grid.length;</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(grid==<span class="keyword">null</span> || m==<span class="number">0</span> || n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>无重叠区间</title>
    <url>/2021/07/24/%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="无重叠区间"><a class="markdownIt-Anchor" href="#无重叠区间"></a> 无重叠区间</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个区间的集合，找到<strong>需要移除区间的最小数量</strong>，使剩余区间互不重叠。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>算法思路：</p>
<ol>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集</li>
</ol>
<img src="https://pic.leetcode-cn.com/678752f150168fc2e53a36d30e589b76ef81a95943c018b01bef6a548bfafeeb-file_1566313617208" style="zoom:50%;" />
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intevalSchedual</span><span class="params">(<span class="keyword">int</span>[][] intvs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(intvs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对intvs按区间end升序排列</span></span><br><span class="line">    Arrays.sort(intvs,<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">1</span>]-b[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//至少会有一个区间不相交</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x_end=intvs[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>[] inteval:intvs)&#123;</span><br><span class="line">        <span class="keyword">int</span> start=inteval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(start&gt;=x_end)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            x_end=inteval[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intvs.length-count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的逆序对</title>
    <url>/2021/07/24/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="数组中的逆序对"><a class="markdownIt-Anchor" href="#数组中的逆序对"></a> 数组中的逆序对</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p>
<h2 id="思路详解"><a class="markdownIt-Anchor" href="#思路详解"></a> 思路详解</h2>
<p>1、很显然，此题可以双循环列举比较，复杂度为O(n^2)，有没有更好的解法呢？有的，利用归并排序的思想。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先你要知道归并排序的流程：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 先将数组分成两部分，然后分别将这两部分排好序；</span></span><br><span class="line"><span class="comment"> * 然后开一个 helper 数组，指针 a 和 b 分别指向这两个部分的第一个元素；</span></span><br><span class="line"><span class="comment"> * 比较指针 a 所指元素与指针 b 所指元素的大小，将小的元素放进 helper 数组中；</span></span><br><span class="line"><span class="comment"> * 如果某个指针遍历到对应部分的末尾的话，则需要将另一个指针所指元素以及它后面的元素直接添加到 helper 数组中；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最后再将 helper 数组中的数据拷贝到原数组中即可。</span></span><br><span class="line"><span class="comment"> * 重点在于在两个指针比较的过程中，如果第一个子数组中的数字大于第二个子数组中的数字，则可以构成逆序对，并且逆序对的数目就是第二个子数组中剩余数字的个数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountReversePairs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        mergeSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并排序整体逻辑</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start==end) <span class="keyword">return</span>; <span class="comment">//如果两个指针相遇，则说明已经排好序</span></span><br><span class="line">        <span class="keyword">int</span> mid=start+((end-start)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        mergeSort(nums,start,mid);  <span class="comment">// 对数组的左半部分进行归并</span></span><br><span class="line">        mergeSort(nums,mid+<span class="number">1</span>,end);  <span class="comment">// 对数组的右半部分进行归并</span></span><br><span class="line">        merge(nums,start,mid,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> mid,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] helper=<span class="keyword">new</span> <span class="keyword">int</span>[end-start+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>,pos1=start,pos2=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (pos1&lt;=mid&amp;&amp;pos2&lt;=end)&#123;</span><br><span class="line">            <span class="comment">//运算符 &lt;= 是为了去除元素相等的情况</span></span><br><span class="line">            <span class="comment">// 例如在 [1, 3, 2, 3, 1] 中，排除 [1, 1] 和 [3, 3] 的情况</span></span><br><span class="line">            <span class="keyword">if</span>(nums[pos1]&lt;=nums[pos2])&#123;</span><br><span class="line">                helper[k++]=nums[pos1++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 本题核心：由于 nums[pos1] &gt; nums[pos2]，</span></span><br><span class="line">                <span class="comment">// 则从 nums[pos1] 到 nums[middle] 必定都是大于 nums[pos2] 的，</span></span><br><span class="line">                <span class="comment">// 因为两部分的子数组已经是各自有序的</span></span><br><span class="line">                helper[k++]=nums[pos2++];</span><br><span class="line">                count+=(mid-pos1+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下面这两个 while 是当其中一个子数组中的指针如果已经遍历完了，</span></span><br><span class="line">        <span class="comment">// 那么另一个子数组肯定会有剩余元素，所以将剩余部分直接放到 help 中</span></span><br><span class="line">        <span class="keyword">while</span> (pos1&lt;mid)&#123;</span><br><span class="line">            helper[k++]=nums[pos1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pos2&lt;end)&#123;</span><br><span class="line">            helper[k++]=nums[pos2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 helper 中的元素拷贝到原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; helper.length; j++) &#123;</span><br><span class="line">            nums[start + j] = helper[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库面试知识一</title>
    <url>/2021/07/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E4%B8%80/</url>
    <content><![CDATA[<h1 id="数据库面试知识一"><a class="markdownIt-Anchor" href="#数据库面试知识一"></a> 数据库面试知识一</h1>
<h2 id="数据库基础知识"><a class="markdownIt-Anchor" href="#数据库基础知识"></a> 数据库基础知识</h2>
<h3 id="为什么要使用数据库"><a class="markdownIt-Anchor" href="#为什么要使用数据库"></a> 为什么要使用数据库</h3>
<p><strong>数据保存在内存</strong></p>
<p>优点： 存取速度快</p>
<p>缺点： 数据不能永久保存</p>
<p><strong>数据保存在文件</strong></p>
<p>优点： 数据永久保存</p>
<p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p>
<p><strong>数据保存在数据库</strong></p>
<p>1）数据永久保存</p>
<p>2）使用SQL语句，查询方便效率高。</p>
<p>3）管理数据方便</p>
<h3 id="什么是sql"><a class="markdownIt-Anchor" href="#什么是sql"></a> 什么是SQL？</h3>
<p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p>
<p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p>
<h3 id="什么是mysql"><a class="markdownIt-Anchor" href="#什么是mysql"></a> 什么是MySQL?</h3>
<p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p>
<h3 id="数据库三大范式是什么"><a class="markdownIt-Anchor" href="#数据库三大范式是什么"></a> 数据库三大范式是什么</h3>
<p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>
<h3 id="mysql有关权限的表都有哪几个"><a class="markdownIt-Anchor" href="#mysql有关权限的表都有哪几个"></a> mysql有关权限的表都有哪几个</h3>
<p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别为user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p>
<ul>
<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li>db权限表：记录各个帐号在各个数据库上的操作权限。</li>
<li>table_priv权限表：记录数据表级的操作权限。</li>
<li>columns_priv权限表：记录数据列级的操作权限。</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ul>
<h3 id="mysql的binlog有几种录入格式分别有什么区别"><a class="markdownIt-Anchor" href="#mysql的binlog有几种录入格式分别有什么区别"></a> MySQL的binlog有几种录入格式？分别有什么区别？</h3>
<p>有三种格式，statement，row和mixed。</p>
<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<h3 id="mysql有哪些数据类型"><a class="markdownIt-Anchor" href="#mysql有哪些数据类型"></a> mysql有哪些数据类型</h3>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>类型名称</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>整数类型</strong></td>
<td>tinyInt</td>
<td>很小的整数(8位二进制)</td>
</tr>
<tr>
<td></td>
<td>smallint</td>
<td>小的整数(16位二进制)</td>
</tr>
<tr>
<td></td>
<td>mediumint</td>
<td>中等大小的整数(24位二进制)</td>
</tr>
<tr>
<td></td>
<td>int(integer)</td>
<td>普通大小的整数(32位二进制)</td>
</tr>
<tr>
<td><strong>小数类型</strong></td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td></td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td></td>
<td>decimal(m,d)</td>
<td>压缩严格的定点数</td>
</tr>
<tr>
<td><strong>日期类型</strong></td>
<td>year</td>
<td>YYYY 1901~2155</td>
</tr>
<tr>
<td></td>
<td>time</td>
<td>HH:MM:SS -838:59:59~838:59:59</td>
</tr>
<tr>
<td></td>
<td>date</td>
<td>YYYY-MM-DD 1000-01-01~9999-12-3</td>
</tr>
<tr>
<td></td>
<td>datetime</td>
<td>YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>
</tr>
<tr>
<td></td>
<td>timestamp</td>
<td>YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>
</tr>
<tr>
<td><strong>文本、二进制类型</strong></td>
<td>CHAR(M)</td>
<td>M为0~255之间的整数</td>
</tr>
<tr>
<td></td>
<td>VARCHAR(M)</td>
<td>M为0~65535之间的整数</td>
</tr>
<tr>
<td></td>
<td>TINYBLOB</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td>BLOB</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMBLOB</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td>LONGBLOB</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td>TINYTEXT</td>
<td>允许长度0~255字节</td>
</tr>
<tr>
<td></td>
<td>TEXT</td>
<td>允许长度0~65535字节</td>
</tr>
<tr>
<td></td>
<td>MEDIUMTEXT</td>
<td>允许长度0~167772150字节</td>
</tr>
<tr>
<td></td>
<td>LONGTEXT</td>
<td>允许长度0~4294967295字节</td>
</tr>
<tr>
<td></td>
<td>VARBINARY(M)</td>
<td>允许长度0~M个字节的变长字节字符串</td>
</tr>
<tr>
<td></td>
<td>BINARY(M)</td>
<td>允许长度0~M个字节的定长字节字符串</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><code>1、整数类型</code>，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br />
<code>长度</code>：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br />
<code>例子</code>，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>
</li>
<li>
<p><code>2、实数类型</code>，包括FLOAT、DOUBLE、DECIMAL。<br />
DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br />
而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br />
计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>
</li>
<li>
<p><code>3、字符串类型</code>，包括VARCHAR、CHAR、TEXT、BLOB<br />
VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br />
VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br />
VARCHAR存储的内容超出设置的长度时，内容会被截断。<br />
CHAR是定长的，根据定义的字符串长度分配足够的空间。<br />
CHAR会根据需要使用空格进行填充方便比较。<br />
CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br />
CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>
<p><strong>使用策略：</strong><br />
对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br />
对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br />
使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br />
尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>
</li>
<li>
<p><code>4、枚举类型（ENUM）</code>，把不重复的数据存储为一个预定义的集合。<br />
有时可以使用ENUM代替常用的字符串类型。<br />
ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br />
ENUM在内部存储时，其实存的是整数。<br />
尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br />
排序是按照内部存储的整数</p>
</li>
<li>
<p><code>5、日期和时间类型</code>，尽量使用timestamp，空间效率高于datetime，<br />
用整数保存时间戳通常不方便处理。<br />
如果需要存储微妙，可以使用bigint存储。<br />
看到这里，这道真题是不是就比较容易回答了。</p>
</li>
</ul>
<h2 id="引擎"><a class="markdownIt-Anchor" href="#引擎"></a> 引擎</h2>
<h3 id="mysql存储引擎myisam与innodb区别"><a class="markdownIt-Anchor" href="#mysql存储引擎myisam与innodb区别"></a> MySQL存储引擎MyISAM与InnoDB区别</h3>
<p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>
<p>常用的存储引擎有以下：</p>
<ul>
<li><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>
<li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>
<li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ul>
<p><strong>MyISAM与InnoDB区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>MyISAM</th>
<th>Innodb</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>
<td>所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>
</tr>
<tr>
<td>存储空间</td>
<td>MyISAM可被压缩，存储空间较小</td>
<td>InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>
</tr>
<tr>
<td>可移植性、备份及恢复</td>
<td>由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>
<td>免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>
</tr>
<tr>
<td>文件格式</td>
<td>数据和索引是分别存储的，数据<code>.MYD</code>，索引<code>.MYI</code></td>
<td>数据和索引是集中存储的，<code>.ibd</code></td>
</tr>
<tr>
<td>记录存储顺序</td>
<td>按记录插入顺序保存</td>
<td>按主键大小有序插入</td>
</tr>
<tr>
<td>外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>
<td>表级锁定</td>
<td>行级锁定、表级锁定，锁定力度小并发能力高</td>
</tr>
<tr>
<td>SELECT</td>
<td>MyISAM更优</td>
<td></td>
</tr>
<tr>
<td>INSERT、UPDATE、DELETE</td>
<td></td>
<td>InnoDB更优</td>
</tr>
<tr>
<td>select count(*)</td>
<td>myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>
<td></td>
</tr>
<tr>
<td>索引的实现方式</td>
<td>B+树索引，myisam 是堆表</td>
<td>B+树索引，Innodb 是索引组织表</td>
</tr>
<tr>
<td>哈希索引</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>
<h3 id="myisam索引与innodb索引的区别"><a class="markdownIt-Anchor" href="#myisam索引与innodb索引的区别"></a> MyISAM索引与InnoDB索引的区别？</h3>
<ul>
<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>
<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>
<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>
<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>
</ul>
<h3 id="innodb引擎的4大特性"><a class="markdownIt-Anchor" href="#innodb引擎的4大特性"></a> InnoDB引擎的4大特性</h3>
<ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3 id="存储引擎选择"><a class="markdownIt-Anchor" href="#存储引擎选择"></a> 存储引擎选择</h3>
<p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p>
<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>
<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p>
<h2 id="索引"><a class="markdownIt-Anchor" href="#索引"></a> 索引</h2>
<h3 id="什么是索引"><a class="markdownIt-Anchor" href="#什么是索引"></a> 什么是索引？</h3>
<p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>
<p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>
<p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p>
<h3 id="索引有哪些优缺点"><a class="markdownIt-Anchor" href="#索引有哪些优缺点"></a> 索引有哪些优缺点？</h3>
<p>索引的优点</p>
<ul>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>索引的缺点</p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h3 id="索引使用场景重点"><a class="markdownIt-Anchor" href="#索引使用场景重点"></a> 索引使用场景（重点）</h3>
<p>where</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2ZTFiNTU4YjI?x-oss-process=image/format,png" alt="img" /></p>
<p>上图中，根据<code>id</code>查询记录，因为<code>id</code>字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 增加一个没有建立索引的字段</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> innodb1 <span class="keyword">add</span> sex <span class="type">char</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 按sex检索时可选的索引为null</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> innodb1 <span class="keyword">where</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2Zjk1YTdmOTk?x-oss-process=image/format,png" alt="img" /></p>
<blockquote>
<p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（<code>alter table 表名 add index(字段名)</code>），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p>
</blockquote>
<p>order by</p>
<p>当我们使用<code>order by</code>将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>
<p>但是如果我们对该字段建立索引<code>alter table 表名 add index(字段名)</code>，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong>，而不用像上述那<strong>取出所有数据</strong>进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>
<p>join</p>
<blockquote>
<p>对<code>join</code>语句匹配关系（<code>on</code>）涉及的字段建立索引能够提高效率</p>
</blockquote>
<p>索引覆盖</p>
<p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在<code>select</code>后只写必要的查询字段，以增加索引覆盖的几率。</p>
<p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p>
<h3 id="索引有哪几种类型"><a class="markdownIt-Anchor" href="#索引有哪几种类型"></a> 索引有哪几种类型？</h3>
<p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>
<p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column);</code> 创建唯一索引</li>
<li>可以通过 <code>ALTER TABLE table_name ADD UNIQUE (column1,column2);</code> 创建唯一组合索引</li>
</ul>
<p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<ul>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name (column);</code>创建普通索引</li>
<li>可以通过<code>ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);</code>创建组合索引</li>
</ul>
<p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p>
<ul>
<li>可以通过<code>ALTER TABLE table_name ADD FULLTEXT (column);</code>创建全文索引</li>
</ul>
<h3 id="索引的数据结构b树hash"><a class="markdownIt-Anchor" href="#索引的数据结构b树hash"></a> 索引的数据结构（b树，hash）</h3>
<p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>1）B树索引</p>
<p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNGRhY2Y2ZjU?x-oss-process=image/format,png" alt="img" /></p>
<p>查询方式：</p>
<p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p>
<p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p>
<p>B+tree性质：</p>
<p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p>
<p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>
<p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p>
<p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p>
<p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>
<p>2）哈希索引</p>
<p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzI0LzE2NjBjMGYxNThhNzZmOTQ?x-oss-process=image/format,png" alt="img" /></p>
<h3 id="索引的基本原理"><a class="markdownIt-Anchor" href="#索引的基本原理"></a> 索引的基本原理</h3>
<p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>
<p>索引的原理很简单，就是把无序的数据变成有序的查询</p>
<ol>
<li>把创建了索引的列的内容进行排序</li>
<li>对排序结果生成倒排表</li>
<li>在倒排表内容上拼上数据地址链</li>
<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>
</ol>
<h3 id="索引算法有哪些"><a class="markdownIt-Anchor" href="#索引算法有哪些"></a> 索引算法有哪些？</h3>
<p>索引算法有 BTree算法和Hash算法</p>
<p><strong>BTree算法</strong></p>
<p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 只要它的查询条件是一个不以通配符开头的常量</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;jack%&#x27;</span>; </span><br><span class="line"><span class="comment">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%jack&#x27;</span>; </span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p><strong>Hash算法</strong></p>
<p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p>
<h3 id="索引设计的原则"><a class="markdownIt-Anchor" href="#索引设计的原则"></a> 索引设计的原则？</h3>
<ol>
<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>
<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>
<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>
<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>
</ol>
<h3 id="创建索引的原则重中之重"><a class="markdownIt-Anchor" href="#创建索引的原则重中之重"></a> 创建索引的原则（重中之重）</h3>
<p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p>
<p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
<p>2）较频繁作为查询条件的字段才去创建索引</p>
<p>3）更新频繁字段不适合创建索引</p>
<p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p>
<p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>
<p>6）定义有外键的数据列一定要建立索引。</p>
<p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p>
<p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p>
<h3 id="创建索引的三种方式删除索引"><a class="markdownIt-Anchor" href="#创建索引的三种方式删除索引"></a> 创建索引的三种方式，删除索引</h3>
<p>第一种方式：在执行CREATE TABLE时创建索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_index2 (</span><br><span class="line">	id <span class="type">INT</span> auto_increment <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	first_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	last_name <span class="type">VARCHAR</span> (<span class="number">16</span>),</span><br><span class="line">	id_card <span class="type">VARCHAR</span> (<span class="number">18</span>),</span><br><span class="line">	information text,</span><br><span class="line">	KEY name (first_name, last_name),</span><br><span class="line">	FULLTEXT KEY (information),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>第二种方式：使用ALTER TABLE命令去增加索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name (column_list);</span><br></pre></td></tr></table></figure>
<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>
<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<p>第三种方式：使用CREATE INDEX命令创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column_list);</span><br></pre></td></tr></table></figure>
<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>
<p>删除索引</p>
<p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY id_card;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index <span class="keyword">drop</span> KEY information;</span><br></pre></td></tr></table></figure>
<p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS8yLzE5LzE2OTA0NTk2YjIxZTIwOWM?x-oss-process=image/format,png" alt="img" /></p>
<p>需要取消自增长再行删除：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> user_index</span><br><span class="line"><span class="comment">-- 重新定义字段</span></span><br><span class="line">MODIFY id <span class="type">int</span>,</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">PRIMARY</span> KEY</span><br></pre></td></tr></table></figure>
<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
<h3 id="创建索引时需要注意什么"><a class="markdownIt-Anchor" href="#创建索引时需要注意什么"></a> 创建索引时需要注意什么？</h3>
<ul>
<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h3 id="使用索引查询一定能提高查询的性能吗为什么"><a class="markdownIt-Anchor" href="#使用索引查询一定能提高查询的性能吗为什么"></a> 使用索引查询一定能提高查询的性能吗？为什么</h3>
<p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p>
<ul>
<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h3 id="百万级别或以上的数据如何删除"><a class="markdownIt-Anchor" href="#百万级别或以上的数据如何删除"></a> 百万级别或以上的数据如何删除</h3>
<p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>
<ol>
<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>
<li>然后删除其中无用数据（此过程需要不到两分钟）</li>
<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>
</ol>
<h3 id="前缀索引"><a class="markdownIt-Anchor" href="#前缀索引"></a> 前缀索引</h3>
<p>语法：<code>index(field(10))</code>，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p>
<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>
<p>实操的难度：在于前缀截取的长度。</p>
<p>我们可以利用<code>select count(*)/count(distinct left(password,prefixLen));</code>，通过从调整<code>prefixLen</code>的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前<code>prefixLen</code>个字符几乎能确定唯一一条记录）</p>
<h3 id="什么是最左前缀原则什么是最左匹配原则"><a class="markdownIt-Anchor" href="#什么是最左前缀原则什么是最左匹配原则"></a> 什么是最左前缀原则？什么是最左匹配原则</h3>
<ul>
<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>
<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>
<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>
</ul>
<h3 id="b树和b树的区别"><a class="markdownIt-Anchor" href="#b树和b树的区别"></a> B树和B+树的区别</h3>
<ul>
<li>
<p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p>
</li>
<li>
<p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgyZTc1OWNmMTI?x-oss-process=image/format,png" alt="img" /></p>
</li>
</ul>
<h3 id="使用b树的好处"><a class="markdownIt-Anchor" href="#使用b树的好处"></a> 使用B树的好处</h3>
<p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>
<h3 id="使用b树的好处-2"><a class="markdownIt-Anchor" href="#使用b树的好处-2"></a> 使用B+树的好处</h3>
<p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>
<h3 id="hash索引和b树所有有什么区别或者说优劣呢"><a class="markdownIt-Anchor" href="#hash索引和b树所有有什么区别或者说优劣呢"></a> Hash索引和B+树所有有什么区别或者说优劣呢?</h3>
<p>首先要知道Hash索引和B+树索引的底层实现原理：</p>
<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p>
<p>那么可以看出他们有以下的不同：</p>
<ul>
<li>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li>
</ul>
<p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>
<ul>
<li>hash索引不支持使用索引进行排序，原理同上。</li>
<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li>
<li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li>
<li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li>
</ul>
<p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p>
<h3 id="数据库为什么使用b树而不是b树"><a class="markdownIt-Anchor" href="#数据库为什么使用b树而不是b树"></a> 数据库为什么使用B+树而不是B树</h3>
<ul>
<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>
<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>
<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>
<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>
<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>
</ul>
<h3 id="b树在满足聚簇索引和覆盖索引的时候不需要回表查询数据"><a class="markdownIt-Anchor" href="#b树在满足聚簇索引和覆盖索引的时候不需要回表查询数据"></a> B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h3>
<p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>
<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>
<h3 id="什么是聚簇索引何时使用聚簇索引与非聚簇索引"><a class="markdownIt-Anchor" href="#什么是聚簇索引何时使用聚簇索引与非聚簇索引"></a> 什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h3>
<ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>
<p>何时使用聚簇索引与非聚簇索引</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDE1NDQ5OS1kNTNhNWNlOWNlY2YyMmYzLnBuZw?x-oss-process=image/format,png" alt="img" /></p>
<h3 id="非聚簇索引一定会回表查询吗"><a class="markdownIt-Anchor" href="#非聚簇索引一定会回表查询吗"></a> 非聚簇索引一定会回表查询吗？</h3>
<p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>
<h3 id="联合索引是什么为什么需要注意联合索引中的顺序"><a class="markdownIt-Anchor" href="#联合索引是什么为什么需要注意联合索引中的顺序"></a> 联合索引是什么？为什么需要注意联合索引中的顺序？</h3>
<p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<p>具体原因为:</p>
<p>MySQL使用索引时需要索引有序，假设现在建立了&quot;name，age，school&quot;的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>
<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
<h2 id="事务"><a class="markdownIt-Anchor" href="#事务"></a> 事务</h2>
<h3 id="什么是数据库事务"><a class="markdownIt-Anchor" href="#什么是数据库事务"></a> 什么是数据库事务？</h3>
<p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>
<p>事务最经典也经常被拿出来说例子就是转账了。</p>
<p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h3 id="事物的四大特性acid介绍一下"><a class="markdownIt-Anchor" href="#事物的四大特性acid介绍一下"></a> 事物的四大特性(ACID)介绍一下?</h3>
<p>关系性数据库需要遵循ACID规则，具体内容如下：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzIwLzE2MzdiMDhiOTg2MTk0NTU?x-oss-process=image/format,png" alt="事务的特性" /></p>
<ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="什么是脏读幻读不可重复读"><a class="markdownIt-Anchor" href="#什么是脏读幻读不可重复读"></a> 什么是脏读？幻读？不可重复读？</h3>
<ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
</ul>
<h3 id="什么是事务的隔离级别mysql的默认隔离级别是什么"><a class="markdownIt-Anchor" href="#什么是事务的隔离级别mysql的默认隔离级别是什么"></a> 什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3>
<p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻影读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p>
<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取提交内容):</strong>，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p>
<h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2>
<h3 id="对mysql的锁了解吗"><a class="markdownIt-Anchor" href="#对mysql的锁了解吗"></a> 对MySQL的锁了解吗</h3>
<p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p>
<p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p>
<h3 id="隔离级别与锁的关系"><a class="markdownIt-Anchor" href="#隔离级别与锁的关系"></a> 隔离级别与锁的关系</h3>
<p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>
<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>
<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>
<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</p>
<h3 id="按照锁的粒度分数据库锁有哪些锁机制与innodb锁算法"><a class="markdownIt-Anchor" href="#按照锁的粒度分数据库锁有哪些锁机制与innodb锁算法"></a> 按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h3>
<p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>
<p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li>
</ul>
<p>行级锁，表级锁和页级锁对比</p>
<p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>
<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>
<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
<h3 id="从锁的类别上分mysql都有哪些锁呢像上面那样子进行锁定岂不是有点阻碍并发效率了"><a class="markdownIt-Anchor" href="#从锁的类别上分mysql都有哪些锁呢像上面那样子进行锁定岂不是有点阻碍并发效率了"></a> 从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</h3>
<p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p>
<p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>
<p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p>
<p>他们的加锁开销从大到小，并发能力也是从大到小。</p>
<h3 id="mysql中innodb引擎的行锁是怎么实现的"><a class="markdownIt-Anchor" href="#mysql中innodb引擎的行锁是怎么实现的"></a> MySQL中InnoDB引擎的行锁是怎么实现的？</h3>
<p>答：InnoDB是基于索引来完成行锁</p>
<p>例: select * from tab_with_index where id = 1 for update;</p>
<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p>
<h3 id="innodb存储引擎的锁的算法有三种"><a class="markdownIt-Anchor" href="#innodb存储引擎的锁的算法有三种"></a> InnoDB存储引擎的锁的算法有三种</h3>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p><strong>相关知识点：</strong></p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
<h3 id="什么是死锁怎么解决"><a class="markdownIt-Anchor" href="#什么是死锁怎么解决"></a> 什么是死锁？怎么解决？</h3>
<p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>
<p>常见的解决死锁的方法</p>
<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>
<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>
<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>
<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p>
<h3 id="数据库的乐观锁和悲观锁是什么怎么实现的"><a class="markdownIt-Anchor" href="#数据库的乐观锁和悲观锁是什么怎么实现的"></a> 数据库的乐观锁和悲观锁是什么？怎么实现的？</h3>
<p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>
<p><strong>两种锁的使用场景</strong></p>
<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>
<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p>
<h2 id="视图"><a class="markdownIt-Anchor" href="#视图"></a> 视图</h2>
<h3 id="为什么要使用视图什么是视图"><a class="markdownIt-Anchor" href="#为什么要使用视图什么是视图"></a> 为什么要使用视图？什么是视图？</h3>
<p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p>
<p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p>
<h3 id="视图有哪些特点"><a class="markdownIt-Anchor" href="#视图有哪些特点"></a> 视图有哪些特点？</h3>
<p>视图的特点如下:</p>
<ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
</ul>
<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>
<h3 id="视图的使用场景有哪些"><a class="markdownIt-Anchor" href="#视图的使用场景有哪些"></a> 视图的使用场景有哪些？</h3>
<p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p>
<p>下面是视图的常见使用场景：</p>
<ul>
<li>重用SQL语句；</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h3 id="视图的优点"><a class="markdownIt-Anchor" href="#视图的优点"></a> 视图的优点</h3>
<ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h3 id="视图的缺点"><a class="markdownIt-Anchor" href="#视图的缺点"></a> 视图的缺点</h3>
<ol>
<li>
<p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>
</li>
<li>
<p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p>
<p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p>
</li>
</ol>
<h3 id="什么是游标"><a class="markdownIt-Anchor" href="#什么是游标"></a> 什么是游标？</h3>
<p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p>
<h2 id="存储过程与函数"><a class="markdownIt-Anchor" href="#存储过程与函数"></a> 存储过程与函数</h2>
<h3 id="什么是存储过程有哪些优缺点"><a class="markdownIt-Anchor" href="#什么是存储过程有哪些优缺点"></a> 什么是存储过程？有哪些优缺点？</h3>
<p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>
<p><strong>优点</strong></p>
<p>1）存储过程是预编译过的，执行效率高。</p>
<p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>
<p>3）安全性高，执行存储过程需要有一定权限的用户。</p>
<p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p>
<p><strong>缺点</strong></p>
<p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p>
<p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p>
<p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p>
<p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p>
<h2 id="触发器"><a class="markdownIt-Anchor" href="#触发器"></a> 触发器</h2>
<h3 id="什么是触发器触发器的使用场景有哪些"><a class="markdownIt-Anchor" href="#什么是触发器触发器的使用场景有哪些"></a> 什么是触发器？触发器的使用场景有哪些？</h3>
<p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>
<p>使用场景</p>
<ul>
<li>可以通过数据库中的相关表实现级联更改。</li>
<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
<li>例如可以生成某些业务的编号。</li>
<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>
<li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li>
</ul>
<h3 id="mysql中都有哪些触发器"><a class="markdownIt-Anchor" href="#mysql中都有哪些触发器"></a> MySQL中都有哪些触发器？</h3>
<p>在MySQL数据库中有如下六种触发器：</p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h2 id="常用sql语句"><a class="markdownIt-Anchor" href="#常用sql语句"></a> 常用SQL语句</h2>
<h3 id="sql语句主要分为哪几类"><a class="markdownIt-Anchor" href="#sql语句主要分为哪几类"></a> SQL语句主要分为哪几类</h3>
<p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>
<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>
<p>数据查询语言DQL（Data Query Language）SELECT</p>
<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>
<p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>
<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>
<p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>
<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>
<h3 id="超键-候选键-主键-外键分别是什么"><a class="markdownIt-Anchor" href="#超键-候选键-主键-外键分别是什么"></a> 超键、候选键、主键、外键分别是什么？</h3>
<ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li>候选键：是最小超键，即没有冗余元素的超键。</li>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h3 id="sql-约束有哪几种"><a class="markdownIt-Anchor" href="#sql-约束有哪几种"></a> SQL 约束有哪几种？</h3>
<blockquote>
<p>SQL 约束有哪几种？</p>
</blockquote>
<ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h3 id="六种关联查询"><a class="markdownIt-Anchor" href="#六种关联查询"></a> 六种关联查询</h3>
<ul>
<li>交叉连接（CROSS JOIN）</li>
<li>内连接（INNER JOIN）</li>
<li>外连接（LEFT JOIN/RIGHT JOIN）</li>
<li>联合查询（UNION与UNION ALL）</li>
<li>全连接（FULL JOIN）</li>
<li>交叉连接（CROSS JOIN）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A,B(,C)或者<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> B (<span class="keyword">CROSS</span> <span class="keyword">JOIN</span> C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（<span class="keyword">INNER</span> <span class="keyword">JOIN</span>）<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A,B <span class="keyword">WHERE</span> A.id<span class="operator">=</span>B.id或者<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id<span class="operator">=</span>B.id多表中同时符合某种条件的数据记录的集合，<span class="keyword">INNER</span> <span class="keyword">JOIN</span>可以缩写为<span class="keyword">JOIN</span></span><br></pre></td></tr></table></figure>
<p>内连接分为三类</p>
<ul>
<li>等值连接：ON <a href="http://A.id=B.id">A.id=B.id</a></li>
<li>不等值连接：ON <a href="http://A.id">A.id</a> &gt; <a href="http://B.id">B.id</a></li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>
</ul>
<p>外连接（LEFT JOIN/RIGHT JOIN）</p>
<ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>
</ul>
<p>联合查询（UNION与UNION ALL）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">UNION</span> ...</span><br></pre></td></tr></table></figure>
<ul>
<li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<p>全连接（FULL JOIN）</p>
<ul>
<li>MySQL不支持全连接</li>
<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id<span class="operator">=</span>B.id UNIONSELECT <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id<span class="operator">=</span>B.id</span><br></pre></td></tr></table></figure>
<p>表连接面试题</p>
<p>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p>
<p>R表</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
</tr>
</tbody>
</table>
<p>S表</p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>c4</td>
<td>d3</td>
</tr>
</tbody>
</table>
<ol>
<li>交叉连接(笛卡尔积):</li>
</ol>
<p>select r.<code>*</code>,s.<code>*</code> from r,s</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c4</td>
<td>d3</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>内连接结果：</p>
<p>select r.<code>*</code>,s.<code>*</code> from r inner join s on r.c=s.c</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>左连接结果：</p>
<p>select r.<code>*</code>,s.<code>*</code> from r left join s on r.c=s.c</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>右连接结果：</p>
<p>select r.<code>*</code>,s.<code>*</code> from r right join s on r.c=s.c</p>
</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>B</td>
<td>C</td>
<td>C</td>
<td>D</td>
</tr>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody>
</table>
<ol>
<li>
<p>全表连接的结果（MySql不支持，Oracle支持）：</p>
<p>select r.<code>*</code>,s.<code>*</code> from r full join s on r.c=s.c</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
</tr>
</thead>
<tbody>
<tr>
<td>a1</td>
<td>b1</td>
<td>c1</td>
<td>c1</td>
<td>d1</td>
</tr>
<tr>
<td>a2</td>
<td>b2</td>
<td>c2</td>
<td>c2</td>
<td>d2</td>
</tr>
<tr>
<td>a3</td>
<td>b3</td>
<td>c3</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>c4</td>
<td>d3</td>
</tr>
</tbody>
</table>
<h3 id="什么是子查询"><a class="markdownIt-Anchor" href="#什么是子查询"></a> 什么是子查询</h3>
<ol>
<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li>
<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>
</ol>
<h3 id="子查询的三种情况"><a class="markdownIt-Anchor" href="#子查询的三种情况"></a> 子查询的三种情况</h3>
<ol>
<li>子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> employee);   </span><br></pre></td></tr></table></figure>
<ol>
<li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询工资最高的员工是谁？ </span></span><br><span class="line"><span class="keyword">select</span>  <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary<span class="operator">=</span>(<span class="keyword">select</span> <span class="built_in">max</span>(salary) <span class="keyword">from</span> employee);    </span><br></pre></td></tr></table></figure>
<ol>
<li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1) 查询出2011年以后入职的员工信息</span></span><br><span class="line"><span class="comment">-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept d,  (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> join_date <span class="operator">&gt;</span> <span class="string">&#x27;2011-1-1&#x27;</span>) e <span class="keyword">where</span> e.dept_id <span class="operator">=</span>  d.id;    </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用表连接：</span></span><br><span class="line"><span class="keyword">select</span> d.<span class="operator">*</span>, e.<span class="operator">*</span> <span class="keyword">from</span>  dept d <span class="keyword">inner</span> <span class="keyword">join</span> employee e <span class="keyword">on</span> d.id <span class="operator">=</span> e.dept_id <span class="keyword">where</span> e.join_date <span class="operator">&gt;</span>  <span class="string">&#x27;2011-1-1&#x27;</span>  </span><br></pre></td></tr></table></figure>
<h3 id="mysql中-in-和-exists-区别"><a class="markdownIt-Anchor" href="#mysql中-in-和-exists-区别"></a> mysql中 in 和 exists 区别</h3>
<p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p>
<ol>
<li>如果查询的两个表大小相当，那么用in和exists差别不大。</li>
<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li>
<li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li>
</ol>
<h3 id="varchar与char的区别"><a class="markdownIt-Anchor" href="#varchar与char的区别"></a> varchar与char的区别</h3>
<p><strong>char的特点</strong></p>
<ul>
<li>char表示定长字符串，长度是固定的；</li>
<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>
<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>
<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>
</ul>
<p><strong>varchar的特点</strong></p>
<ul>
<li>varchar表示可变长字符串，长度是可变的；</li>
<li>插入的数据是多长，就按照多长来存储；</li>
<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>
<li>对于varchar来说，最多能存放的字符个数为65532</li>
</ul>
<p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p>
<h3 id="varchar50中50的涵义"><a class="markdownIt-Anchor" href="#varchar50中50的涵义"></a> varchar(50)中50的涵义</h3>
<p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p>
<h3 id="int20中20的涵义"><a class="markdownIt-Anchor" href="#int20中20的涵义"></a> int(20)中20的涵义</h3>
<p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p>
<p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>
<h3 id="mysql为什么这么设计"><a class="markdownIt-Anchor" href="#mysql为什么这么设计"></a> mysql为什么这么设计</h3>
<p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p>
<h3 id="mysql中int10和char10以及varchar10的区别"><a class="markdownIt-Anchor" href="#mysql中int10和char10以及varchar10的区别"></a> mysql中int(10)和char(10)以及varchar(10)的区别</h3>
<ul>
<li>
<p>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</p>
<p>int(10) 10位的数据长度 9999999999，占32个字节，int型4位<br />
char(10) 10位固定字符串，不足补空格 最多10个字符<br />
varchar(10) 10位可变字符串，不足补空格 最多10个字符</p>
</li>
<li>
<p>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</p>
</li>
<li>
<p>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</p>
</li>
</ul>
<h3 id="float和double的区别是什么"><a class="markdownIt-Anchor" href="#float和double的区别是什么"></a> FLOAT和DOUBLE的区别是什么？</h3>
<ul>
<li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li>
<li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li>
</ul>
<h3 id="drop-delete与truncate的区别"><a class="markdownIt-Anchor" href="#drop-delete与truncate的区别"></a> drop、delete与truncate的区别</h3>
<p>三者都表示删除，但是三者有一些差别：</p>
<table>
<thead>
<tr>
<th></th>
<th>Delete</th>
<th>Truncate</th>
<th>Drop</th>
</tr>
</thead>
<tbody>
<tr>
<td>类型</td>
<td>属于DML</td>
<td>属于DDL</td>
<td>属于DDL</td>
</tr>
<tr>
<td>回滚</td>
<td>可回滚</td>
<td>不可回滚</td>
<td>不可回滚</td>
</tr>
<tr>
<td>删除内容</td>
<td>表结构还在，删除表的全部或者一部分数据行</td>
<td>表结构还在，删除表中的所有数据</td>
<td>从数据库中删除表，所有的数据行，索引和权限也会被删除</td>
</tr>
<tr>
<td>删除速度</td>
<td>删除速度慢，需要逐行删除</td>
<td>删除速度快</td>
<td>删除速度最快</td>
</tr>
</tbody>
</table>
<p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p>
<h3 id="union与union-all的区别"><a class="markdownIt-Anchor" href="#union与union-all的区别"></a> UNION与UNION ALL的区别？</h3>
<ul>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<h2 id="sql优化"><a class="markdownIt-Anchor" href="#sql优化"></a> SQL优化</h2>
<h3 id="如何定位及优化sql语句的性能问题创建的索引有没有被使用到或者说怎么才可以知道这条语句运行很慢的原因"><a class="markdownIt-Anchor" href="#如何定位及优化sql语句的性能问题创建的索引有没有被使用到或者说怎么才可以知道这条语句运行很慢的原因"></a> 如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h3>
<p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</p>
<p><img src="https://img-blog.csdnimg.cn/20200310171131582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
<p>执行计划包含的信息 <strong>id</strong> 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>
<ul>
<li>id相同执行顺序由上至下。</li>
<li>id不同，id值越大优先级越高，越先被执行。</li>
<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>
</ul>
<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>SIMPLE</td>
<td>不包含任何子查询或union等查询</td>
</tr>
<tr>
<td>2</td>
<td>PRIMARY</td>
<td>包含子查询最外层查询就显示为 PRIMARY</td>
</tr>
<tr>
<td>3</td>
<td>SUBQUERY</td>
<td>在select或 where字句中包含的查询</td>
</tr>
<tr>
<td>4</td>
<td>DERIVED</td>
<td>from字句中包含的查询</td>
</tr>
<tr>
<td>5</td>
<td>UNION</td>
<td>出现在union后的查询语句中</td>
</tr>
<tr>
<td>6</td>
<td>UNION RESULT</td>
<td>从UNION中获取结果集，例如上文的第三个例子</td>
</tr>
</tbody>
</table>
<p><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tmp (</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) engine <span class="operator">=</span> innodb</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> key (id) partitions <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型</p>
<ul>
<li>ALL 扫描全表数据</li>
<li>index 遍历索引</li>
<li>range 索引范围查找</li>
<li>index_subquery 在子查询中使用 ref</li>
<li>unique_subquery 在子查询中使用 eq_ref</li>
<li>ref_or_null 对Null进行索引的优化的 ref</li>
<li>fulltext 使用全文索引</li>
<li>ref 使用非唯一索引查找数据</li>
<li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li>
</ul>
<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p>
<p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>
<p><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p>
<p><strong>key_length</strong> 索引长度</p>
<p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>
<p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p>
<p><strong>extra</strong> 的信息非常丰富，常见的有：</p>
<ol>
<li>Using index 使用覆盖索引</li>
<li>Using where 使用了用where子句来过滤结果集</li>
<li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li>
<li>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 </span><br><span class="line">说明： </span><br><span class="line">1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 </span><br><span class="line">2） ref 指的是使用普通的索引（normal index）。 </span><br><span class="line">3） range 对索引进行范围检索。 </span><br><span class="line">反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</span><br></pre></td></tr></table></figure>
<h3 id="sql的生命周期"><a class="markdownIt-Anchor" href="#sql的生命周期"></a> SQL的生命周期？</h3>
<ol>
<li>
<p>应用服务器与数据库服务器建立一个连接</p>
</li>
<li>
<p>数据库进程拿到请求sql</p>
</li>
<li>
<p>解析并生成执行计划，执行</p>
</li>
<li>
<p>读取数据到内存并进行逻辑处理</p>
</li>
<li>
<p>通过步骤一的连接，发送结果到客户端</p>
</li>
<li>
<p>关掉连接，释放资源</p>
<p><img src="https://img-blog.csdnimg.cn/20200310170936478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
</li>
</ol>
<h3 id="大表数据查询怎么优化"><a class="markdownIt-Anchor" href="#大表数据查询怎么优化"></a> 大表数据查询，怎么优化</h3>
<ol>
<li>优化shema、sql语句+索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li>
</ol>
<h3 id="超大分页怎么处理"><a class="markdownIt-Anchor" href="#超大分页怎么处理"></a> 超大分页怎么处理？</h3>
<p>超大的分页一般从两个方向上来解决.</p>
<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
<p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p>
<p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">【推荐】利用延迟关联或者子查询优化超多分页场景。 </span><br><span class="line"></span><br><span class="line">说明：MySQL并不是跳过<span class="keyword">offset</span>行，而是取<span class="keyword">offset</span><span class="operator">+</span>N行，然后返回放弃前<span class="keyword">offset</span>行，返回N行，那当<span class="keyword">offset</span>特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行<span class="keyword">SQL</span>改写。 </span><br><span class="line"></span><br><span class="line">正例：先快速定位需要获取的id段，然后再关联： </span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> a.<span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span> a, (<span class="keyword">select</span> id <span class="keyword">from</span> 表<span class="number">1</span> <span class="keyword">where</span> 条件 LIMIT <span class="number">100000</span>,<span class="number">20</span> ) b <span class="keyword">where</span> a.id<span class="operator">=</span>b.id</span><br></pre></td></tr></table></figure>
<h3 id="mysql-分页"><a class="markdownIt-Anchor" href="#mysql-分页"></a> mysql 分页</h3>
<p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 </span><br></pre></td></tr></table></figure>
<p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. </span><br></pre></td></tr></table></figure>
<p>如果只给定一个参数，它表示返回最大的记录行数目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 </span><br></pre></td></tr></table></figure>
<p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p>
<h3 id="慢查询日志"><a class="markdownIt-Anchor" href="#慢查询日志"></a> 慢查询日志</h3>
<blockquote>
<p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p>
</blockquote>
<p>开启慢查询日志</p>
<p>配置项：<code>slow_query_log</code></p>
<p>可以使用<code>show variables like ‘slov_query_log’</code>查看是否开启，如果状态值为<code>OFF</code>，可以使用<code>set GLOBAL slow_query_log = on</code>来开启，它会在<code>datadir</code>下产生一个<code>xxx-slow.log</code>的文件。</p>
<p>设置临界时间</p>
<p>配置项：<code>long_query_time</code></p>
<p>查看：<code>show VARIABLES like 'long_query_time'</code>，单位秒</p>
<p>设置：<code>set long_query_time=0.5</code></p>
<p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p>
<p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到<code>xxx-slow.log</code>中</p>
<h3 id="关心过业务系统里面的sql耗时吗统计过慢查询吗对慢查询都怎么优化过"><a class="markdownIt-Anchor" href="#关心过业务系统里面的sql耗时吗统计过慢查询吗对慢查询都怎么优化过"></a> 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h3>
<p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p>
<p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p>
<p>所以优化也是针对这三个方向来的，</p>
<ul>
<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>
<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>
<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>
</ul>
<h3 id="为什么要尽量设定一个主键"><a class="markdownIt-Anchor" href="#为什么要尽量设定一个主键"></a> 为什么要尽量设定一个主键？</h3>
<p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>
<h3 id="主键使用自增id还是uuid"><a class="markdownIt-Anchor" href="#主键使用自增id还是uuid"></a> 主键使用自增ID还是UUID？</h3>
<p>推荐使用自增ID，不要使用UUID。</p>
<p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>
<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p>
<p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p>
<h3 id="字段为什么要求定义为not-null"><a class="markdownIt-Anchor" href="#字段为什么要求定义为not-null"></a> 字段为什么要求定义为not null？</h3>
<p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>
<h3 id="如果要存储用户的密码散列应该使用什么字段进行存储"><a class="markdownIt-Anchor" href="#如果要存储用户的密码散列应该使用什么字段进行存储"></a> 如果要存储用户的密码散列，应该使用什么字段进行存储？</h3>
<p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p>
<h3 id="优化查询过程中的数据访问"><a class="markdownIt-Anchor" href="#优化查询过程中的数据访问"></a> 优化查询过程中的数据访问</h3>
<ul>
<li>访问数据太多导致查询性能下降</li>
<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>
<li>确认MySQL服务器是否在分析大量不必要的数据行</li>
<li>避免犯如下SQL语句错误</li>
<li>查询不需要的数据。解决办法：使用limit解决</li>
<li>多表关联返回全部列。解决办法：指定列名</li>
<li>总是返回全部列。解决办法：避免使用SELECT *</li>
<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>
<li>是否在扫描额外的记录。解决办法：</li>
<li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li>
<li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li>
<li>改变数据库和表的结构，修改数据表范式</li>
<li>重写SQL语句，让优化器可以以更优的方式执行查询。</li>
</ul>
<h3 id="优化长难的查询语句"><a class="markdownIt-Anchor" href="#优化长难的查询语句"></a> 优化长难的查询语句</h3>
<ul>
<li>一个复杂查询还是多个简单查询</li>
<li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li>
<li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li>
<li>切分查询</li>
<li>将一个大的查询分为多个小的相同的查询</li>
<li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li>
<li>分解关联查询，让缓存的效率更高。</li>
<li>执行单个查询可以减少锁的竞争。</li>
<li>在应用层做关联更容易对数据库进行拆分。</li>
<li>查询效率会有大幅提升。</li>
<li>较少冗余记录的查询。</li>
</ul>
<h3 id="优化特定类型的查询语句"><a class="markdownIt-Anchor" href="#优化特定类型的查询语句"></a> 优化特定类型的查询语句</h3>
<ul>
<li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li>
<li>MyISAM中，没有任何where条件的count(*)非常快。</li>
<li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li>
<li>可以使用explain查询近似值，用近似值替代count(*)</li>
<li>增加汇总表</li>
<li>使用缓存</li>
</ul>
<h3 id="优化关联查询"><a class="markdownIt-Anchor" href="#优化关联查询"></a> 优化关联查询</h3>
<ul>
<li>确定ON或者USING子句中是否有索引。</li>
<li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li>
</ul>
<h3 id="优化子查询"><a class="markdownIt-Anchor" href="#优化子查询"></a> 优化子查询</h3>
<ul>
<li>用关联查询替代</li>
<li>优化GROUP BY和DISTINCT</li>
<li>这两种查询据可以使用索引来优化，是最有效的优化方法</li>
<li>关联查询中，使用标识列分组的效率更高</li>
<li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li>
<li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li>
</ul>
<h3 id="优化limit分页"><a class="markdownIt-Anchor" href="#优化limit分页"></a> 优化LIMIT分页</h3>
<ul>
<li>LIMIT偏移量大的时候，查询效率较低</li>
<li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li>
</ul>
<h3 id="优化union查询"><a class="markdownIt-Anchor" href="#优化union查询"></a> 优化UNION查询</h3>
<ul>
<li>UNION ALL的效率高于UNION</li>
</ul>
<h3 id="优化where子句"><a class="markdownIt-Anchor" href="#优化where子句"></a> 优化WHERE子句</h3>
<p>解题方法</p>
<p>对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p>
<p>SQL语句优化的一些方法？</p>
<ul>
<li>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line"><span class="comment">-- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> num<span class="operator">=</span><span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li><a href="http://5.in">5.in</a> 和 not in 也要慎用，否则会导致全表扫描，如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li>
<li>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">with</span>(index(索引名)) <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br></pre></td></tr></table></figure>
<ul>
<li>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">/</span><span class="number">2</span><span class="operator">=</span><span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">100</span><span class="operator">*</span><span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">1</span>,<span class="number">3</span>)<span class="operator">=</span>’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> ‘abc<span class="operator">%</span>’</span><br></pre></td></tr></table></figure>
<ul>
<li>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
</ul>
<h2 id="数据库优化"><a class="markdownIt-Anchor" href="#数据库优化"></a> 数据库优化</h2>
<h3 id="为什么要优化"><a class="markdownIt-Anchor" href="#为什么要优化"></a> 为什么要优化</h3>
<ul>
<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>
<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>
<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>
</ul>
<p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p>
<h3 id="数据库结构优化"><a class="markdownIt-Anchor" href="#数据库结构优化"></a> 数据库结构优化</h3>
<p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p>
<p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>
<p><strong>将字段很多的表分解成多个表</strong></p>
<p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p>
<p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>
<p><strong>增加中间表</strong></p>
<p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p>
<p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p>
<p><strong>增加冗余字段</strong></p>
<p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p>
<p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p>
<p><strong>注意：</strong></p>
<p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p>
<h3 id="mysql数据库cpu飙升到500的话他怎么处理"><a class="markdownIt-Anchor" href="#mysql数据库cpu飙升到500的话他怎么处理"></a> MySQL数据库cpu飙升到500%的话他怎么处理？</h3>
<p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>
<p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p>
<p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p>
<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p>
<h3 id="大表怎么优化某个表有近千万数据crud比较慢如何优化分库分表了是怎么做的分表分库了有什么问题有用到中间件么他们的原理知道么"><a class="markdownIt-Anchor" href="#大表怎么优化某个表有近千万数据crud比较慢如何优化分库分表了是怎么做的分表分库了有什么问题有用到中间件么他们的原理知道么"></a> 大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3>
<p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>
<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>
<ol>
<li>
<p><strong>垂直分区：</strong></p>
<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NDM1NGJhMmUwZmQ?x-oss-process=image/format,png" alt="img" /></p>
<p><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>
<h4 id="垂直分表"><a class="markdownIt-Anchor" href="#垂直分表"></a> 垂直分表</h4>
<p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dFZnBCTm4xZkNtdEVhMkRaNTlISFNSaWN2SEIzeU43Yk5LY1hkc3NWZGFNb25TOEFKanY5cFdBLzY0MA?x-oss-process=image/format,png" alt="img" /></p>
<h5 id="适用场景"><a class="markdownIt-Anchor" href="#适用场景"></a> 适用场景</h5>
<ul>
<li>1、如果一个表中某些列常用，另外一些列不常用</li>
<li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</li>
</ul>
<h5 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h5>
<ul>
<li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li>
<li>对于应用层来说，逻辑算法增加开发成本</li>
<li>管理冗余列，查询所有数据需要join操作</li>
</ul>
</li>
<li>
<p><strong>水平分区：</strong></p>
<p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>
<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC82LzE2LzE2NDA4NGI3ZTllNDIzZTM?x-oss-process=image/format,png" alt="数据库水平拆分" /></p>
<p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>
<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</p>
<p>《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<h4 id="水平分表"><a class="markdownIt-Anchor" href="#水平分表"></a> 水平分表：</h4>
<p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy90dVNhS2M2U2ZQcjh0NFBaVVFJVUszVHl0aWF3T0VRa2dkQVpyU1Y3M2liMWZkRENYS2M3QUd6Wmhid3FjS0ZVWkpGWThwMFZkVXRPM3JNYzZ2eDFBdzVBLzY0MA?x-oss-process=image/format,png" alt="img" /></p>
<h5 id="适用场景-2"><a class="markdownIt-Anchor" href="#适用场景-2"></a> 适用场景</h5>
<ul>
<li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li>
<li>2、需要把数据存放在多个介质上。</li>
</ul>
<h5 id="水平切分的缺点"><a class="markdownIt-Anchor" href="#水平切分的缺点"></a> 水平切分的缺点</h5>
<ul>
<li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li>
<li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li>
</ul>
<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>
<ul>
<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
</li>
</ol>
<p><strong>分库分表后面临的问题</strong></p>
<ul>
<li>
<p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>
</li>
<li>
<p><strong>跨库join</strong></p>
<p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p>
</li>
<li>
<p><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
</li>
<li>
<p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p>
</li>
<li>
<p><strong>ID问题</strong></p>
</li>
<li>
<p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p>
</li>
</ul>
<p><strong>UUID</strong> 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p>
<ul>
<li>
<p>跨分片的排序分页</p>
<p>般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200310170753848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RoaW5rV29u,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" /></p>
</li>
</ul>
<h3 id="mysql的复制原理以及流程"><a class="markdownIt-Anchor" href="#mysql的复制原理以及流程"></a> MySQL的复制原理以及流程</h3>
<p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>
<p><strong>主从复制的作用</strong></p>
<ol>
<li>主数据库出现问题，可以切换到从数据库。</li>
<li>可以进行数据库层面的读写分离。</li>
<li>可以在从数据库上进行日常备份。</li>
</ol>
<p><strong>MySQL主从复制解决的问题</strong></p>
<ul>
<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>
<li>负载均衡：降低单个服务器的压力</li>
<li>高可用和故障切换：帮助应用程序避免单点失败</li>
<li>升级测试：可以用更高版本的MySQL作为从库</li>
</ul>
<p><strong>MySQL主从复制工作原理</strong></p>
<ul>
<li>在主库上把数据更高记录到二进制日志</li>
<li>从库将主库的日志复制到自己的中继日志</li>
<li>从库读取中继日志的事件，将其重放到从库数据中</li>
</ul>
<p><strong>基本原理流程，3个线程以及之间的关联</strong></p>
<p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p>
<p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p>
<p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p>
<p><strong>复制过程</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC85LzIxLzE2NWZiNjgzMjIyMDViMmU?x-oss-process=image/format,png" alt="img" /></p>
<p>Binary log：主数据库的二进制日志</p>
<p>Relay log：从服务器的中继日志</p>
<p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>
<p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>
<p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>
<h3 id="读写分离有哪些解决方案"><a class="markdownIt-Anchor" href="#读写分离有哪些解决方案"></a> 读写分离有哪些解决方案？</h3>
<p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求<code>slave</code>不能写只能读（如果对<code>slave</code>执行写操作，那么<code>show slave status</code>将会呈现<code>Slave_SQL_Running=NO</code>，此时你需要按照前面提到的手动同步一下<code>slave</code>）。</p>
<p><strong>方案一</strong></p>
<p>使用mysql-proxy代理</p>
<p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p>
<p>缺点：降低性能， 不支持事务</p>
<p><strong>方案二</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br />
如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p>
<p><strong>方案三</strong></p>
<p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p>
<p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p>
<h3 id="备份计划mysqldump以及xtranbackup的实现原理"><a class="markdownIt-Anchor" href="#备份计划mysqldump以及xtranbackup的实现原理"></a> 备份计划，mysqldump以及xtranbackup的实现原理</h3>
<p><strong>(1)备份计划</strong></p>
<p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p>
<p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p>
<p><strong>(2)备份恢复时间</strong></p>
<p>物理备份恢复快，逻辑备份恢复慢</p>
<p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p>
<p>20G的2分钟（mysqldump）</p>
<p>80G的30分钟(mysqldump)</p>
<p>111G的30分钟（mysqldump)</p>
<p>288G的3小时（xtra)</p>
<p>3T的4小时（xtra)</p>
<p>逻辑导入时间一般是备份时间的5倍以上</p>
<p><strong>(3)备份恢复失败如何处理</strong></p>
<p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p>
<p><strong>(4)mysqldump和xtrabackup实现原理</strong></p>
<p>mysqldump</p>
<p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>
<p>Xtrabackup:</p>
<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p>
<p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p>
<p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p>
<h3 id="数据表损坏的修复方式有哪些"><a class="markdownIt-Anchor" href="#数据表损坏的修复方式有哪些"></a> 数据表损坏的修复方式有哪些？</h3>
<p>使用 myisamchk 来修复，具体步骤：</p>
<ul>
<li>1）修复前将mysql服务停止。</li>
<li>2）打开命令行方式，然后进入到mysql的/bin目录。</li>
<li>3）执行myisamchk –recover 数据库所在路径/*.MYI</li>
</ul>
<p>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数值的整数次方</title>
    <url>/2021/07/24/%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="数值的整数次方"><a class="markdownIt-Anchor" href="#数值的整数次方"></a> 数值的整数次方</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p>
<p><strong>快速幂解析</strong></p>
<blockquote>
<p>快速幂是二分思想的一种应用。</p>
</blockquote>
<p>根据二分推导，可通过循环x=x^2操作，每次将幂n降至n/2，直至将幂降为0。</p>
<p>设res=1，则初始状态x<sup>n=x</sup>n<em>res，在循环二分时，当n为奇数，将多出的一项乘以res，偶数则不用处理，最终x^n=1</em>res。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> b=n;  <span class="comment">//由于int范围n∈[−2147483648,2147483647] ，因此当 n = -2147483648时执行 n = -nn=−n 会因越界而赋值出错。解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            x=<span class="number">1</span>/x;</span><br><span class="line">            b=-b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b&amp;<span class="number">1</span>==<span class="number">1</span>)&#123;  <span class="comment">// b%2==1?</span></span><br><span class="line">                res*=x;</span><br><span class="line">            &#125; </span><br><span class="line">            x*=x;  <span class="comment">// x=x^2</span></span><br><span class="line">            b&gt;&gt;=<span class="number">1</span>;  <span class="comment">//b=b/2;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索二维矩阵</title>
    <url>/2021/07/24/%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="搜索二维矩阵"><a class="markdownIt-Anchor" href="#搜索二维矩阵"></a> 搜索二维矩阵</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br />
每列的元素从上到下升序排列。<br />
示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现有矩阵 matrix 如下：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line"></span><br><span class="line">给定 target = 20，返回 false。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>由于矩阵从上到下、从左到右是排序的，我们从左下角元素开始，如果比target小，则往右走；如果比target大，则往上走。如果target存在，则一定能找到。若是在矩阵范围内，没找到，说明不存在target，返回false。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row=matrix.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> col=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(row&gt;=<span class="number">0</span>&amp;&amp;col&lt;matrix[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col]&lt;target)&#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[row][col]&gt;target)&#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>把二叉搜索树转换为累加树</title>
    <url>/2021/07/24/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</url>
    <content><![CDATA[<h1 id="把二叉搜索树转换为累加树"><a class="markdownIt-Anchor" href="#把二叉搜索树转换为累加树"></a> 把二叉搜索树转换为累加树</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">              5</span><br><span class="line">            /   \</span><br><span class="line">           2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">             18</span><br><span class="line">            /   \</span><br><span class="line">          20     13</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="逆中序遍历法"><a class="markdownIt-Anchor" href="#逆中序遍历法"></a> 逆中序遍历法</h2>
<p>由于二叉搜索树的特性，左结点&lt;根结点&lt;右结点。因此可以递归右子树，递归回来的值与当前结点值求和得到当前结点值，然后递归左子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            convertBST(root.right);</span><br><span class="line">            sum+=root.val;</span><br><span class="line">            root.val=sum;</span><br><span class="line">            convertBST(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于栈的方法"><a class="markdownIt-Anchor" href="#基于栈的方法"></a> 基于栈的方法</h2>
<p>一个描述迭代栈的方法就是通过递归的思想。首先我们初始化一个空的栈并把根节点作为当前节点。然后只要在栈中有未遍历节点或者 node 节点不为空，我们就将当前节点到最右边叶子路径上的点全部压入栈中。这与递归过程中我们总是先走右子树的思路是一致的，这个思路确保我们总是降序遍历所有节点的值。接下来，我们访问栈顶节点，并考虑它的左子树，这就像我们递归中先遍历当前节点再遍历它的左子树的思路。最后，我们的栈为空并且 node 指向树中最小节点的左孩子 null ，循环结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum==<span class="number">0</span>;</span><br><span class="line">        TreeNode node=<span class="keyword">new</span> TreeNode();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()||node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root=root.right;</span><br><span class="line">            &#125;</span><br><span class="line">            node=stack.pop();</span><br><span class="line">            sum+=node.val;</span><br><span class="line">            node.val=sum;</span><br><span class="line">            </span><br><span class="line">            node=node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>打开转盘锁</title>
    <url>/2021/07/24/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</url>
    <content><![CDATA[<h1 id="打开转盘锁"><a class="markdownIt-Anchor" href="#打开转盘锁"></a> 打开转盘锁</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'</code> 。每个拨轮可以自由旋转：例如把 <code>'9'</code> 变为 <code>'0'</code>，<code>'0'</code> 变为 <code>'9'</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p>
<p>锁的初始数字为 <code>'0000'</code> ，一个代表四个拨轮的数字的字符串。</p>
<p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p>
<p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: deadends = [&quot;8888&quot;], target = &quot;0009&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>⽐如说从 “0000” 开始，转⼀次，可以穷举出 “1000”, “9000”, “0100”, “0900”… 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转 ⼀下，穷举出所有可能… 仔细想想，这就可以抽象成***⼀*<strong>幅图，每个节点有</strong> <strong>8</strong> <strong>个相邻的节点</strong>，⼜让你求 最短距离，这不就是典型的 BFS 嘛.</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Echo.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">open</span><span class="params">(String[] deadens,String target)</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录死亡密码deadens到一个HashSet。</span></span><br><span class="line">        Set&lt;String&gt; dead=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s:deadens)&#123;</span><br><span class="line">            dead.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录已访问，防止走回头路。</span></span><br><span class="line">        Set&lt;String&gt; visited=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//bfs遍历</span></span><br><span class="line">        Queue&lt;String&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        visited.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size= queue.size();</span><br><span class="line">            <span class="comment">//将当前队列中的所有节点向周围扩散</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">                String cur= queue.poll();</span><br><span class="line">                <span class="comment">//判断是否到达终点</span></span><br><span class="line">                <span class="keyword">if</span>(dead.contains(cur))&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.equals(target))&#123;</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将当前结点的所有邻接结点入队。</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">                    String up=plusOne(cur,j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(up))&#123;</span><br><span class="line">                        queue.offer(up);</span><br><span class="line">                        visited.add(up);</span><br><span class="line">                    &#125;</span><br><span class="line">                    String down=miniOne(cur,j);</span><br><span class="line">                    <span class="keyword">if</span>(!visited.contains(down))&#123;</span><br><span class="line">                        queue.offer(down);</span><br><span class="line">                        visited.add(down);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对每个字符s的第j位可以往上或往下拨。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">plusOne</span><span class="params">(String s,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars=s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(chars[j]==<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            chars[j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chars[j]+=<span class="number">1</span>;<span class="comment">//数字字符可直接算术运算。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);<span class="comment">//char数组直接转String。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">miniOne</span><span class="params">(String s,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars=s.toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(chars[j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            chars[j]=<span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            chars[j]-=<span class="number">1</span>;<span class="comment">//数字字符可直接算术运算。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);<span class="comment">//char数组直接转String。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍Ⅱ</title>
    <url>/2021/07/24/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E2%85%A1/</url>
    <content><![CDATA[<h1 id="打家劫舍ii"><a class="markdownIt-Anchor" href="#打家劫舍ii"></a> 打家劫舍Ⅱ</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<h2 id="思路实现"><a class="markdownIt-Anchor" href="#思路实现"></a> 思路实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">//处理环形情况</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, n - <span class="number">2</span>), rob(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通一排的打家劫舍</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre2 = <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = Math.max(pre1, pre2 + nums[i]);</span><br><span class="line">        pre2 = pre1;</span><br><span class="line">        pre1 = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>打印从1到最大的n位数</title>
    <url>/2021/07/24/%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="打印从1到最大的n位数"><a class="markdownIt-Anchor" href="#打印从1到最大的n位数"></a> 打印从1到最大的n位数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入数字 <code>n</code>，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<p><strong>简易解法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> len=(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,n)-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] nums=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            nums[i]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>考虑大数越界</strong></p>
<p>当 n 较大时，结果会超出 int32 整型的取值范围，超出取值范围的数字无法正常存储。应该存储为字符串进行输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    StringBuilder res;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, n;</span><br><span class="line">    <span class="keyword">char</span>[] num, loop = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        res = <span class="keyword">new</span> StringBuilder(); <span class="comment">// 数字字符串集</span></span><br><span class="line">        num = <span class="keyword">new</span> <span class="keyword">char</span>[n]; <span class="comment">// 定义长度为 n 的字符列表</span></span><br><span class="line">        dfs(<span class="number">0</span>); <span class="comment">// 开启全排列递归</span></span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>); <span class="comment">// 删除最后多余的逗号</span></span><br><span class="line">        <span class="keyword">return</span> res.toString(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == n) &#123; <span class="comment">// 终止条件：已固定完所有位</span></span><br><span class="line">            res.append(String.valueOf(num) + <span class="string">&quot;,&quot;</span>); <span class="comment">// 拼接 num 并添加至 res 尾部，使用逗号隔开</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> i : loop) &#123; <span class="comment">// 遍历 ‘0‘ - ’9‘</span></span><br><span class="line">            num[x] = i; <span class="comment">// 固定第 x 位为 i</span></span><br><span class="line">            dfs(x + <span class="number">1</span>); <span class="comment">// 开启固定第 x + 1 位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>平方数之和</title>
    <url>/2021/07/24/%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="平方数之和"><a class="markdownIt-Anchor" href="#平方数之和"></a> 平方数之和</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>题目描述：判断一个非负整数是否为两个整数的平方和。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*双指针遍历法</span></span><br><span class="line"><span class="comment">*设两个整数为a，b，非负整数c。显然a，b在区间[0,sqrt(c)]内，因此可用双指针逼近进行判断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(c&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=(<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=i*i+j*j;</span><br><span class="line">        <span class="keyword">if</span>(sum==c) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;c) j--;</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*解法二*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> a=<span class="number">0</span>;a*a&lt;=c;a++)&#123;</span><br><span class="line">        <span class="keyword">double</span> b=Math.sqrt(c-a*a);</span><br><span class="line">        <span class="keyword">if</span>(b==(<span class="keyword">int</span>)b)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿的最大面积</title>
    <url>/2021/07/24/%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h1 id="岛屿的最大面积"><a class="markdownIt-Anchor" href="#岛屿的最大面积"></a> 岛屿的最大面积</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p>
<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p>
<h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2>
<p>DFS</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    res=Math.max(res,dfs(grid,i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=grid.length||j&lt;<span class="number">0</span>||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line">        num+=dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">        num+=dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        num+=dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        num+=dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找重复数</title>
    <url>/2021/07/24/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="寻找重复数"><a class="markdownIt-Anchor" href="#寻找重复数"></a> 寻找重复数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h2 id="常规思路"><a class="markdownIt-Anchor" href="#常规思路"></a> 常规思路</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">publiic <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原地寻找"><a class="markdownIt-Anchor" href="#原地寻找"></a> 原地寻找</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以数组元素的值作为索引，若出现相同索引，则必定是重复值。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == i) &#123;<span class="comment">//当前值与索引相同，跳过</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums[i]] == nums[i]) <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[i];<span class="comment">//若不等，交换至索引位置。</span></span><br><span class="line">            nums[i] = nums[tmp];</span><br><span class="line">            nums[tmp] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//若没找到，返回-1。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表"></a> 哈希表</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">publiic <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    HashSet&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(set.contains(num))&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">publiic <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>, high = nums.length - <span class="number">1</span> <span class="comment">// 数组项的范围 1 到 n</span></span><br><span class="line">  <span class="keyword">while</span> (low &lt; high) &#123; <span class="comment">// 在循环中缩小区间，区间闭合循环结束</span></span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) &gt;&gt; <span class="number">1</span> <span class="comment">// 求中位数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nums[i] &lt;= mid) count++ <span class="comment">// 统计小于等于mid的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; mid) &#123; <span class="comment">// 重复数落在 [1,mid]</span></span><br><span class="line">      high = mid       <span class="comment">// 区间收缩</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;           <span class="comment">// 落在 [mid+1,n]</span></span><br><span class="line">      low = mid + <span class="number">1</span>    <span class="comment">// 区间收缩</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快慢指针"><a class="markdownIt-Anchor" href="#快慢指针"></a> 快慢指针</h2>
<p>比如，nums 数组：[4, 3, 1, 2, 2][4,3,1,2,2]<br />
如果以 nums[0] 的值 4 作为索引，去到 nums[4]<br />
如果以 nums[4] 的值 2 作为索引，去到 nums[2]<br />
如果以 nums[2] 的值 1 作为索引，去到 nums[1]……<br />
从一项到另一项，有了指向性的联系，有点像“单向链表”<br />
形成一条链表：4 &gt; 2 &gt; 1 &gt; 3 &gt; 2 ，可见链表又指回了 2 ，“链表有环”</p>
<p><img src="https://pic.leetcode-cn.com/a393fd88e07b576de4d603fcccd47539e6648273a7f6626760b95ec28d2343b7-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200526201809.png" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> slow = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">    <span class="comment">//寻找相遇点</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[nums[fast]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//slow 从起点出发, fast 从相遇点出发, 一次走一步</span></span><br><span class="line">    slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow];</span><br><span class="line">        fast = nums[fast];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找数组中第k大的元素</title>
    <url>/2021/07/24/%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E7%AC%ACk%E5%A4%A7%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="寻找数组中第k大的元素"><a class="markdownIt-Anchor" href="#寻找数组中第k大的元素"></a> 寻找数组中第k大的元素</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>寻找数组中第k大的元素。</p>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<p><strong>思路一</strong>：先排序，然后直接获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKLargeElements</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路二</strong>：通过维持一个大堆顶，堆顶元素就是第k大的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKLargeElements</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; pq=<span class="keyword">new</span> PriorityQueue&lt;&gt;();<span class="comment">//默认实现一个小顶堆。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        pq.add(num);</span><br><span class="line">        <span class="keyword">if</span>(pq.size()&gt;k)&#123;</span><br><span class="line">            pq.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路三</strong>：快速选择排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    Random random=<span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKLargeElements</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quicksort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,nums.length-k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> q=randomPartition(nums,l,r);</span><br><span class="line">        <span class="keyword">if</span>(q==index)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[q];</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> q&lt;index? quicksort(nums,q+<span class="number">1</span>,r,index):quicksort(nums,l,q-<span class="number">1</span>,index);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomPartition</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = random.nextInt(r - l + <span class="number">1</span>) + l;</span><br><span class="line">        swap(a, i, r);</span><br><span class="line">        <span class="keyword">return</span> partition(a, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = a[r], i = l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt; r; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt;= x) &#123;</span><br><span class="line">                swap(a, ++i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i + <span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/2021/07/24/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<h1 id="完全平方数"><a class="markdownIt-Anchor" href="#完全平方数"></a> 完全平方数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 12</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 12 = 4 + 4 + 4.</span><br></pre></td></tr></table></figure>
<h2 id="常规思路"><a class="markdownIt-Anchor" href="#常规思路"></a> 常规思路</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numSquaresHelper(n, <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">numSquaresHelper</span><span class="params">(<span class="keyword">int</span> n, HashMap&lt;Integer, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (map.containsKey(n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        count = Math.min(count, numSquaresHelper(n - i * i, map) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(n, count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//依次求出 1, 2... 直到 n 的解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">//依次减去一个平方数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">            dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BFS</strong></p>
<p>BFS 的话，我们可以一层一层的算。第一层依次减去一个平方数得到第二层，第二层依次减去一个平方数得到第三层。直到某一层出现了 0，此时的层数就是我们要找到平方数和的最小个数。</p>
<p>举个例子，n = 12，每层的话每个节点依次减 1, 4, 9…。如下图，灰色表示当前层重复的节点，不需要处理。</p>
<p><img src="https://pic.leetcode-cn.com/641036134c746b8bba3be26299a9cbd8493950dba92edcf50408031903c4f37c.jpg" alt="" /></p>
<p>如上图，当出现 0 的时候遍历就可以停止，此时是第 3 层（从 0 计数），所以最终答案就是 3。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSqure</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">    queue.add(n);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size=queue.size();</span><br><span class="line">        level++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur=queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j*j&lt;=n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> next=n-j*j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(next))&#123;</span><br><span class="line">                queue.offer(next);</span><br><span class="line">                set.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的排列</title>
    <url>/2021/07/24/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="字符串的排列"><a class="markdownIt-Anchor" href="#字符串的排列"></a> 字符串的排列</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定两个字符串 <strong>s1</strong> 和 <strong>s2</strong>，写一个函数来判断 <strong>s2</strong> 是否包含 <strong>s1</strong> 的排列。</p>
<p>换句话说，第一个字符串的排列之一是第二个字符串的子串。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出: True</span><br><span class="line">解释: s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br></pre></td></tr></table></figure>
<h2 id="算法思路"><a class="markdownIt-Anchor" href="#算法思路"></a> 算法思路</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkInclusion</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        s1=sort(s1);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=s2.length()-s1.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.equals(sort(s2.substring(i,i+s1.length()))))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sort</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] t=s.toCharArray();</span><br><span class="line">        Arrays.sort(t);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>太平洋大西洋水流</title>
    <url>/2021/07/24/%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81/</url>
    <content><![CDATA[<h1 id="太平洋大西洋水流"><a class="markdownIt-Anchor" href="#太平洋大西洋水流"></a> 太平洋大西洋水流</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p>
<p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p>
<p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定下面的 5x5 矩阵:</span><br><span class="line"></span><br><span class="line">  太平洋 ~   ~   ~   ~   ~ </span><br><span class="line">       ~  1   2   2   3  (5) *</span><br><span class="line">       ~  3   2   3  (4) (4) *</span><br><span class="line">       ~  2   4  (5)  3   1  *</span><br><span class="line">       ~ (6) (7)  1   4   5  *</span><br><span class="line">       ~ (5)  1   1   2   4  *</span><br><span class="line">          *   *   *   *   * 大西洋</span><br><span class="line"></span><br><span class="line">返回:</span><br><span class="line"></span><br><span class="line">[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>思路是从海洋开始逆流 如果可以逆流到 就标记为1 然后检查两个海洋都可以逆流到的区域。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAndAtlantic(<span class="keyword">int</span>[][] matrix)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] pacific=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span>[][] atlantic=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                    dfs(matrix,pacific,i,j,matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(i==m-<span class="number">1</span>||j==n-<span class="number">1</span>)&#123;</span><br><span class="line">                    dfs(matrix,atlantic,i,j,matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pacific[i][j]==<span class="number">1</span>&amp;&amp;atlantic[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    res.add(Arrays.asList(i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span>[][] ocean,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=matrix.length || j&lt;<span class="number">0</span> || j&gt;=matrix[<span class="number">0</span>].length || ocean[i][j]==<span class="number">1</span> || matrix[i][j]&lt;pre)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ocean[i][j]=<span class="number">1</span>;</span><br><span class="line">        dfs(matrix, ocean, i - <span class="number">1</span>, j, matrix[i][j]);</span><br><span class="line">        dfs(matrix, ocean, i + <span class="number">1</span>, j, matrix[i][j]);</span><br><span class="line">        dfs(matrix, ocean, i, j - <span class="number">1</span>, matrix[i][j]);</span><br><span class="line">        dfs(matrix, ocean, i, j + <span class="number">1</span>, matrix[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>在线笔试输入输出处理</title>
    <url>/2021/07/24/%E5%9C%A8%E7%BA%BF%E7%AC%94%E8%AF%95%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="在线笔试输入输出处理"><a class="markdownIt-Anchor" href="#在线笔试输入输出处理"></a> 在线笔试输入输出处理</h1>
<h2 id="1-简单字符串及数组输入"><a class="markdownIt-Anchor" href="#1-简单字符串及数组输入"></a> 1、简单字符串及数组输入</h2>
<h3 id="1-输入字符串"><a class="markdownIt-Anchor" href="#1-输入字符串"></a> 1、输入字符串</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//next()方法在读取内容时，会过滤掉有效字符前面的无效字符，对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，next()方法会自动将其过滤掉；只有在读取到有效字符之后，next()方法才将其后的空格键、Tab键或Enter键等视为结束符；所以next()方法不能得到带空格的字符串。</span></span><br><span class="line">        String str=in.next();</span><br><span class="line">       <span class="comment">// nextLine()方法字面上有扫描一整行的意思，它的结束符只能是Enter键，即nextLine()方法返回的是Enter键之前没有被读取的所有字符，它是可以得到带空格的字符串的。</span></span><br><span class="line">        String str1=in.nextLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-输入一维和二维数组"><a class="markdownIt-Anchor" href="#2-输入一维和二维数组"></a> 2、输入一维和二维数组</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//输入一维数组</span></span><br><span class="line">        <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] onearray=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            onearray[i]=in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输入二维数组</span></span><br><span class="line">        <span class="keyword">int</span> m=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[][] grid=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                grid[i][j]=in.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多行输入输出处理"><a class="markdownIt-Anchor" href="#多行输入输出处理"></a> 多行输入输出处理</h2>
<h3 id="1-数字多行输入输出"><a class="markdownIt-Anchor" href="#1-数字多行输入输出"></a> 1、数字多行输入输出</h3>
<p>输入包括两个正整数a,b(1 &lt;= a, b &lt;= 10^9),输入数据包括多组。输出为a+b的结果</p>
<p>示例：</p>
<blockquote>
<p>输入：</p>
<p>1    5<br />
10    20</p>
<p>输出：</p>
<p>6<br />
30</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeInput</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//1.多行输入a，b，求和。</span></span><br><span class="line">        <span class="keyword">while</span> (in.hasNextLine())&#123;</span><br><span class="line">            String[] row=in.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row.length;i++)&#123;</span><br><span class="line">                System.out.println(Integer.parseInt(row[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.已知行数，对每行a，b求和。</span></span><br><span class="line">        <span class="keyword">int</span> rowNum=in.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rowNum;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a=in.nextInt();</span><br><span class="line">            <span class="keyword">int</span> b=in.nextInt();</span><br><span class="line">            System.out.println(a+b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.对每行输入a，b求和，当遇到0，0行结束输入。</span></span><br><span class="line">        <span class="keyword">while</span> (in.hasNextLine())&#123;</span><br><span class="line">            String[] row=in.nextLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(row[<span class="number">0</span>].equals(<span class="string">&quot;0&quot;</span>)&amp;&amp;row[<span class="number">1</span>].equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(Integer.parseInt(row[<span class="number">0</span>])+Integer.parseInt(row[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.对每行输入数据求和，当某行为0结束输入。</span></span><br><span class="line">        <span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">            String s = in.nextLine();</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;0&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] arr = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> len = Integer.parseInt(arr[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                sum += Integer.parseInt(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// Integer.parseInt()和Integer.valueOf()都可以返回int值，但parseInt()返回的是基本类型int,而valueOf()返回的是包装类Integer。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-字符串多行输入输出"><a class="markdownIt-Anchor" href="#2-字符串多行输入输出"></a> 2、字符串多行输入输出</h3>
<p>对于每组用例输出一行排序后的字符串，用’,'隔开，无结尾空格</p>
<p>示例：</p>
<blockquote>
<p>输入</p>
<p>a,c,bb<br />
f,dddd<br />
nowcoder</p>
<p>输出：</p>
<p>a,bb,c<br />
dddd,f<br />
nowcoder</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(in.hasNextLine())&#123;</span><br><span class="line">            String[] str=in.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            Arrays.sort(str);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=str.length-<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.print(str[i]+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    System.out.print(str[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>offer之路</category>
      </categories>
  </entry>
  <entry>
    <title>在B不在A的数</title>
    <url>/2021/07/24/%E5%9C%A8B%E4%B8%8D%E5%9C%A8A%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="在b不在a的数"><a class="markdownIt-Anchor" href="#在b不在a的数"></a> 在B不在A的数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>一个有序数组 A，另一个无序数组 B，请打印在数组 B 中而不在数组 A 中的数。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>可遍历B中元素，然后在A中二分查找是否有相同元素存在，若存在则跳过，不存在则加入一个可变列表list。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getElementsInAnotB</span><span class="params">(<span class="keyword">int</span>[] A,<span class="keyword">int</span>[] B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;B.length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left=<span class="number">0</span>,right=A.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> contains=<span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)<span class="comment">//当左右索引元素重叠，还没有找到，即没有</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(B[i]==A[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    contains=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(B[i]&gt;A[mid])</span><br><span class="line">                &#123;</span><br><span class="line">                    left=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    right=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!contains)</span><br><span class="line">            &#123;</span><br><span class="line">                list.add(B[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表</title>
    <url>/2021/07/24/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="回文链表"><a class="markdownIt-Anchor" href="#回文链表"></a> 回文链表</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>请判断一个链表是否为回文链表。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<h2 id="将链表存入数组然后双指针判断"><a class="markdownIt-Anchor" href="#将链表存入数组然后双指针判断"></a> 将链表存入数组然后双指针判断</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode node1=head;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(node1!=<span class="keyword">null</span>)&#123;<span class="comment">//获取链表长度</span></span><br><span class="line">            len++;</span><br><span class="line">            node1=node1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode node=head;node!=<span class="keyword">null</span>;node=node.next)&#123;<span class="comment">//将链表元素存入数组</span></span><br><span class="line">            array[k++]=node.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,j=len-<span class="number">1</span>;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[i]!=array[j]) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//每一对都相等才是回文</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表上反转一半元素进行比较"><a class="markdownIt-Anchor" href="#链表上反转一半元素进行比较"></a> 链表上反转一半元素进行比较</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = head, prepre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            pre.next = prepre;</span><br><span class="line">            prepre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;<span class="comment">//slow指向下半部分头结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pre != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.val != slow.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>回文子串</title>
    <url>/2021/07/24/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="回文子串"><a class="markdownIt-Anchor" href="#回文子串"></a> 回文子串</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>
<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;abc&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.</span><br></pre></td></tr></table></figure>
<h2 id="动态规划法"><a class="markdownIt-Anchor" href="#动态规划法"></a> 动态规划法</h2>
<p>状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。<br />
状态转移方程：当 s[i] == s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]=true，否则为false。</p>
<p>1、当只有一个字符时，比如a自然是一个回文串。<br />
2、当有两个字符时，如果是相等的，比如aa，也是一个回文串。<br />
3、当有三个及以上字符时，比如ababa这个字符记作串1，把两边的a去掉，也就是bab记作串2，可以看出只要串2是一个回文串，那么左右各多了一个a的串1必定也是回文串。所以当s[i]==s[j]时，自然要看dp[i+1][j-1]是不是一个回文串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubString</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=j;i++)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(s.charAt(i)==s.charAt(j)&amp;&amp;(j-i&lt;<span class="number">2</span>||dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                     dp[i][j]=<span class="keyword">true</span>;</span><br><span class="line">                     res++;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中心扩展法"><a class="markdownIt-Anchor" href="#中心扩展法"></a> 中心扩展法</h2>
<p>比如对一个字符串ababa，选择最中间的a作为中心点，往两边扩散，第一次扩散发现left指向的是b，right指向的也是b，所以是回文串，继续扩散，同理ababa也是回文串。</p>
<p>这个是确定了一个中心点后的寻找的路径，然后我们只要寻找到所有的中心点，问题就解决了。</p>
<p>中心点一共有多少个呢？看起来像是和字符串长度相等，但你会发现，如果是这样，上面的例子永远也搜不到abab，想象一下单个字符的哪个中心点扩展可以得到这个子串？似乎不可能。所以中心点不能只有单个字符构成，还要包括两个字符，比如上面这个子串abab，就可以有中心点ba扩展一次得到，<strong>所以最终的中心点由2 * len - 1个，分别是len个单字符和len - 1个双字符。</strong></p>
<p>如果上面看不太懂的话，还可以看看下面几个问题：</p>
<p>为什么有 2 * len - 1 个中心点？<br />
aba 有5个中心点，分别是 a、b、a、ab、ba<br />
abba 有7个中心点，分别是 a、b、b、a、ab、bb、ba<br />
什么是中心点？<br />
<strong>中心点即left指针和right指针初始化指向的地方，可能是一个也可能是两个</strong><br />
为什么不可能是三个或者更多？<br />
因为3个可以由1个扩展一次得到，4个可以由两个扩展一次得到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution6472</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 中心扩展法</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> center = <span class="number">0</span>; center &lt; <span class="number">2</span> * s.length() - <span class="number">1</span>; center++) &#123;</span><br><span class="line">            <span class="comment">// left和right指针和中心点的关系是？</span></span><br><span class="line">            <span class="comment">// 首先是left，有一个很明显的2倍关系的存在，其次是right，可能和left指向同一个（偶数时），也可能往后移动一个（奇数）</span></span><br><span class="line">            <span class="comment">// 大致的关系出来了，可以选择带两个特殊例子进去看看是否满足。</span></span><br><span class="line">            <span class="keyword">int</span> left = center / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> right = left + center % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个排序的数组</title>
    <url>/2021/07/24/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="合并两个排序的数组"><a class="markdownIt-Anchor" href="#合并两个排序的数组"></a> 合并两个排序的数组</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给你两个有序整数数组 <em>nums1</em> 和 <em>nums2</em>，请你将 <em>nums2</em> 合并到 <em>nums1</em> 中*，*使 <em>nums1</em> 成为一个有序数组。</p>
<p>说明:</p>
<p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。<br />
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<p>可使用双指针比较，由于需要合并到nums1，故需要从尾开始比较，这样不会导致覆盖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=m-<span class="number">1</span>,j=n-<span class="number">1</span>,k=m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i]&gt;nums2[j])&#123;</span><br><span class="line">                nums1[k--]=nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums1[k--]=nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[k--]=nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            nums1[k--]=nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中的元音字母</title>
    <url>/2021/07/24/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</url>
    <content><![CDATA[<h1 id="反转字符串中的元音字母"><a class="markdownIt-Anchor" href="#反转字符串中的元音字母"></a> 反转字符串中的元音字母</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;hello&quot;</span><br><span class="line">输出：&quot;holle&quot;</span><br><span class="line">https://github.com/Zhi-Tu/My-Album/blob/master/photos/leetcode.png</span><br><span class="line">https://github.com/Zhi-Tu/My-Album/blob/master/photos/const.png</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>可将元音字母存入一个HashSet，双指针首尾遍历字符串，遇到元音字母则交换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HashSet&lt;Character&gt; vowels = <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">        Arrays.asList(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;U&#x27;</span>));</span><br><span class="line"><span class="comment">//Arrays.asList(num)将num数组转换为list。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;<span class="comment">//必须要有等号，不然奇数个字符中间那个没有统计到。</span></span><br><span class="line">        <span class="keyword">char</span> ci = s.charAt(i);</span><br><span class="line">        <span class="keyword">char</span> cj = s.charAt(j);</span><br><span class="line">        <span class="keyword">if</span> (!vowels.contains(ci)) &#123;</span><br><span class="line">            result[i++] = ci;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!vowels.contains(cj)) &#123;</span><br><span class="line">            result[j--] = cj;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[i++] = cj;<span class="comment">//巧妙实现了交换。</span></span><br><span class="line">            result[j--] = ci;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>单词接龙</title>
    <url>/2021/07/24/%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
    <content><![CDATA[<h1 id="单词接龙"><a class="markdownIt-Anchor" href="#单词接龙"></a> 单词接龙</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p>
<p>每次转换只能改变一个字母。<br />
转换过程中的中间单词必须是字典中的单词。<br />
说明:</p>
<p>如果不存在这样的转换序列，返回 0。<br />
所有单词具有相同的长度。<br />
所有单词只由小写字母组成。<br />
字典中不存在重复的单词。<br />
你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>根据题意分析：已知开头和结尾词，从词集中找到类似词（具有两个相同字母）进行接龙。</p>
<p>1、如果词集中没有尾词，则直接返回0。</p>
<p>2、层序遍历。将首词加入队列，判断词集中是否有可以与之接龙的词。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!wordList.contains(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//访问过的不能再次使用，故设置visited数组。</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[wordList.size()];</span><br><span class="line">        <span class="keyword">int</span> idx=wordList.indexOf(beginWord);</span><br><span class="line">        <span class="keyword">if</span>(idx!=-<span class="number">1</span>)&#123;</span><br><span class="line">            visited[idx]=<span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//层序遍历</span></span><br><span class="line">        Queue&lt;String&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;<span class="comment">//此判断条件很必要。</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">int</span> size=queue.size();</span><br><span class="line">            <span class="keyword">while</span>(size--&gt;<span class="number">0</span>)&#123;<span class="comment">//每层的遍历</span></span><br><span class="line">                String s1=queue.poll();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.size();i++)&#123;</span><br><span class="line">                    String s2=wordList.get(i);</span><br><span class="line">                    <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(!canConvert(s1,s2))&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(s2.equals(endWord))&#123;</span><br><span class="line">                        <span class="keyword">return</span> count+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    visited[i]=<span class="keyword">true</span>;</span><br><span class="line">                    queue.offer(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(String s1,String s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s2.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i)!=s2.charAt(i))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化：上述方法符合一般流程但效率过低，考虑使用首尾BFS并优化比较过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> end = wordList.indexOf(endWord);</span><br><span class="line">        <span class="keyword">if</span> (end == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordList.add(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从两端BFS遍历要用的队列</span></span><br><span class="line">        Queue&lt;String&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 两端已经遍历过的节点</span></span><br><span class="line">        Set&lt;String&gt; visited1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; visited2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        queue1.offer(beginWord);</span><br><span class="line">        queue2.offer(endWord);</span><br><span class="line">        visited1.add(beginWord);</span><br><span class="line">        visited2.add(endWord);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; allWordSet = <span class="keyword">new</span> HashSet&lt;&gt;(wordList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty() &amp;&amp; !queue2.isEmpty()) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (queue1.size() &gt; queue2.size()) &#123;</span><br><span class="line">                Queue&lt;String&gt; tmp = queue1;</span><br><span class="line">                queue1 = queue2;</span><br><span class="line">                queue2 = tmp;</span><br><span class="line">                Set&lt;String&gt; t = visited1;</span><br><span class="line">                visited1 = visited2;</span><br><span class="line">                visited2 = t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> size1 = queue1.size();</span><br><span class="line">            <span class="keyword">while</span> (size1-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String s = queue1.poll();</span><br><span class="line">                <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s.length(); ++j) &#123;</span><br><span class="line">                    <span class="comment">// 保存第j位的原始字符</span></span><br><span class="line">                    <span class="keyword">char</span> c0 = chars[j];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; ++c) &#123;</span><br><span class="line">                        chars[j] = c;</span><br><span class="line">                        String newString = <span class="keyword">new</span> String(chars);</span><br><span class="line">                        <span class="comment">// 已经访问过了，跳过</span></span><br><span class="line">                        <span class="keyword">if</span> (visited1.contains(newString)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 两端遍历相遇，结束遍历，返回count</span></span><br><span class="line">                        <span class="keyword">if</span> (visited2.contains(newString)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> count + <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 如果单词在列表中存在，将其添加到队列，并标记为已访问</span></span><br><span class="line">                        <span class="keyword">if</span> (allWordSet.contains(newString)) &#123;</span><br><span class="line">                            queue1.offer(newString);</span><br><span class="line">                            visited1.add(newString);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 恢复第j位的原始字符</span></span><br><span class="line">                    chars[j] = c0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和与差分数组</title>
    <url>/2021/07/24/%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="前缀和与差分数组"><a class="markdownIt-Anchor" href="#前缀和与差分数组"></a> 前缀和与差分数组</h1>
<h2 id="前缀和问题"><a class="markdownIt-Anchor" href="#前缀和问题"></a> 前缀和问题</h2>
<p>示例：对于一个给定的数组，寻找和为k的连续子数组。</p>
<p><strong>思路实现：</strong></p>
<p>对每个元素构建一个前缀和数组，然后遍历该数组所有可能的子数组判断和是否为k。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrefixSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subArray(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)&#123;</span><br><span class="line">        <span class="comment">//构建前缀和数组sum，长度为nums长度加1</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] sum=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>]=sum[i]+nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sum[i]-sum[j]==k)&#123;</span><br><span class="line">                    List&lt;Integer&gt; str=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> s=j;s&lt;i;s++)&#123;</span><br><span class="line">                        str.add(nums[s]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    res.add(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;-<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,-<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">2</span>;</span><br><span class="line">        PrefixSum prefixSum=<span class="keyword">new</span> PrefixSum();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result=prefixSum.subArray(nums,k);</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; c:result)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="差分数组"><a class="markdownIt-Anchor" href="#差分数组"></a> 差分数组</h2>
<p><strong>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减</strong>。</p>
<p>示例：</p>
<p>比如说，我给你输入一个数组<code>nums</code>，然后又要求给区间<code>nums[2..6]</code>全部加 1，再给<code>nums[3..9]</code>全部减 3，再给<code>nums[0..4]</code>全部加 2，再给…，然后问你，最后<code>nums</code>数组的值是什么？</p>
<p><strong>思路分析</strong></p>
<p>构建差分数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[diff.length];</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>前k个高频元素</title>
    <url>/2021/07/24/%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="前k个高频元素"><a class="markdownIt-Anchor" href="#前k个高频元素"></a> 前k个高频元素</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个非空的整数数组，返回其中出现频率前 <strong>k</strong> 个高频元素。</p>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<p>先使用哈希表统计元素及其出现频率，然后基于桶排序的思想获得频率排序，最后遍历得到前k个高频元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrequentKElements</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">topKFrequent</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!map.containsKey(num))&#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//桶排序</span></span><br><span class="line">        <span class="comment">//将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标</span></span><br><span class="line">        List&lt;Integer&gt;[] list=<span class="keyword">new</span> List[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">int</span> i=map.get(key);<span class="comment">//获取键对应的值</span></span><br><span class="line">            <span class="keyword">if</span>(list[i]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                list[i]=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            list[i].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 倒序遍历list数组获取出现顺序从大到小的排列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=list.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>&amp;&amp;res.size()&lt;k;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list[i]==<span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res.addAll(list[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        FrequentKElements frequentKElements=<span class="keyword">new</span> FrequentKElements();</span><br><span class="line">        System.out.println(frequentKElements.topKFrequent(nums,<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>判断子序列</title>
    <url>/2021/07/24/%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="判断子序列"><a class="markdownIt-Anchor" href="#判断子序列"></a> 判断子序列</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</p>
<p>你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 &lt;=100）。</p>
<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（<strong>例如，&quot;ace&quot;是&quot;abcde&quot;的一个子序列，而&quot;aec&quot;不是</strong>）。</p>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//双指针遍历</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSequence</span><span class="params">(String s,String t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;s.length()&amp;&amp;j&lt;t.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s.charAt(i)==t.charAt(j))&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i==s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用内部函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        index = t.indexOf(c, index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>分发饼干</title>
    <url>/2021/07/24/%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</url>
    <content><![CDATA[<h1 id="分发饼干"><a class="markdownIt-Anchor" href="#分发饼干"></a> 分发饼干</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//示例1</span><br><span class="line">输入: [1,2,3], [1,1]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br><span class="line"></span><br><span class="line">//示例2</span><br><span class="line">输入: [1,2], [1,2,3]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="算法实现"><a class="markdownIt-Anchor" href="#算法实现"></a> 算法实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//贪心思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(g==<span class="keyword">null</span>||s==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">int</span> gi=<span class="number">0</span>,si=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(gi&lt;g.length&amp;&amp;si&lt;s.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[gi]&lt;=s[si])&#123;</span><br><span class="line">                gi++;</span><br><span class="line">            &#125;</span><br><span class="line">            si++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>分割回文串</title>
    <url>/2021/07/24/%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="分割回文串"><a class="markdownIt-Anchor" href="#分割回文串"></a> 分割回文串</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 s 所有可能的分割方案。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="思路实现"><a class="markdownIt-Anchor" href="#思路实现"></a> 思路实现</h2>
<p>回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; partitions=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; curpartion=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        doPartition(s,partitions,curpartion);</span><br><span class="line">        <span class="keyword">return</span> partitions;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doPartition</span><span class="params">(String s,List&lt;List&lt;String&gt;&gt; partitions,List&lt;String&gt; curpartion)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            partitions.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curpartion));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome(s,<span class="number">0</span>,i))&#123;</span><br><span class="line">                curpartion.add(s.substring(<span class="number">0</span>,i+<span class="number">1</span>));</span><br><span class="line">                doPartition(s.substring(i+<span class="number">1</span>),partitions,curpartion);</span><br><span class="line">                curpartion.remove(curpartion.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i++)!=s.charAt(j--))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2021/07/24/%E5%85%B3%E4%BA%8E%E6%88%91/</url>
    <content><![CDATA[<p>我也不知道自己是什么样的一个人，普普通通，生活在一个南方温婉的小城，抚州临川，这里是我的家乡，也是汤显祖，曾巩、王安石、晏殊等人的故乡。</p>
<p>目前在大连理工大学软件工程研一在读，对专业知识不太感冒的我更多的喜欢动人的文字与美好的景物。热爱古典文化，喜欢读诗歌、散文和别人的故事。</p>
<p>喜欢大自然的花草树木，喜欢仰望天空中一朵漂浮不定的云，喜欢在水边捡一粒晶莹透亮的石子，喜欢夜幕降临时看归巢的鸟儿与天边的暮云。</p>
<p>从小到大，回想起来，孤独的日子总比快乐要少，成长的岁月里很多时候总是一个人，我不善交际，也不够聪明，也没有一点可以自豪的东西，以至于漫长的读书生涯里一直很自卑自闭，其间看了一些书，对我影响挺多。后面上大学后才开始逐渐接触一些人，认识了一些朋友，大一的时候参加文学社和学生会，后面又机缘巧合懵懵懂懂的加入了校外的一个演讲培训机构，得以认识更多的人，虽然后面离开后和那些人交集也很少了。大二的时候很巧的就认识一个女生，我们可能爱好比较相似，后面她约我，我们去看了电影，那是我生命中第一次去电影院，因为我自小在农村长大，也没什么朋友，所以外面这些娱乐方式都没经历过。那天她身穿一袭素净的汉服，扎的发辫特别与众不同，戴的耳坠和头饰也特别好看，电影落幕后，她说再坐一会儿，电影演的是《八月》，一部黑白影片，满满的幼年回忆之感，然后我们就讲起这些往日的事物来，直到扫地的阿姨要关灯了。后面也常见面，算是本科生涯唯一接触比较多的女生，一起玩的时候有点开心，大三下临毕业那会儿，选择了考研，既有对名校求学的向往，也是渴望去掉更好平台工作的催促使然。于是开启了早出晚归的图书馆自习室备考生活，大三末那个暑假也一直留校学习，学校的饮食并不是很好，每天早上六七点早起，走在寂静的校园里，去到校门口买好早餐，然后坐到树林里的石凳上吃着是一件极幸福的事情，吃完开始背书。下午太阳落山后方去吃晚饭，趁着晚风习习，吃完饭会去荷塘边看一看荷花。后面也如愿考上了研究生，在大连理工大学，复试完录取后第一次去了海边，去星海广场看成群的海鸥，听浪花拍岸的声音，沿着海边一直到黑石礁。次日，体检完便踏上了回乡的路途，坐火车经天津辗转回到南昌。星夜漫漫，一路上北方的萧疏草木，滚滚的黄河与长江水，交织着我一生孑孓飘落的故事。</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200505175904.jpg" alt="" /></p>
<p>大学后，逐渐一个人去了很多地方，去过长沙，走过橘子洲，看过岳麓山的晚照。去过杭州，在一个秋天，一个人搭夜里的火车，在凌晨三点到了杭州，在火车站等公交，然后五点到了断桥边，那时第一眼看见西湖，是在天色有一点点光亮的白茫茫雾色中，看着眼前的一片西湖水，有一种生命的惊心动魄之感，我欢喜不迭的走向断桥，感受着隔年的雪色与今日天边已白的月色，就这样沿着白堤，环着孤山，走过长长的苏堤去到南山。去过济南，是在一个八月底的夏天，去看了大明湖，行走在藕花杨柳深处，想起来李清照的 “争渡，争渡，惊起一滩鸥鹭”，也去看了济南的泉，济南七十二名泉从小在语文课本里便有耳闻，特别著名当属趵突泉，我真的喜欢泉的那种冷碧之色，正好在夏天，泉之冷碧与天之暑热使得这座城市格外美好。去过北京，去看了心心念念的故宫博物院，感叹于故宫古典建筑群的布局设计与色彩辉煌之美，赭红色的宫墙，琉黄色的瓦片，青绿色的雕栏……去的时候是雪后的晴天，地面尚有积雪，阳光在建筑物上洒下的光影也特别迷人。去了颐和园，在颐和园的山里和陌生人一起玩雪，沿着山径走廊看其间的山光鸟影。在大连，也时常一个人逃离出去，去海边看一场日落，去星海广场看飞翔的海鸥，去南山植物园看簇拥在日式建筑里的纷纷银杏，去金石滩看宁静的海水不停的涌上来，去渤海的妈祖庙许下一个关于平安的梦，趁着落雪去看雪后的校园，和一个同爱摄影的朋友沿海之韵一直到棒棰岛。</p>
<p>以后，想去到很多地方，遇见美好的事物，关于美丽的风景或有趣的人儿，也会一直记录，以文字和照片视频的方式。希望遇见志同道合的的有缘人，那一刻，是如山呼海啸，是如落英缤纷。</p>
<p>……</p>
<p>时间来到2020的夏天，因为年初的疫情，今年过年第一次回到阔别已久的家乡，老家庭院的红墙如旧，枣树的枝柯照例横横斜斜，枇杷树已经比我高了。久违了生柴火的大灶，以及随处可闻的鸡犬之声。白天有太阳的时候，最快乐莫过于坐在太阳下看书，看一些古代文人的深情慧性，而庭阶寂寂，小鸟时来啄食。晚上吃完饭便早早去歇息，有月光的时候，喜欢就着月光入睡。</p>
<p>年后算是完整邂逅了家乡的春季，喜欢摄影的我照例去看了许多花，早春的油菜花，红白山茶，满树端庄的玉兰，片片吹落如雪的杏花，以及梦湖边，凤岗河畔，三翁花园是我常去的地方。</p>
<p>当芳菲歇去，夏天也来了，先是一场场急雨敲打着我的窗棂，于是就身倚窗听雨，想起来自己生命中的那些雨季以及那些历史人物生命中的雨。无论是夜雨霖铃，巴山夜雨，秋夕风雨，还是我的泪雨，一并嵌入我生命的骨髓。</p>
<p>梅雨过后，五色的阳光映在水滴上，蝴蝶开始翩翩起舞，夏天的花事正式开始，从合欢花的羽扇轻摇，荷花的满池清影，到紫薇的冉冉花枝。蝉鸣也就四起了，这样的时候并不出外，开始认真准备学业以及工作事宜，是我目前压力较大的源头了，今日有执笔欲，遂书此段。</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
  </entry>
  <entry>
    <title>二进制矩阵中的最短路径</title>
    <url>/2021/07/24/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="二进制矩阵中的最短路径"><a class="markdownIt-Anchor" href="#二进制矩阵中的最短路径"></a> 二进制矩阵中的最短路径</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。</p>
<p>一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, …, C_k 组成：</p>
<ul>
<li>相邻单元格 C_i 和 C_{i+1} 在八个方向之一上连通（此时，C_i 和 C_{i+1} 不同且共享边或角）</li>
<li>C_1 位于 (0, 0)（即，值为 <code>grid[0][0]</code>）</li>
<li>C_k 位于 (N-1, N-1)（即，值为 <code>grid[N-1][N-1]</code>）</li>
<li>如果 C_i 位于 (r, c)，则 <code>grid[r][c]</code> 为空（即，<code>grid[r][c] == 0</code>）</li>
</ul>
<p>返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[[0,1],[1,0]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>最短路通常考虑BFS方法求解。</p>
<p>需要注意的两点：是八连通不是四连通，最长路径指的是点的个数而不是边的长度。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestPathBinaryMatrix</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=grid.length;</span><br><span class="line">        <span class="comment">//当起始位和终点位为1，即阻塞。</span></span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>||grid[n-<span class="number">1</span>][n-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化队列存储当前层元素，boolean数组判断该元素是否为0（即路径可走）。</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[][] vis=<span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        <span class="comment">//加入初始位</span></span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">        vis[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//八邻域方向</span></span><br><span class="line">        <span class="keyword">int</span>[][] direction=<span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//res记录可作为路径的当前点</span></span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//层序遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size= queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size--!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] cur= queue.poll();</span><br><span class="line">                <span class="comment">//到达终点则返回res</span></span><br><span class="line">                <span class="keyword">if</span>(cur[<span class="number">0</span>]==n-<span class="number">1</span>&amp;&amp;cur[<span class="number">1</span>]==n-<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//判断该位置元素和它的八邻域元素是否构成路径</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span>[] dir:direction)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x=cur[<span class="number">0</span>]+dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y=cur[<span class="number">1</span>]+dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;n&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;n&amp;&amp;grid[x][y]==<span class="number">0</span>)&#123;</span><br><span class="line">                        vis[x][y]=<span class="keyword">true</span>;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x,y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] grid=&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        ShortestPathBinaryMatrix shortestPathBinaryMatrix=<span class="keyword">new</span> ShortestPathBinaryMatrix();</span><br><span class="line">        System.out.println(shortestPathBinaryMatrix.shortestPath(grid));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制中1的个数</title>
    <url>/2021/07/24/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="二进制中1的个数"><a class="markdownIt-Anchor" href="#二进制中1的个数"></a> 二进制中1的个数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p>
<h2 id="方法一逐位与1相与"><a class="markdownIt-Anchor" href="#方法一逐位与1相与"></a> 方法一：逐位与1相与</h2>
<p>根据 <strong>与运算</strong> 定义，设二进制数字 n ，则有：<br />
若 n &amp; 1 = 0，则 n 二进制 最右一位 为 0 ；<br />
若 n &amp; 1 = 1 ，则 n 二进制 最右一位 为 1。</p>
<p>根据以上特点，考虑以下 循环判断 ：<br />
判断 n 最右一位是否为 1 ，根据结果计数。<br />
将 n右移一位（本题要求把数字 n 看作无符号数，因此使用 无符号右移 操作）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;<span class="comment">//当全部比较完，n的二进制位全为0，即n=0.</span></span><br><span class="line">        res+=n&amp;<span class="number">1</span>;</span><br><span class="line">        n&gt;&gt;&gt;=<span class="number">1</span>;<span class="comment">//java无符号右移，这样每次将n的二进制位置于最尾进行比较。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二进制移位相关知识"><a class="markdownIt-Anchor" href="#二进制移位相关知识"></a> 二进制移位相关知识</h2>
<ul>
<li>**无符号右移：**无论是正数还是负数，高位通通补0。</li>
<li><strong>右移运算符</strong>：它表示是将运算符左边的对象向右移动，移动位数为运算符右边指定的数，并且在高位补0，其实右移n位，就相当于除于2的n次方。</li>
<li><strong>带符号右移运算符</strong>：它表示将运算符左边的运算对象，向右移动运算符右边指定的位数。如果是正数，在高位补零，如果是负数，则在高位补1；</li>
<li>**左移运算符：**它表示是将运算符左边的对象，向左移动运算符右边指定的位数，并且在低位补零。其实，向左移n位，就相当于乘上2的n此方；</li>
</ul>
<h2 id="方法二n-n-1"><a class="markdownIt-Anchor" href="#方法二n-n-1"></a> 方法二：n &amp;（n-1）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            n &amp;= n - <span class="number">1</span>;<span class="comment">//消去数字 n 最右边的 1 。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中的所有路径</title>
    <url>/2021/07/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="二叉树中的所有路径"><a class="markdownIt-Anchor" href="#二叉树中的所有路径"></a> 二叉树中的所有路径</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>典型的回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">allPaths</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; paths=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; values=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        backTrack(root,paths,values);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(TreeNode node,List&lt;Integer&gt; paths,List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;<span class="comment">//判空</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        values.add(node.val);<span class="comment">//不空则加入路径结点值</span></span><br><span class="line">        <span class="keyword">if</span>(isLeaf(node))&#123;<span class="comment">//成立条件：走到了叶子结点</span></span><br><span class="line">            paths.add(buildPath(values));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//否则选择左右方向遍历</span></span><br><span class="line">            backTrack(node.left,paths,values);</span><br><span class="line">            backTrack(node.right,paths,values);</span><br><span class="line">        &#125;</span><br><span class="line">        values.remove(values.size()-<span class="number">1</span>);<span class="comment">//撤销选择</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是叶子</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.left==<span class="keyword">null</span>&amp;&amp;node.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据路径value值建立path</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">buildPath</span><span class="params">(List&lt;Integer&gt; values)</span></span>&#123;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;values.size();i++)&#123;</span><br><span class="line">            res.append(values.get(i));</span><br><span class="line">            <span class="keyword">if</span>(i!=values.size()-<span class="number">1</span>)&#123;</span><br><span class="line">                res.append(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>为运算表达式设定优先级</title>
    <url>/2021/07/24/%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E5%AE%9A%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="为运算表达式设定优先级"><a class="markdownIt-Anchor" href="#为运算表达式设定优先级"></a> 为运算表达式设定优先级</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;2-1-1&quot;</span><br><span class="line">输出: [0, 2]</span><br><span class="line">解释: </span><br><span class="line">((2-1)-1) = 0 </span><br><span class="line">(2-(1-1)) = 2</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>考虑使用分治法。</p>
<p>1、先对输入字符串进行判断，若为空，返回一个空列表结果。</p>
<p>2、若不空但全为数字，则直接获取该数字字符串所表示的整数值。</p>
<p>3、出现了运算符，则对字符串根据该运算符位置划分左列表和右列表。分别计算左列表结果和右列表结果，然后根据该运算符得到一个最后结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以 2 * 3 - 4 * 5 为例。</span><br><span class="line"></span><br><span class="line">2 和 3 - 4 * 5 两部分，中间是 * 号相连。</span><br><span class="line"></span><br><span class="line">2 * 3 和 4 * 5 两部分，中间是 - 号相连。</span><br><span class="line"></span><br><span class="line">2 * 3 - 4 和 5 两部分，中间是 * 号相连。</span><br><span class="line"></span><br><span class="line">有了两部分的结果，然后再通过中间的符号两两计算加入到最终的结果中即可。</span><br><span class="line"></span><br><span class="line">比如第一种情况，2 和 3 - 4 * 5 两部分，中间是 * 号相连。</span><br><span class="line"></span><br><span class="line">2 的解就是 [2]，3 - 4 * 5 的解就是 [-5, -17]。</span><br><span class="line"></span><br><span class="line">把两部分解通过 * 号计算，最终结果就是 [-10, -34]。</span><br><span class="line"></span><br><span class="line">另外两种情况也类似。</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiffWayToCompute</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffToCompute</span><span class="params">(String input)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span>(input.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>,num=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//全为数字的情况</span></span><br><span class="line">        <span class="keyword">while</span>(index&lt;input.length()&amp;&amp;!isOperation(input.charAt(index)))&#123;</span><br><span class="line">            num=num*<span class="number">10</span>+input.charAt(index)-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//数字字符减0字符可以得到该字符对应数字。</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(index==input.length())&#123;</span><br><span class="line">            result.add(num);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出现算术符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;input.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isOperation(input.charAt(i)))&#123;</span><br><span class="line">                List&lt;Integer&gt; result1=diffToCompute(input.substring(<span class="number">0</span>,i));</span><br><span class="line">                List&lt;Integer&gt; result2=diffToCompute(input.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;result1.size();j++)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;result2.size();k++)&#123;</span><br><span class="line">                        <span class="keyword">char</span> op=input.charAt(i);</span><br><span class="line">                        result.add(calculate(result1.get(j),op,result2.get(k)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">char</span> op, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (op)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> m+n;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> m-n;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> m*n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOperation</span><span class="params">(<span class="keyword">char</span> op)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((op == <span class="string">&#x27;+&#x27;</span>)||(op==<span class="string">&#x27;-&#x27;</span>)||(op==<span class="string">&#x27;*&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>不同的二叉搜索树</title>
    <url>/2021/07/24/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="不同的二叉搜索树"><a class="markdownIt-Anchor" href="#不同的二叉搜索树"></a> 不同的二叉搜索树</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>构建一棵二叉搜索树</strong></p>
<p>构建一颗二叉搜索树很简单，只需要选择一个根结点，然后递归去构建其左右子树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">creatBinaryTree</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(<span class="number">1</span>,n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start&gt;end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> val=(start+end)/<span class="number">2</span>;</span><br><span class="line">    TreeNode root=<span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    root.left=helper(start,val-<span class="number">1</span>);</span><br><span class="line">    root.right=helper(val+<span class="number">1</span>,end);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要构建多颗二叉树，问题就在于如何选择不同的根节点，以构建不同的树和子树。</p>
<p>在上面的代码中，在选择根结点的时候，可以这样改造</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 选择所有可能的根结点</span><br><span class="line">for(int i = start; i &lt;= end; i++)&#123;</span><br><span class="line">    TreeNode root = new TreeNode(i);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是如果按照上述递归函数的方法写，每次递归只能返回一颗树，我们需要的是多颗树，我们可以将不同的根结点装入List然后返回，实际上，上述代码可以改写成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 装入所有根结点</span></span><br><span class="line">        list.add(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很显然，现在问题变成了如何构建root的左右子树，我们抛开复杂的递归函数，只关心递归的返回值，每次选择根结点root，我们</p>
<ul>
<li>
<p>递归构建左子树，并拿到左子树所有可能的根结点列表left</p>
</li>
<li>
<p>递归构建右子树，并拿到右子树所有可能的根结点列表right</p>
<p>这个时候我们有了左右子树列表，我们的左右子树都是各不相同的，因为根结点不同，我们如何通过左右子树列表构建出所有的以root为根的树呢？</p>
</li>
</ul>
<p>我们固定一个左孩子，遍历右子树列表，那么以当前为root根结点的树个数就为left.size() * right.size()个。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">        <span class="comment">// 如果当前子树为空，不加null行吗？</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">        <span class="comment">// 想想为什么这行不能放在这里，而放在下面？</span></span><br><span class="line">        <span class="comment">// TreeNode root = new TreeNode(i);</span></span><br><span class="line">        List&lt;TreeNode&gt; left = helper(start, i-<span class="number">1</span>);  </span><br><span class="line">        List&lt;TreeNode&gt; right = helper(i+<span class="number">1</span>, end); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 固定左孩子，遍历右孩子</span></span><br><span class="line">        <span class="keyword">for</span>(TreeNode l : left)&#123;</span><br><span class="line">            <span class="keyword">for</span>(TreeNode r : right)&#123;</span><br><span class="line">                TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                root.left = l;</span><br><span class="line">                root.right = r;</span><br><span class="line">                list.add(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}<br />
关于TreeNode root = new TreeNode(i)的放置的位置问题<br />
如果这行代码放置在注释的地方，会造成一个问题，就是以当前为root根结点的树个数就<br />
num = left.size() * right.size() &gt; 1时，num棵子树会共用这个root结点，在下面两层for循环中，root的左右子树一直在更新，如果每次不新建一个root，就会导致num个root为根节点的树都相同。</p>
<p>关于如果当前子树为空，不加null行不行的问题<br />
显然，如果一颗树的左子树为空，右子树不为空，要正确构建所有树，依赖于对左右子树列表的遍历，也就是上述代码两层for循环的地方，如果其中一个列表为空，那么循环都将无法进行。</p>
<p>作者：antione<br />
链接：<a href="https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/cong-gou-jian-dan-ke-shu-dao-gou-jian-suo-you-shu-/">https://leetcode-cn.com/problems/unique-binary-search-trees-ii/solution/cong-gou-jian-dan-ke-shu-dao-gou-jian-suo-you-shu-/</a><br />
来源：力扣（LeetCode）<br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora图标一览</title>
    <url>/2021/07/24/Typora%E5%9B%BE%E6%A0%87%E4%B8%80%E8%A7%88/</url>
    <content><![CDATA[<h1 id="typora图标一览"><a class="markdownIt-Anchor" href="#typora图标一览"></a> Typora图标一览</h1>
<h1 id="people"><a class="markdownIt-Anchor" href="#people"></a> People</h1>
<table>
<thead>
<tr>
<th style="text-align:left">😄 <code>:smile:</code></th>
<th style="text-align:left">😆 <code>:laughing:</code></th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">😊 <code>:blush:</code></td>
<td style="text-align:left">😃 <code>:smiley:</code></td>
<td style="text-align:left">☺️ <code>:relaxed:</code></td>
</tr>
<tr>
<td style="text-align:left">😏 <code>:smirk:</code></td>
<td style="text-align:left">😍 <code>:heart_eyes:</code></td>
<td style="text-align:left">😘 <code>:kissing_heart:</code></td>
</tr>
<tr>
<td style="text-align:left">😚 <code>:kissing_closed_eyes:</code></td>
<td style="text-align:left">😳 <code>:flushed:</code></td>
<td style="text-align:left">😌 <code>:relieved:</code></td>
</tr>
<tr>
<td style="text-align:left">😆 <code>:satisfied:</code></td>
<td style="text-align:left">😁 <code>:grin:</code></td>
<td style="text-align:left">😉 <code>:wink:</code></td>
</tr>
<tr>
<td style="text-align:left">😜 <code>:stuck_out_tongue_winking_eye:</code></td>
<td style="text-align:left">😝 <code>:stuck_out_tongue_closed_eyes:</code></td>
<td style="text-align:left">😀 <code>:grinning:</code></td>
</tr>
<tr>
<td style="text-align:left">😗 <code>:kissing:</code></td>
<td style="text-align:left">😙 <code>:kissing_smiling_eyes:</code></td>
<td style="text-align:left">😛 <code>:stuck_out_tongue:</code></td>
</tr>
<tr>
<td style="text-align:left">😴 <code>:sleeping:</code></td>
<td style="text-align:left">😟 <code>:worried:</code></td>
<td style="text-align:left">😦 <code>:frowning:</code></td>
</tr>
<tr>
<td style="text-align:left">😧 <code>:anguished:</code></td>
<td style="text-align:left">😮 <code>:open_mouth:</code></td>
<td style="text-align:left">😬 <code>:grimacing:</code></td>
</tr>
<tr>
<td style="text-align:left">😕 <code>:confused:</code></td>
<td style="text-align:left">😯 <code>:hushed:</code></td>
<td style="text-align:left">😑 <code>:expressionless:</code></td>
</tr>
<tr>
<td style="text-align:left">😒 <code>:unamused:</code></td>
<td style="text-align:left">😅 <code>:sweat_smile:</code></td>
<td style="text-align:left">😓 <code>:sweat:</code></td>
</tr>
<tr>
<td style="text-align:left">😥 <code>:disappointed_relieved:</code></td>
<td style="text-align:left">😩 <code>:weary:</code></td>
<td style="text-align:left">😔 <code>:pensive:</code></td>
</tr>
<tr>
<td style="text-align:left">😞 <code>:disappointed:</code></td>
<td style="text-align:left">😖 <code>:confounded:</code></td>
<td style="text-align:left">😨 <code>:fearful:</code></td>
</tr>
<tr>
<td style="text-align:left">😰 <code>:cold_sweat:</code></td>
<td style="text-align:left">😣 <code>:persevere:</code></td>
<td style="text-align:left">😢 <code>:cry:</code></td>
</tr>
<tr>
<td style="text-align:left">😭 <code>:sob:</code></td>
<td style="text-align:left">😂 <code>:joy:</code></td>
<td style="text-align:left">😲 <code>:astonished:</code></td>
</tr>
<tr>
<td style="text-align:left">😱 <code>:scream:</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">😫 <code>:tired_face:</code></td>
</tr>
<tr>
<td style="text-align:left">😠 <code>:angry:</code></td>
<td style="text-align:left">😡 <code>:rage:</code></td>
<td style="text-align:left">😤 <code>:triumph:</code></td>
</tr>
<tr>
<td style="text-align:left">😪 <code>:sleepy:</code></td>
<td style="text-align:left">😋 <code>:yum:</code></td>
<td style="text-align:left">😷 <code>:mask:</code></td>
</tr>
<tr>
<td style="text-align:left">😎 <code>:sunglasses:</code></td>
<td style="text-align:left">😵 <code>:dizzy_face:</code></td>
<td style="text-align:left">👿 <code>:imp:</code></td>
</tr>
<tr>
<td style="text-align:left">😈 <code>:smiling_imp:</code></td>
<td style="text-align:left">😐 <code>:neutral_face:</code></td>
<td style="text-align:left">😶 <code>:no_mouth:</code></td>
</tr>
<tr>
<td style="text-align:left">😇 <code>:innocent:</code></td>
<td style="text-align:left">👽 <code>:alien:</code></td>
<td style="text-align:left">💛 <code>:yellow_heart:</code></td>
</tr>
<tr>
<td style="text-align:left">💙 <code>:blue_heart:</code></td>
<td style="text-align:left">💜 <code>:purple_heart:</code></td>
<td style="text-align:left">❤️ <code>:heart:</code></td>
</tr>
<tr>
<td style="text-align:left">💚 <code>:green_heart:</code></td>
<td style="text-align:left">💔 <code>:broken_heart:</code></td>
<td style="text-align:left">💓 <code>:heartbeat:</code></td>
</tr>
<tr>
<td style="text-align:left">💗 <code>:heartpulse:</code></td>
<td style="text-align:left">💕 <code>:two_hearts:</code></td>
<td style="text-align:left">💞 <code>:revolving_hearts:</code></td>
</tr>
<tr>
<td style="text-align:left">💘 <code>:cupid:</code></td>
<td style="text-align:left">💖 <code>:sparkling_heart:</code></td>
<td style="text-align:left">✨ <code>:sparkles:</code></td>
</tr>
<tr>
<td style="text-align:left">⭐️ <code>:star:</code></td>
<td style="text-align:left">🌟 <code>:star2:</code></td>
<td style="text-align:left">💫 <code>:dizzy:</code></td>
</tr>
<tr>
<td style="text-align:left">💥 <code>:boom:</code></td>
<td style="text-align:left">💥 <code>:collision:</code></td>
<td style="text-align:left">💢 <code>:anger:</code></td>
</tr>
<tr>
<td style="text-align:left">❗️ <code>:exclamation:</code></td>
<td style="text-align:left">❓ <code>:question:</code></td>
<td style="text-align:left">❕ <code>:grey_exclamation:</code></td>
</tr>
<tr>
<td style="text-align:left">❔ <code>:grey_question:</code></td>
<td style="text-align:left">💤 <code>:zzz:</code></td>
<td style="text-align:left">💨 <code>:dash:</code></td>
</tr>
<tr>
<td style="text-align:left">💦 <code>:sweat_drops:</code></td>
<td style="text-align:left">🎶 <code>:notes:</code></td>
<td style="text-align:left">🎵 <code>:musical_note:</code></td>
</tr>
<tr>
<td style="text-align:left">🔥 <code>:fire:</code></td>
<td style="text-align:left">💩 <code>:hankey:</code></td>
<td style="text-align:left">💩 <code>:poop:</code></td>
</tr>
<tr>
<td style="text-align:left">💩 <code>:shit:</code></td>
<td style="text-align:left">👍 <code>:+1:</code></td>
<td style="text-align:left">👍 <code>:thumbsup:</code></td>
</tr>
<tr>
<td style="text-align:left">👎 <code>:-1:</code></td>
<td style="text-align:left">👎 <code>:thumbsdown:</code></td>
<td style="text-align:left">👌 <code>:ok_hand:</code></td>
</tr>
<tr>
<td style="text-align:left">👊 <code>:punch:</code></td>
<td style="text-align:left">👊 <code>:facepunch:</code></td>
<td style="text-align:left">✊ <code>:fist:</code></td>
</tr>
<tr>
<td style="text-align:left">✌️ <code>:v:</code></td>
<td style="text-align:left">👋 <code>:wave:</code></td>
<td style="text-align:left">✋ <code>:hand:</code></td>
</tr>
<tr>
<td style="text-align:left">✋ <code>:raised_hand:</code></td>
<td style="text-align:left">👐 <code>:open_hands:</code></td>
<td style="text-align:left">☝️ <code>:point_up:</code></td>
</tr>
<tr>
<td style="text-align:left">👇 <code>:point_down:</code></td>
<td style="text-align:left">👈 <code>:point_left:</code></td>
<td style="text-align:left">👉 <code>:point_right:</code></td>
</tr>
<tr>
<td style="text-align:left">🙌 <code>:raised_hands:</code></td>
<td style="text-align:left">🙏 <code>:pray:</code></td>
<td style="text-align:left">👆 <code>:point_up_2:</code></td>
</tr>
<tr>
<td style="text-align:left">👏 <code>:clap:</code></td>
<td style="text-align:left">💪 <code>:muscle:</code></td>
<td style="text-align:left">🤘 <code>:metal:</code></td>
</tr>
<tr>
<td style="text-align:left">🖕 <code>:fu:</code></td>
<td style="text-align:left">🚶 <code>:walking:</code></td>
<td style="text-align:left">🏃 <code>:runner:</code></td>
</tr>
<tr>
<td style="text-align:left">🏃 <code>:running:</code></td>
<td style="text-align:left">👫 <code>:couple:</code></td>
<td style="text-align:left">👪 <code>:family:</code></td>
</tr>
<tr>
<td style="text-align:left">👬 <code>:two_men_holding_hands:</code></td>
<td style="text-align:left">👭 <code>:two_women_holding_hands:</code></td>
<td style="text-align:left">💃 <code>:dancer:</code></td>
</tr>
<tr>
<td style="text-align:left">👯 <code>:dancers:</code></td>
<td style="text-align:left">🙆 <code>:ok_woman:</code></td>
<td style="text-align:left">🙅 <code>:no_good:</code></td>
</tr>
<tr>
<td style="text-align:left">💁 <code>:information_desk_person:</code></td>
<td style="text-align:left">🙋 <code>:raising_hand:</code></td>
<td style="text-align:left">👰 <code>:bride_with_veil:</code></td>
</tr>
<tr>
<td style="text-align:left">🙎 <code>:person_with_pouting_face:</code></td>
<td style="text-align:left">🙍 <code>:person_frowning:</code></td>
<td style="text-align:left">🙇 <code>:bow:</code></td>
</tr>
<tr>
<td style="text-align:left">:couplekiss: <code>:couplekiss:</code></td>
<td style="text-align:left">💑 <code>:couple_with_heart:</code></td>
<td style="text-align:left">💆 <code>:massage:</code></td>
</tr>
<tr>
<td style="text-align:left">💇 <code>:haircut:</code></td>
<td style="text-align:left">💅 <code>:nail_care:</code></td>
<td style="text-align:left">👦 <code>:boy:</code></td>
</tr>
<tr>
<td style="text-align:left">👧 <code>:girl:</code></td>
<td style="text-align:left">👩 <code>:woman:</code></td>
<td style="text-align:left">👨 <code>:man:</code></td>
</tr>
<tr>
<td style="text-align:left">👶 <code>:baby:</code></td>
<td style="text-align:left">👵 <code>:older_woman:</code></td>
<td style="text-align:left">👴 <code>:older_man:</code></td>
</tr>
<tr>
<td style="text-align:left">👱 <code>:person_with_blond_hair:</code></td>
<td style="text-align:left">👲 <code>:man_with_gua_pi_mao:</code></td>
<td style="text-align:left">👳 <code>:man_with_turban:</code></td>
</tr>
<tr>
<td style="text-align:left">👷 <code>:construction_worker:</code></td>
<td style="text-align:left">👮 <code>:cop:</code></td>
<td style="text-align:left">👼 <code>:angel:</code></td>
</tr>
<tr>
<td style="text-align:left">👸 <code>:princess:</code></td>
<td style="text-align:left">😺 <code>:smiley_cat:</code></td>
<td style="text-align:left">😸 <code>:smile_cat:</code></td>
</tr>
<tr>
<td style="text-align:left">😻 <code>:heart_eyes_cat:</code></td>
<td style="text-align:left">😽 <code>:kissing_cat:</code></td>
<td style="text-align:left">😼 <code>:smirk_cat:</code></td>
</tr>
<tr>
<td style="text-align:left">🙀 <code>:scream_cat:</code></td>
<td style="text-align:left">😿 <code>:crying_cat_face:</code></td>
<td style="text-align:left">😹 <code>:joy_cat:</code></td>
</tr>
<tr>
<td style="text-align:left">😾 <code>:pouting_cat:</code></td>
<td style="text-align:left">👹 <code>:japanese_ogre:</code></td>
<td style="text-align:left">👺 <code>:japanese_goblin:</code></td>
</tr>
<tr>
<td style="text-align:left">🙈 <code>:see_no_evil:</code></td>
<td style="text-align:left">🙉 <code>:hear_no_evil:</code></td>
<td style="text-align:left">🙊 <code>:speak_no_evil:</code></td>
</tr>
<tr>
<td style="text-align:left">💂 <code>:guardsman:</code></td>
<td style="text-align:left">💀 <code>:skull:</code></td>
<td style="text-align:left">🐾 <code>:feet:</code></td>
</tr>
<tr>
<td style="text-align:left">👄 <code>:lips:</code></td>
<td style="text-align:left">💋 <code>:kiss:</code></td>
<td style="text-align:left">💧 <code>:droplet:</code></td>
</tr>
<tr>
<td style="text-align:left">👂 <code>:ear:</code></td>
<td style="text-align:left">👀 <code>:eyes:</code></td>
<td style="text-align:left">👃 <code>:nose:</code></td>
</tr>
<tr>
<td style="text-align:left">👅 <code>:tongue:</code></td>
<td style="text-align:left">💌 <code>:love_letter:</code></td>
<td style="text-align:left">👤 <code>:bust_in_silhouette:</code></td>
</tr>
<tr>
<td style="text-align:left">👥 <code>:busts_in_silhouette:</code></td>
<td style="text-align:left">💬 <code>:speech_balloon:</code></td>
<td style="text-align:left">💭 <code>:thought_balloon:</code></td>
</tr>
</tbody>
</table>
<h1 id="nature"><a class="markdownIt-Anchor" href="#nature"></a> Nature</h1>
<table>
<thead>
<tr>
<th style="text-align:left">☀️ <code>:sunny:</code></th>
<th style="text-align:left">☔️ <code>:umbrella:</code></th>
<th style="text-align:left">☁️ <code>:cloud:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">❄️ <code>:snowflake:</code></td>
<td style="text-align:left">⛄️ <code>:snowman:</code></td>
<td style="text-align:left">⚡️ <code>:zap:</code></td>
</tr>
<tr>
<td style="text-align:left">🌀 <code>:cyclone:</code></td>
<td style="text-align:left">🌁 <code>:foggy:</code></td>
<td style="text-align:left">🌊 <code>:ocean:</code></td>
</tr>
<tr>
<td style="text-align:left">🐱 <code>:cat:</code></td>
<td style="text-align:left">🐶 <code>:dog:</code></td>
<td style="text-align:left">🐭 <code>:mouse:</code></td>
</tr>
<tr>
<td style="text-align:left">🐹 <code>:hamster:</code></td>
<td style="text-align:left">🐰 <code>:rabbit:</code></td>
<td style="text-align:left">🐺 <code>:wolf:</code></td>
</tr>
<tr>
<td style="text-align:left">🐸 <code>:frog:</code></td>
<td style="text-align:left">🐯 <code>:tiger:</code></td>
<td style="text-align:left">🐨 <code>:koala:</code></td>
</tr>
<tr>
<td style="text-align:left">🐻 <code>:bear:</code></td>
<td style="text-align:left">🐷 <code>:pig:</code></td>
<td style="text-align:left">🐽 <code>:pig_nose:</code></td>
</tr>
<tr>
<td style="text-align:left">🐮 <code>:cow:</code></td>
<td style="text-align:left">🐗 <code>:boar:</code></td>
<td style="text-align:left">🐵 <code>:monkey_face:</code></td>
</tr>
<tr>
<td style="text-align:left">🐒 <code>:monkey:</code></td>
<td style="text-align:left">🐴 <code>:horse:</code></td>
<td style="text-align:left">🐎 <code>:racehorse:</code></td>
</tr>
<tr>
<td style="text-align:left">🐫 <code>:camel:</code></td>
<td style="text-align:left">🐑 <code>:sheep:</code></td>
<td style="text-align:left">🐘 <code>:elephant:</code></td>
</tr>
<tr>
<td style="text-align:left">🐼 <code>:panda_face:</code></td>
<td style="text-align:left">🐍 <code>:snake:</code></td>
<td style="text-align:left">🐦 <code>:bird:</code></td>
</tr>
<tr>
<td style="text-align:left">🐤 <code>:baby_chick:</code></td>
<td style="text-align:left">🐥 <code>:hatched_chick:</code></td>
<td style="text-align:left">🐣 <code>:hatching_chick:</code></td>
</tr>
<tr>
<td style="text-align:left">🐔 <code>:chicken:</code></td>
<td style="text-align:left">🐧 <code>:penguin:</code></td>
<td style="text-align:left">🐢 <code>:turtle:</code></td>
</tr>
<tr>
<td style="text-align:left">🐛 <code>:bug:</code></td>
<td style="text-align:left">🐝 <code>:honeybee:</code></td>
<td style="text-align:left">🐜 <code>:ant:</code></td>
</tr>
<tr>
<td style="text-align:left">🐞 <code>:beetle:</code></td>
<td style="text-align:left">🐌 <code>:snail:</code></td>
<td style="text-align:left">🐙 <code>:octopus:</code></td>
</tr>
<tr>
<td style="text-align:left">🐠 <code>:tropical_fish:</code></td>
<td style="text-align:left">🐟 <code>:fish:</code></td>
<td style="text-align:left">🐳 <code>:whale:</code></td>
</tr>
<tr>
<td style="text-align:left">🐋 <code>:whale2:</code></td>
<td style="text-align:left">🐬 <code>:dolphin:</code></td>
<td style="text-align:left">🐄 <code>:cow2:</code></td>
</tr>
<tr>
<td style="text-align:left">🐏 <code>:ram:</code></td>
<td style="text-align:left">🐀 <code>:rat:</code></td>
<td style="text-align:left">🐃 <code>:water_buffalo:</code></td>
</tr>
<tr>
<td style="text-align:left">🐅 <code>:tiger2:</code></td>
<td style="text-align:left">🐇 <code>:rabbit2:</code></td>
<td style="text-align:left">🐉 <code>:dragon:</code></td>
</tr>
<tr>
<td style="text-align:left">🐐 <code>:goat:</code></td>
<td style="text-align:left">🐓 <code>:rooster:</code></td>
<td style="text-align:left">🐕 <code>:dog2:</code></td>
</tr>
<tr>
<td style="text-align:left">🐖 <code>:pig2:</code></td>
<td style="text-align:left">🐁 <code>:mouse2:</code></td>
<td style="text-align:left">🐂 <code>:ox:</code></td>
</tr>
<tr>
<td style="text-align:left">🐲 <code>:dragon_face:</code></td>
<td style="text-align:left">🐡 <code>:blowfish:</code></td>
<td style="text-align:left">🐊 <code>:crocodile:</code></td>
</tr>
<tr>
<td style="text-align:left">🐪 <code>:dromedary_camel:</code></td>
<td style="text-align:left">🐆 <code>:leopard:</code></td>
<td style="text-align:left">🐈 <code>:cat2:</code></td>
</tr>
<tr>
<td style="text-align:left">🐩 <code>:poodle:</code></td>
<td style="text-align:left">🐾 <code>:paw_prints:</code></td>
<td style="text-align:left">💐 <code>:bouquet:</code></td>
</tr>
<tr>
<td style="text-align:left">🌸 <code>:cherry_blossom:</code></td>
<td style="text-align:left">🌷 <code>:tulip:</code></td>
<td style="text-align:left">🍀 <code>:four_leaf_clover:</code></td>
</tr>
<tr>
<td style="text-align:left">🌹 <code>:rose:</code></td>
<td style="text-align:left">🌻 <code>:sunflower:</code></td>
<td style="text-align:left">🌺 <code>:hibiscus:</code></td>
</tr>
<tr>
<td style="text-align:left">🍁 <code>:maple_leaf:</code></td>
<td style="text-align:left">🍃 <code>:leaves:</code></td>
<td style="text-align:left">🍂 <code>:fallen_leaf:</code></td>
</tr>
<tr>
<td style="text-align:left">🌿 <code>:herb:</code></td>
<td style="text-align:left">🍄 <code>:mushroom:</code></td>
<td style="text-align:left">🌵 <code>:cactus:</code></td>
</tr>
<tr>
<td style="text-align:left">🌴 <code>:palm_tree:</code></td>
<td style="text-align:left">🌲 <code>:evergreen_tree:</code></td>
<td style="text-align:left">🌳 <code>:deciduous_tree:</code></td>
</tr>
<tr>
<td style="text-align:left">🌰 <code>:chestnut:</code></td>
<td style="text-align:left">🌱 <code>:seedling:</code></td>
<td style="text-align:left">🌼 <code>:blossom:</code></td>
</tr>
<tr>
<td style="text-align:left">🌾 <code>:ear_of_rice:</code></td>
<td style="text-align:left">🐚 <code>:shell:</code></td>
<td style="text-align:left">🌐 <code>:globe_with_meridians:</code></td>
</tr>
<tr>
<td style="text-align:left">🌞 <code>:sun_with_face:</code></td>
<td style="text-align:left">🌝 <code>:full_moon_with_face:</code></td>
<td style="text-align:left">🌚 <code>:new_moon_with_face:</code></td>
</tr>
<tr>
<td style="text-align:left">🌑 <code>:new_moon:</code></td>
<td style="text-align:left">🌒 <code>:waxing_crescent_moon:</code></td>
<td style="text-align:left">🌓 <code>:first_quarter_moon:</code></td>
</tr>
<tr>
<td style="text-align:left">🌔 <code>:waxing_gibbous_moon:</code></td>
<td style="text-align:left">🌕 <code>:full_moon:</code></td>
<td style="text-align:left">🌖 <code>:waning_gibbous_moon:</code></td>
</tr>
<tr>
<td style="text-align:left">🌗 <code>:last_quarter_moon:</code></td>
<td style="text-align:left">🌘 <code>:waning_crescent_moon:</code></td>
<td style="text-align:left">🌜 <code>:last_quarter_moon_with_face:</code></td>
</tr>
<tr>
<td style="text-align:left">🌛 <code>:first_quarter_moon_with_face:</code></td>
<td style="text-align:left">🌔 <code>:moon:</code></td>
<td style="text-align:left">🌍 <code>:earth_africa:</code></td>
</tr>
<tr>
<td style="text-align:left">🌎 <code>:earth_americas:</code></td>
<td style="text-align:left">🌏 <code>:earth_asia:</code></td>
<td style="text-align:left">🌋 <code>:volcano:</code></td>
</tr>
<tr>
<td style="text-align:left">🌌 <code>:milky_way:</code></td>
<td style="text-align:left">⛅️ <code>:partly_sunny:</code></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h1 id="object"><a class="markdownIt-Anchor" href="#object"></a> Object</h1>
<table>
<thead>
<tr>
<th style="text-align:left">🎍 <code>:bamboo:</code></th>
<th style="text-align:left">💝 <code>:gift_heart:</code></th>
<th style="text-align:left">🎎 <code>:dolls:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">🎒 <code>:school_satchel:</code></td>
<td style="text-align:left">🎓 <code>:mortar_board:</code></td>
<td style="text-align:left">🎏 <code>:flags:</code></td>
</tr>
<tr>
<td style="text-align:left">🎆 <code>:fireworks:</code></td>
<td style="text-align:left">🎇 <code>:sparkler:</code></td>
<td style="text-align:left">🎐 <code>:wind_chime:</code></td>
</tr>
<tr>
<td style="text-align:left">🎑 <code>:rice_scene:</code></td>
<td style="text-align:left">🎃 <code>:jack_o_lantern:</code></td>
<td style="text-align:left">👻 <code>:ghost:</code></td>
</tr>
<tr>
<td style="text-align:left">🎅 <code>:santa:</code></td>
<td style="text-align:left">🎄 <code>:christmas_tree:</code></td>
<td style="text-align:left">🎁 <code>:gift:</code></td>
</tr>
<tr>
<td style="text-align:left">🔔 <code>:bell:</code></td>
<td style="text-align:left">🔕 <code>:no_bell:</code></td>
<td style="text-align:left">🎋 <code>:tanabata_tree:</code></td>
</tr>
<tr>
<td style="text-align:left">🎉 <code>:tada:</code></td>
<td style="text-align:left">🎊 <code>:confetti_ball:</code></td>
<td style="text-align:left">🎈 <code>:balloon:</code></td>
</tr>
<tr>
<td style="text-align:left">🔮 <code>:crystal_ball:</code></td>
<td style="text-align:left">💿 <code>:cd:</code></td>
<td style="text-align:left">📀 <code>:dvd:</code></td>
</tr>
<tr>
<td style="text-align:left">💾 <code>:floppy_disk:</code></td>
<td style="text-align:left">📷 <code>:camera:</code></td>
<td style="text-align:left">📹 <code>:video_camera:</code></td>
</tr>
<tr>
<td style="text-align:left">🎥 <code>:movie_camera:</code></td>
<td style="text-align:left">💻 <code>:computer:</code></td>
<td style="text-align:left">📺 <code>:tv:</code></td>
</tr>
<tr>
<td style="text-align:left">📱 <code>:iphone:</code></td>
<td style="text-align:left">☎️ <code>:phone:</code></td>
<td style="text-align:left">☎️ <code>:telephone:</code></td>
</tr>
<tr>
<td style="text-align:left">📞 <code>:telephone_receiver:</code></td>
<td style="text-align:left">📟 <code>:pager:</code></td>
<td style="text-align:left">📠 <code>:fax:</code></td>
</tr>
<tr>
<td style="text-align:left">💽 <code>:minidisc:</code></td>
<td style="text-align:left">📼 <code>:vhs:</code></td>
<td style="text-align:left">🔉 <code>:sound:</code></td>
</tr>
<tr>
<td style="text-align:left">🔈 <code>:speaker:</code></td>
<td style="text-align:left">🔇 <code>:mute:</code></td>
<td style="text-align:left">📢 <code>:loudspeaker:</code></td>
</tr>
<tr>
<td style="text-align:left">📣 <code>:mega:</code></td>
<td style="text-align:left">⌛️ <code>:hourglass:</code></td>
<td style="text-align:left">⏳ <code>:hourglass_flowing_sand:</code></td>
</tr>
<tr>
<td style="text-align:left">⏰ <code>:alarm_clock:</code></td>
<td style="text-align:left">⌚️ <code>:watch:</code></td>
<td style="text-align:left">📻 <code>:radio:</code></td>
</tr>
<tr>
<td style="text-align:left">📡 <code>:satellite:</code></td>
<td style="text-align:left">➿ <code>:loop:</code></td>
<td style="text-align:left">🔍 <code>:mag:</code></td>
</tr>
<tr>
<td style="text-align:left">🔎 <code>:mag_right:</code></td>
<td style="text-align:left">🔓 <code>:unlock:</code></td>
<td style="text-align:left">🔒 <code>:lock:</code></td>
</tr>
<tr>
<td style="text-align:left">🔏 <code>:lock_with_ink_pen:</code></td>
<td style="text-align:left">🔐 <code>:closed_lock_with_key:</code></td>
<td style="text-align:left">🔑 <code>:key:</code></td>
</tr>
<tr>
<td style="text-align:left">💡 <code>:bulb:</code></td>
<td style="text-align:left">🔦 <code>:flashlight:</code></td>
<td style="text-align:left">🔆 <code>:high_brightness:</code></td>
</tr>
<tr>
<td style="text-align:left">🔅 <code>:low_brightness:</code></td>
<td style="text-align:left">🔌 <code>:electric_plug:</code></td>
<td style="text-align:left">🔋 <code>:battery:</code></td>
</tr>
<tr>
<td style="text-align:left">📲 <code>:calling:</code></td>
<td style="text-align:left">✉️ <code>:email:</code></td>
<td style="text-align:left">📫 <code>:mailbox:</code></td>
</tr>
<tr>
<td style="text-align:left">📮 <code>:postbox:</code></td>
<td style="text-align:left">🛀 <code>:bath:</code></td>
<td style="text-align:left">🛁 <code>:bathtub:</code></td>
</tr>
<tr>
<td style="text-align:left">🚿 <code>:shower:</code></td>
<td style="text-align:left">🚽 <code>:toilet:</code></td>
<td style="text-align:left">🔧 <code>:wrench:</code></td>
</tr>
<tr>
<td style="text-align:left">🔩 <code>:nut_and_bolt:</code></td>
<td style="text-align:left">🔨 <code>:hammer:</code></td>
<td style="text-align:left">💺 <code>:seat:</code></td>
</tr>
<tr>
<td style="text-align:left">💰 <code>:moneybag:</code></td>
<td style="text-align:left">💴 <code>:yen:</code></td>
<td style="text-align:left">💵 <code>:dollar:</code></td>
</tr>
<tr>
<td style="text-align:left">💷 <code>:pound:</code></td>
<td style="text-align:left">💶 <code>:euro:</code></td>
<td style="text-align:left">💳 <code>:credit_card:</code></td>
</tr>
<tr>
<td style="text-align:left">💸 <code>:money_with_wings:</code></td>
<td style="text-align:left">📧 <code>:e-mail:</code></td>
<td style="text-align:left">📥 <code>:inbox_tray:</code></td>
</tr>
<tr>
<td style="text-align:left">📤 <code>:outbox_tray:</code></td>
<td style="text-align:left">✉️ <code>:envelope:</code></td>
<td style="text-align:left">📨 <code>:incoming_envelope:</code></td>
</tr>
<tr>
<td style="text-align:left">📯 <code>:postal_horn:</code></td>
<td style="text-align:left">📪 <code>:mailbox_closed:</code></td>
<td style="text-align:left">📬 <code>:mailbox_with_mail:</code></td>
</tr>
<tr>
<td style="text-align:left">📭 <code>:mailbox_with_no_mail:</code></td>
<td style="text-align:left">🚪 <code>:door:</code></td>
<td style="text-align:left">🚬 <code>:smoking:</code></td>
</tr>
<tr>
<td style="text-align:left">💣 <code>:bomb:</code></td>
<td style="text-align:left">🔫 <code>:gun:</code></td>
<td style="text-align:left">🔪 <code>:hocho:</code></td>
</tr>
<tr>
<td style="text-align:left">💊 <code>:pill:</code></td>
<td style="text-align:left">💉 <code>:syringe:</code></td>
<td style="text-align:left">📄 <code>:page_facing_up:</code></td>
</tr>
<tr>
<td style="text-align:left">📃 <code>:page_with_curl:</code></td>
<td style="text-align:left">📑 <code>:bookmark_tabs:</code></td>
<td style="text-align:left">📊 <code>:bar_chart:</code></td>
</tr>
<tr>
<td style="text-align:left">📈 <code>:chart_with_upwards_trend:</code></td>
<td style="text-align:left">📉 <code>:chart_with_downwards_trend:</code></td>
<td style="text-align:left">📜 <code>:scroll:</code></td>
</tr>
<tr>
<td style="text-align:left">📋 <code>:clipboard:</code></td>
<td style="text-align:left">📆 <code>:calendar:</code></td>
<td style="text-align:left">📅 <code>:date:</code></td>
</tr>
<tr>
<td style="text-align:left">📇 <code>:card_index:</code></td>
<td style="text-align:left">📁 <code>:file_folder:</code></td>
<td style="text-align:left">📂 <code>:open_file_folder:</code></td>
</tr>
<tr>
<td style="text-align:left">✂️ <code>:scissors:</code></td>
<td style="text-align:left">📌 <code>:pushpin:</code></td>
<td style="text-align:left">📎 <code>:paperclip:</code></td>
</tr>
<tr>
<td style="text-align:left">✒️ <code>:black_nib:</code></td>
<td style="text-align:left">✏️ <code>:pencil2:</code></td>
<td style="text-align:left">📏 <code>:straight_ruler:</code></td>
</tr>
<tr>
<td style="text-align:left">📐 <code>:triangular_ruler:</code></td>
<td style="text-align:left">📕 <code>:closed_book:</code></td>
<td style="text-align:left">📗 <code>:green_book:</code></td>
</tr>
<tr>
<td style="text-align:left">📘 <code>:blue_book:</code></td>
<td style="text-align:left">📙 <code>:orange_book:</code></td>
<td style="text-align:left">📓 <code>:notebook:</code></td>
</tr>
<tr>
<td style="text-align:left">📔 <code>:notebook_with_decorative_cover:</code></td>
<td style="text-align:left">📒 <code>:ledger:</code></td>
<td style="text-align:left">📚 <code>:books:</code></td>
</tr>
<tr>
<td style="text-align:left">🔖 <code>:bookmark:</code></td>
<td style="text-align:left">📛 <code>:name_badge:</code></td>
<td style="text-align:left">🔬 <code>:microscope:</code></td>
</tr>
<tr>
<td style="text-align:left">🔭 <code>:telescope:</code></td>
<td style="text-align:left">📰 <code>:newspaper:</code></td>
<td style="text-align:left">🏈 <code>:football:</code></td>
</tr>
<tr>
<td style="text-align:left">🏀 <code>:basketball:</code></td>
<td style="text-align:left">⚽️ <code>:soccer:</code></td>
<td style="text-align:left">⚾️ <code>:baseball:</code></td>
</tr>
<tr>
<td style="text-align:left">🎾 <code>:tennis:</code></td>
<td style="text-align:left">🎱 <code>:8ball:</code></td>
<td style="text-align:left">🏉 <code>:rugby_football:</code></td>
</tr>
<tr>
<td style="text-align:left">🎳 <code>:bowling:</code></td>
<td style="text-align:left">⛳️ <code>:golf:</code></td>
<td style="text-align:left">🚵 <code>:mountain_bicyclist:</code></td>
</tr>
<tr>
<td style="text-align:left">🚴 <code>:bicyclist:</code></td>
<td style="text-align:left">🏇 <code>:horse_racing:</code></td>
<td style="text-align:left">🏂 <code>:snowboarder:</code></td>
</tr>
<tr>
<td style="text-align:left">🏊 <code>:swimmer:</code></td>
<td style="text-align:left">🏄 <code>:surfer:</code></td>
<td style="text-align:left">🎿 <code>:ski:</code></td>
</tr>
<tr>
<td style="text-align:left">♠️ <code>:spades:</code></td>
<td style="text-align:left">♥️ <code>:hearts:</code></td>
<td style="text-align:left">♣️ <code>:clubs:</code></td>
</tr>
<tr>
<td style="text-align:left">♦️ <code>:diamonds:</code></td>
<td style="text-align:left">💎 <code>:gem:</code></td>
<td style="text-align:left">💍 <code>:ring:</code></td>
</tr>
<tr>
<td style="text-align:left">🏆 <code>:trophy:</code></td>
<td style="text-align:left">🎼 <code>:musical_score:</code></td>
<td style="text-align:left">🎹 <code>:musical_keyboard:</code></td>
</tr>
<tr>
<td style="text-align:left">🎻 <code>:violin:</code></td>
<td style="text-align:left">👾 <code>:space_invader:</code></td>
<td style="text-align:left">🎮 <code>:video_game:</code></td>
</tr>
<tr>
<td style="text-align:left">🃏 <code>:black_joker:</code></td>
<td style="text-align:left">🎴 <code>:flower_playing_cards:</code></td>
<td style="text-align:left">🎲 <code>:game_die:</code></td>
</tr>
<tr>
<td style="text-align:left">🎯 <code>:dart:</code></td>
<td style="text-align:left">🀄️ <code>:mahjong:</code></td>
<td style="text-align:left">🎬 <code>:clapper:</code></td>
</tr>
<tr>
<td style="text-align:left">📝 <code>:memo:</code></td>
<td style="text-align:left">📝 <code>:pencil:</code></td>
<td style="text-align:left">📖 <code>:book:</code></td>
</tr>
<tr>
<td style="text-align:left">🎨 <code>:art:</code></td>
<td style="text-align:left">🎤 <code>:microphone:</code></td>
<td style="text-align:left">🎧 <code>:headphones:</code></td>
</tr>
<tr>
<td style="text-align:left">🎺 <code>:trumpet:</code></td>
<td style="text-align:left">🎷 <code>:saxophone:</code></td>
<td style="text-align:left">🎸 <code>:guitar:</code></td>
</tr>
<tr>
<td style="text-align:left">👞 <code>:shoe:</code></td>
<td style="text-align:left">👡 <code>:sandal:</code></td>
<td style="text-align:left">👠 <code>:high_heel:</code></td>
</tr>
<tr>
<td style="text-align:left">💄 <code>:lipstick:</code></td>
<td style="text-align:left">👢 <code>:boot:</code></td>
<td style="text-align:left">👕 <code>:shirt:</code></td>
</tr>
<tr>
<td style="text-align:left">👕 <code>:tshirt:</code></td>
<td style="text-align:left">👔 <code>:necktie:</code></td>
<td style="text-align:left">👚 <code>:womans_clothes:</code></td>
</tr>
<tr>
<td style="text-align:left">👗 <code>:dress:</code></td>
<td style="text-align:left">🎽 <code>:running_shirt_with_sash:</code></td>
<td style="text-align:left">👖 <code>:jeans:</code></td>
</tr>
<tr>
<td style="text-align:left">👘 <code>:kimono:</code></td>
<td style="text-align:left">👙 <code>:bikini:</code></td>
<td style="text-align:left">🎀 <code>:ribbon:</code></td>
</tr>
<tr>
<td style="text-align:left">🎩 <code>:tophat:</code></td>
<td style="text-align:left">👑 <code>:crown:</code></td>
<td style="text-align:left">👒 <code>:womans_hat:</code></td>
</tr>
<tr>
<td style="text-align:left">👞 <code>:mans_shoe:</code></td>
<td style="text-align:left">🌂 <code>:closed_umbrella:</code></td>
<td style="text-align:left">💼 <code>:briefcase:</code></td>
</tr>
<tr>
<td style="text-align:left">👜 <code>:handbag:</code></td>
<td style="text-align:left">👝 <code>:pouch:</code></td>
<td style="text-align:left">👛 <code>:purse:</code></td>
</tr>
<tr>
<td style="text-align:left">👓 <code>:eyeglasses:</code></td>
<td style="text-align:left">🎣 <code>:fishing_pole_and_fish:</code></td>
<td style="text-align:left">☕️ <code>:coffee:</code></td>
</tr>
<tr>
<td style="text-align:left">🍵 <code>:tea:</code></td>
<td style="text-align:left">🍶 <code>:sake:</code></td>
<td style="text-align:left">🍼 <code>:baby_bottle:</code></td>
</tr>
<tr>
<td style="text-align:left">🍺 <code>:beer:</code></td>
<td style="text-align:left">🍻 <code>:beers:</code></td>
<td style="text-align:left">🍸 <code>:cocktail:</code></td>
</tr>
<tr>
<td style="text-align:left">🍹 <code>:tropical_drink:</code></td>
<td style="text-align:left">🍷 <code>:wine_glass:</code></td>
<td style="text-align:left">🍴 <code>:fork_and_knife:</code></td>
</tr>
<tr>
<td style="text-align:left">🍕 <code>:pizza:</code></td>
<td style="text-align:left">🍔 <code>:hamburger:</code></td>
<td style="text-align:left">🍟 <code>:fries:</code></td>
</tr>
<tr>
<td style="text-align:left">🍗 <code>:poultry_leg:</code></td>
<td style="text-align:left">🍖 <code>:meat_on_bone:</code></td>
<td style="text-align:left">🍝 <code>:spaghetti:</code></td>
</tr>
<tr>
<td style="text-align:left">🍛 <code>:curry:</code></td>
<td style="text-align:left">🍤 <code>:fried_shrimp:</code></td>
<td style="text-align:left">🍱 <code>:bento:</code></td>
</tr>
<tr>
<td style="text-align:left">🍣 <code>:sushi:</code></td>
<td style="text-align:left">🍥 <code>:fish_cake:</code></td>
<td style="text-align:left">🍙 <code>:rice_ball:</code></td>
</tr>
<tr>
<td style="text-align:left">🍘 <code>:rice_cracker:</code></td>
<td style="text-align:left">🍚 <code>:rice:</code></td>
<td style="text-align:left">🍜 <code>:ramen:</code></td>
</tr>
<tr>
<td style="text-align:left">🍲 <code>:stew:</code></td>
<td style="text-align:left">🍢 <code>:oden:</code></td>
<td style="text-align:left">🍡 <code>:dango:</code></td>
</tr>
<tr>
<td style="text-align:left">🥚 <code>:egg:</code></td>
<td style="text-align:left">🍞 <code>:bread:</code></td>
<td style="text-align:left">🍩 <code>:doughnut:</code></td>
</tr>
<tr>
<td style="text-align:left">🍮 <code>:custard:</code></td>
<td style="text-align:left">🍦 <code>:icecream:</code></td>
<td style="text-align:left">🍨 <code>:ice_cream:</code></td>
</tr>
<tr>
<td style="text-align:left">🍧 <code>:shaved_ice:</code></td>
<td style="text-align:left">🎂 <code>:birthday:</code></td>
<td style="text-align:left">🍰 <code>:cake:</code></td>
</tr>
<tr>
<td style="text-align:left">🍪 <code>:cookie:</code></td>
<td style="text-align:left">🍫 <code>:chocolate_bar:</code></td>
<td style="text-align:left">🍬 <code>:candy:</code></td>
</tr>
<tr>
<td style="text-align:left">🍭 <code>:lollipop:</code></td>
<td style="text-align:left">🍯 <code>:honey_pot:</code></td>
<td style="text-align:left">🍎 <code>:apple:</code></td>
</tr>
<tr>
<td style="text-align:left">🍏 <code>:green_apple:</code></td>
<td style="text-align:left">🍊 <code>:tangerine:</code></td>
<td style="text-align:left">🍋 <code>:lemon:</code></td>
</tr>
<tr>
<td style="text-align:left">🍒 <code>:cherries:</code></td>
<td style="text-align:left">🍇 <code>:grapes:</code></td>
<td style="text-align:left">🍉 <code>:watermelon:</code></td>
</tr>
<tr>
<td style="text-align:left">🍓 <code>:strawberry:</code></td>
<td style="text-align:left">🍑 <code>:peach:</code></td>
<td style="text-align:left">🍈 <code>:melon:</code></td>
</tr>
<tr>
<td style="text-align:left">🍌 <code>:banana:</code></td>
<td style="text-align:left">🍐 <code>:pear:</code></td>
<td style="text-align:left">🍍 <code>:pineapple:</code></td>
</tr>
<tr>
<td style="text-align:left">🍠 <code>:sweet_potato:</code></td>
<td style="text-align:left">🍆 <code>:eggplant:</code></td>
<td style="text-align:left">🍅 <code>:tomato:</code></td>
</tr>
<tr>
<td style="text-align:left">🌽 <code>:corn:</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h1 id="places"><a class="markdownIt-Anchor" href="#places"></a> Places</h1>
<table>
<thead>
<tr>
<th style="text-align:left">🏠 <code>:house:</code></th>
<th style="text-align:left">🏡 <code>:house_with_garden:</code></th>
<th style="text-align:left">🏫 <code>:school:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">🏢 <code>:office:</code></td>
<td style="text-align:left">🏣 <code>:post_office:</code></td>
<td style="text-align:left">🏥 <code>:hospital:</code></td>
</tr>
<tr>
<td style="text-align:left">🏦 <code>:bank:</code></td>
<td style="text-align:left">🏪 <code>:convenience_store:</code></td>
<td style="text-align:left">🏩 <code>:love_hotel:</code></td>
</tr>
<tr>
<td style="text-align:left">🏨 <code>:hotel:</code></td>
<td style="text-align:left">💒 <code>:wedding:</code></td>
<td style="text-align:left">⛪️ <code>:church:</code></td>
</tr>
<tr>
<td style="text-align:left">🏬 <code>:department_store:</code></td>
<td style="text-align:left">🏤 <code>:european_post_office:</code></td>
<td style="text-align:left">🌇 <code>:city_sunrise:</code></td>
</tr>
<tr>
<td style="text-align:left">🌆 <code>:city_sunset:</code></td>
<td style="text-align:left">🏯 <code>:japanese_castle:</code></td>
<td style="text-align:left">🏰 <code>:european_castle:</code></td>
</tr>
<tr>
<td style="text-align:left">⛺️ <code>:tent:</code></td>
<td style="text-align:left">🏭 <code>:factory:</code></td>
<td style="text-align:left">🗼 <code>:tokyo_tower:</code></td>
</tr>
<tr>
<td style="text-align:left">🗾 <code>:japan:</code></td>
<td style="text-align:left">🗻 <code>:mount_fuji:</code></td>
<td style="text-align:left">🌄 <code>:sunrise_over_mountains:</code></td>
</tr>
<tr>
<td style="text-align:left">🌅 <code>:sunrise:</code></td>
<td style="text-align:left">🌠 <code>:stars:</code></td>
<td style="text-align:left">🗽 <code>:statue_of_liberty:</code></td>
</tr>
<tr>
<td style="text-align:left">🌉 <code>:bridge_at_night:</code></td>
<td style="text-align:left">🎠 <code>:carousel_horse:</code></td>
<td style="text-align:left">🌈 <code>:rainbow:</code></td>
</tr>
<tr>
<td style="text-align:left">🎡 <code>:ferris_wheel:</code></td>
<td style="text-align:left">⛲️ <code>:fountain:</code></td>
<td style="text-align:left">🎢 <code>:roller_coaster:</code></td>
</tr>
<tr>
<td style="text-align:left">🚢 <code>:ship:</code></td>
<td style="text-align:left">🚤 <code>:speedboat:</code></td>
<td style="text-align:left">⛵️ <code>:boat:</code></td>
</tr>
<tr>
<td style="text-align:left">⛵️ <code>:sailboat:</code></td>
<td style="text-align:left">🚣 <code>:rowboat:</code></td>
<td style="text-align:left">⚓️ <code>:anchor:</code></td>
</tr>
<tr>
<td style="text-align:left">🚀 <code>:rocket:</code></td>
<td style="text-align:left">✈️ <code>:airplane:</code></td>
<td style="text-align:left">🚁 <code>:helicopter:</code></td>
</tr>
<tr>
<td style="text-align:left">🚂 <code>:steam_locomotive:</code></td>
<td style="text-align:left">🚊 <code>:tram:</code></td>
<td style="text-align:left">🚞 <code>:mountain_railway:</code></td>
</tr>
<tr>
<td style="text-align:left">🚲 <code>:bike:</code></td>
<td style="text-align:left">🚡 <code>:aerial_tramway:</code></td>
<td style="text-align:left">🚟 <code>:suspension_railway:</code></td>
</tr>
<tr>
<td style="text-align:left">🚠 <code>:mountain_cableway:</code></td>
<td style="text-align:left">🚜 <code>:tractor:</code></td>
<td style="text-align:left">🚙 <code>:blue_car:</code></td>
</tr>
<tr>
<td style="text-align:left">🚘 <code>:oncoming_automobile:</code></td>
<td style="text-align:left">🚗 <code>:car:</code></td>
<td style="text-align:left">🚗 <code>:red_car:</code></td>
</tr>
<tr>
<td style="text-align:left">🚕 <code>:taxi:</code></td>
<td style="text-align:left">🚖 <code>:oncoming_taxi:</code></td>
<td style="text-align:left">🚛 <code>:articulated_lorry:</code></td>
</tr>
<tr>
<td style="text-align:left">🚌 <code>:bus:</code></td>
<td style="text-align:left">🚍 <code>:oncoming_bus:</code></td>
<td style="text-align:left">🚨 <code>:rotating_light:</code></td>
</tr>
<tr>
<td style="text-align:left">🚓 <code>:police_car:</code></td>
<td style="text-align:left">🚔 <code>:oncoming_police_car:</code></td>
<td style="text-align:left">🚒 <code>:fire_engine:</code></td>
</tr>
<tr>
<td style="text-align:left">🚑 <code>:ambulance:</code></td>
<td style="text-align:left">🚐 <code>:minibus:</code></td>
<td style="text-align:left">🚚 <code>:truck:</code></td>
</tr>
<tr>
<td style="text-align:left">🚋 <code>:train:</code></td>
<td style="text-align:left">🚉 <code>:station:</code></td>
<td style="text-align:left">🚆 <code>:train2:</code></td>
</tr>
<tr>
<td style="text-align:left">🚅 <code>:bullettrain_front:</code></td>
<td style="text-align:left">🚄 <code>:bullettrain_side:</code></td>
<td style="text-align:left">🚈 <code>:light_rail:</code></td>
</tr>
<tr>
<td style="text-align:left">🚝 <code>:monorail:</code></td>
<td style="text-align:left">🚃 <code>:railway_car:</code></td>
<td style="text-align:left">🚎 <code>:trolleybus:</code></td>
</tr>
<tr>
<td style="text-align:left">🎫 <code>:ticket:</code></td>
<td style="text-align:left">⛽️ <code>:fuelpump:</code></td>
<td style="text-align:left">🚦 <code>:vertical_traffic_light:</code></td>
</tr>
<tr>
<td style="text-align:left">🚥 <code>:traffic_light:</code></td>
<td style="text-align:left">⚠️ <code>:warning:</code></td>
<td style="text-align:left">🚧 <code>:construction:</code></td>
</tr>
<tr>
<td style="text-align:left">🔰 <code>:beginner:</code></td>
<td style="text-align:left">🏧 <code>:atm:</code></td>
<td style="text-align:left">🎰 <code>:slot_machine:</code></td>
</tr>
<tr>
<td style="text-align:left">🚏 <code>:busstop:</code></td>
<td style="text-align:left">💈 <code>:barber:</code></td>
<td style="text-align:left">♨️ <code>:hotsprings:</code></td>
</tr>
<tr>
<td style="text-align:left">🏁 <code>:checkered_flag:</code></td>
<td style="text-align:left">🎌 <code>:crossed_flags:</code></td>
<td style="text-align:left">🏮 <code>:izakaya_lantern:</code></td>
</tr>
<tr>
<td style="text-align:left">🗿 <code>:moyai:</code></td>
<td style="text-align:left">🎪 <code>:circus_tent:</code></td>
<td style="text-align:left">🎭 <code>:performing_arts:</code></td>
</tr>
<tr>
<td style="text-align:left">📍 <code>:round_pushpin:</code></td>
<td style="text-align:left">🚩 <code>:triangular_flag_on_post:</code></td>
<td style="text-align:left">🇯🇵 <code>:jp:</code></td>
</tr>
<tr>
<td style="text-align:left">🇰🇷 <code>:kr:</code></td>
<td style="text-align:left">🇨🇳 <code>:cn:</code></td>
<td style="text-align:left">🇺🇸 <code>:us:</code></td>
</tr>
<tr>
<td style="text-align:left">🇫🇷 <code>:fr:</code></td>
<td style="text-align:left">🇪🇸 <code>:es:</code></td>
<td style="text-align:left">🇮🇹 <code>:it:</code></td>
</tr>
<tr>
<td style="text-align:left">🇷🇺 <code>:ru:</code></td>
<td style="text-align:left">🇬🇧 <code>:gb:</code></td>
<td style="text-align:left">🇬🇧 <code>:uk:</code></td>
</tr>
<tr>
<td style="text-align:left">🇩🇪 <code>:de:</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<h1 id="symbols"><a class="markdownIt-Anchor" href="#symbols"></a> Symbols</h1>
<table>
<thead>
<tr>
<th style="text-align:left">1️⃣ <code>:one:</code></th>
<th style="text-align:left">2️⃣ <code>:two:</code></th>
<th style="text-align:left">3️⃣ <code>:three:</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">4️⃣ <code>:four:</code></td>
<td style="text-align:left">5️⃣ <code>:five:</code></td>
<td style="text-align:left">6️⃣ <code>:six:</code></td>
</tr>
<tr>
<td style="text-align:left">7️⃣ <code>:seven:</code></td>
<td style="text-align:left">8️⃣ <code>:eight:</code></td>
<td style="text-align:left">9️⃣ <code>:nine:</code></td>
</tr>
<tr>
<td style="text-align:left">🔟 <code>:keycap_ten:</code></td>
<td style="text-align:left">🔢 <code>:1234:</code></td>
<td style="text-align:left">0️⃣ <code>:zero:</code></td>
</tr>
<tr>
<td style="text-align:left">#️⃣ <code>:hash:</code></td>
<td style="text-align:left">🔣 <code>:symbols:</code></td>
<td style="text-align:left">◀️ <code>:arrow_backward:</code></td>
</tr>
<tr>
<td style="text-align:left">⬇️ <code>:arrow_down:</code></td>
<td style="text-align:left">▶️ <code>:arrow_forward:</code></td>
<td style="text-align:left">⬅️ <code>:arrow_left:</code></td>
</tr>
<tr>
<td style="text-align:left">🔠 <code>:capital_abcd:</code></td>
<td style="text-align:left">🔡 <code>:abcd:</code></td>
<td style="text-align:left">🔤 <code>:abc:</code></td>
</tr>
<tr>
<td style="text-align:left">↙️ <code>:arrow_lower_left:</code></td>
<td style="text-align:left">↘️ <code>:arrow_lower_right:</code></td>
<td style="text-align:left">➡️ <code>:arrow_right:</code></td>
</tr>
<tr>
<td style="text-align:left">⬆️ <code>:arrow_up:</code></td>
<td style="text-align:left">↖️ <code>:arrow_upper_left:</code></td>
<td style="text-align:left">↗️ <code>:arrow_upper_right:</code></td>
</tr>
<tr>
<td style="text-align:left">⏬ <code>:arrow_double_down:</code></td>
<td style="text-align:left">⏫ <code>:arrow_double_up:</code></td>
<td style="text-align:left">🔽 <code>:arrow_down_small:</code></td>
</tr>
<tr>
<td style="text-align:left">⤵️ <code>:arrow_heading_down:</code></td>
<td style="text-align:left">⤴️ <code>:arrow_heading_up:</code></td>
<td style="text-align:left">↩️<code>:leftwards_arrow_with_hook:</code></td>
</tr>
<tr>
<td style="text-align:left">↪️ <code>:arrow_right_hook:</code></td>
<td style="text-align:left">↔️ <code>:left_right_arrow:</code></td>
<td style="text-align:left">↕️ <code>:arrow_up_down:</code></td>
</tr>
<tr>
<td style="text-align:left">🔼 <code>:arrow_up_small:</code></td>
<td style="text-align:left">🔃 <code>:arrows_clockwise:</code></td>
<td style="text-align:left">🔄 <code>:arrows_counterclockwise:</code></td>
</tr>
<tr>
<td style="text-align:left">⏪ <code>:rewind:</code></td>
<td style="text-align:left">⏩ <code>:fast_forward:</code></td>
<td style="text-align:left">ℹ️ <code>:information_source:</code></td>
</tr>
<tr>
<td style="text-align:left">🆗 <code>:ok:</code></td>
<td style="text-align:left">🔀 <code>:twisted_rightwards_arrows:</code></td>
<td style="text-align:left">🔁 <code>:repeat:</code></td>
</tr>
<tr>
<td style="text-align:left">🔂 <code>:repeat_one:</code></td>
<td style="text-align:left">🆕 <code>:new:</code></td>
<td style="text-align:left">🔝 <code>:top:</code></td>
</tr>
<tr>
<td style="text-align:left">🆙 <code>:up:</code></td>
<td style="text-align:left">🆒 <code>:cool:</code></td>
<td style="text-align:left">🆓 <code>:free:</code></td>
</tr>
<tr>
<td style="text-align:left">🆖 <code>:ng:</code></td>
<td style="text-align:left">🎦 <code>:cinema:</code></td>
<td style="text-align:left">🈁 <code>:koko:</code></td>
</tr>
<tr>
<td style="text-align:left">📶 <code>:signal_strength:</code></td>
<td style="text-align:left">🈹 <code>:u5272:</code></td>
<td style="text-align:left">🈴 <code>:u5408:</code></td>
</tr>
<tr>
<td style="text-align:left">🈺 <code>:u55b6:</code></td>
<td style="text-align:left">🈯️ <code>:u6307:</code></td>
<td style="text-align:left">🈷️ <code>:u6708:</code></td>
</tr>
<tr>
<td style="text-align:left">🈶 <code>:u6709:</code></td>
<td style="text-align:left">🈵 <code>:u6e80:</code></td>
<td style="text-align:left">🈚️ <code>:u7121:</code></td>
</tr>
<tr>
<td style="text-align:left">🈸 <code>:u7533:</code></td>
<td style="text-align:left">🈳 <code>:u7a7a:</code></td>
<td style="text-align:left">🈲 <code>:u7981:</code></td>
</tr>
<tr>
<td style="text-align:left">🈂️ <code>:sa:</code></td>
<td style="text-align:left">🚻 <code>:restroom:</code></td>
<td style="text-align:left">🚹 <code>:mens:</code></td>
</tr>
<tr>
<td style="text-align:left">🚺 <code>:womens:</code></td>
<td style="text-align:left">🚼 <code>:baby_symbol:</code></td>
<td style="text-align:left">🚭 <code>:no_smoking:</code></td>
</tr>
<tr>
<td style="text-align:left">🅿️ <code>:parking:</code></td>
<td style="text-align:left">♿️ <code>:wheelchair:</code></td>
<td style="text-align:left">🚇 <code>:metro:</code></td>
</tr>
<tr>
<td style="text-align:left">🛄 <code>:baggage_claim:</code></td>
<td style="text-align:left">🉑 <code>:accept:</code></td>
<td style="text-align:left">🚾 <code>:wc:</code></td>
</tr>
<tr>
<td style="text-align:left">🚰 <code>:potable_water:</code></td>
<td style="text-align:left">🚮 <code>:put_litter_in_its_place:</code></td>
<td style="text-align:left">㊙️ <code>:secret:</code></td>
</tr>
<tr>
<td style="text-align:left">㊗️ <code>:congratulations:</code></td>
<td style="text-align:left">Ⓜ️ <code>:m:</code></td>
<td style="text-align:left">🛂 <code>:passport_control:</code></td>
</tr>
<tr>
<td style="text-align:left">🛅 <code>:left_luggage:</code></td>
<td style="text-align:left">🛃 <code>:customs:</code></td>
<td style="text-align:left">🉐 <code>:ideograph_advantage:</code></td>
</tr>
<tr>
<td style="text-align:left">🆑 <code>:cl:</code></td>
<td style="text-align:left">🆘 <code>:sos:</code></td>
<td style="text-align:left">🆔 <code>:id:</code></td>
</tr>
<tr>
<td style="text-align:left">🚫 <code>:no_entry_sign:</code></td>
<td style="text-align:left">🔞 <code>:underage:</code></td>
<td style="text-align:left">📵 <code>:no_mobile_phones:</code></td>
</tr>
<tr>
<td style="text-align:left">🚯 <code>:do_not_litter:</code></td>
<td style="text-align:left">🚱 <code>:non-potable_water:</code></td>
<td style="text-align:left">🚳 <code>:no_bicycles:</code></td>
</tr>
<tr>
<td style="text-align:left">🚷 <code>:no_pedestrians:</code></td>
<td style="text-align:left">🚸 <code>:children_crossing:</code></td>
<td style="text-align:left">⛔️ <code>:no_entry:</code></td>
</tr>
<tr>
<td style="text-align:left">✳️ <code>:eight_spoked_asterisk:</code></td>
<td style="text-align:left">✴️ <code>:eight_pointed_black_star:</code></td>
<td style="text-align:left">💟 <code>:heart_decoration:</code></td>
</tr>
<tr>
<td style="text-align:left">🆚 <code>:vs:</code></td>
<td style="text-align:left">📳 <code>:vibration_mode:</code></td>
<td style="text-align:left">📴 <code>:mobile_phone_off:</code></td>
</tr>
<tr>
<td style="text-align:left">💹 <code>:chart:</code></td>
<td style="text-align:left">💱 <code>:currency_exchange:</code></td>
<td style="text-align:left">♈️ <code>:aries:</code></td>
</tr>
<tr>
<td style="text-align:left">♉️ <code>:taurus:</code></td>
<td style="text-align:left">♊️ <code>:gemini:</code></td>
<td style="text-align:left">♋️ <code>:cancer:</code></td>
</tr>
<tr>
<td style="text-align:left">♌️ <code>:leo:</code></td>
<td style="text-align:left">♍️ <code>:virgo:</code></td>
<td style="text-align:left">♎️ <code>:libra:</code></td>
</tr>
<tr>
<td style="text-align:left">♏️ <code>:scorpius:</code></td>
<td style="text-align:left">♐️ <code>:sagittarius:</code></td>
<td style="text-align:left">♑️ <code>:capricorn:</code></td>
</tr>
<tr>
<td style="text-align:left">♒️ <code>:aquarius:</code></td>
<td style="text-align:left">♓️ <code>:pisces:</code></td>
<td style="text-align:left">⛎ <code>:ophiuchus:</code></td>
</tr>
<tr>
<td style="text-align:left">🔯 <code>:six_pointed_star:</code></td>
<td style="text-align:left">❎<code>:negative_squared_cross_mark:</code></td>
<td style="text-align:left">🅰️ <code>:a:</code></td>
</tr>
<tr>
<td style="text-align:left">🅱️ <code>:b:</code></td>
<td style="text-align:left">🆎 <code>:ab:</code></td>
<td style="text-align:left">🅾️ <code>:o2:</code></td>
</tr>
<tr>
<td style="text-align:left">💠<code>:diamond_shape_with_a_dot_inside:</code></td>
<td style="text-align:left">♻️ <code>:recycle:</code></td>
<td style="text-align:left">🔚 <code>:end:</code></td>
</tr>
<tr>
<td style="text-align:left">🔛 <code>:on:</code></td>
<td style="text-align:left">🔜 <code>:soon:</code></td>
<td style="text-align:left">🕐 <code>:clock1:</code></td>
</tr>
<tr>
<td style="text-align:left">🕜 <code>:clock130:</code></td>
<td style="text-align:left">🕙 <code>:clock10:</code></td>
<td style="text-align:left">🕥 <code>:clock1030:</code></td>
</tr>
<tr>
<td style="text-align:left">🕚 <code>:clock11:</code></td>
<td style="text-align:left">🕦 <code>:clock1130:</code></td>
<td style="text-align:left">🕛 <code>:clock12:</code></td>
</tr>
<tr>
<td style="text-align:left">🕧 <code>:clock1230:</code></td>
<td style="text-align:left">🕑 <code>:clock2:</code></td>
<td style="text-align:left">🕝 <code>:clock230:</code></td>
</tr>
<tr>
<td style="text-align:left">🕒 <code>:clock3:</code></td>
<td style="text-align:left">🕞 <code>:clock330:</code></td>
<td style="text-align:left">🕓 <code>:clock4:</code></td>
</tr>
<tr>
<td style="text-align:left">🕟 <code>:clock430:</code></td>
<td style="text-align:left">🕔 <code>:clock5:</code></td>
<td style="text-align:left">🕠 <code>:clock530:</code></td>
</tr>
<tr>
<td style="text-align:left">🕕 <code>:clock6:</code></td>
<td style="text-align:left">🕡 <code>:clock630:</code></td>
<td style="text-align:left">🕖 <code>:clock7:</code></td>
</tr>
<tr>
<td style="text-align:left">🕢 <code>:clock730:</code></td>
<td style="text-align:left">🕗 <code>:clock8:</code></td>
<td style="text-align:left">🕣 <code>:clock830:</code></td>
</tr>
<tr>
<td style="text-align:left">🕘 <code>:clock9:</code></td>
<td style="text-align:left">🕤 <code>:clock930:</code></td>
<td style="text-align:left">💲 <code>:heavy_dollar_sign:</code></td>
</tr>
<tr>
<td style="text-align:left">©️ <code>:copyright:</code></td>
<td style="text-align:left">®️ <code>:registered:</code></td>
<td style="text-align:left">™️ <code>:tm:</code></td>
</tr>
<tr>
<td style="text-align:left">❌ <code>:x:</code></td>
<td style="text-align:left">❗️ <code>:heavy_exclamation_mark:</code></td>
<td style="text-align:left">‼️ <code>:bangbang:</code></td>
</tr>
<tr>
<td style="text-align:left">⁉️ <code>:interrobang:</code></td>
<td style="text-align:left">⭕️ <code>:o:</code></td>
<td style="text-align:left">✖️ <code>:heavy_multiplication_x:</code></td>
</tr>
<tr>
<td style="text-align:left">➕ <code>:heavy_plus_sign:</code></td>
<td style="text-align:left">➖ <code>:heavy_minus_sign:</code></td>
<td style="text-align:left">➗ <code>:heavy_division_sign:</code></td>
</tr>
<tr>
<td style="text-align:left">💮 <code>:white_flower:</code></td>
<td style="text-align:left">💯 <code>:100:</code></td>
<td style="text-align:left">✔️ <code>:heavy_check_mark:</code></td>
</tr>
<tr>
<td style="text-align:left">☑️ <code>:ballot_box_with_check:</code></td>
<td style="text-align:left">🔘 <code>:radio_button:</code></td>
<td style="text-align:left">🔗 <code>:link:</code></td>
</tr>
<tr>
<td style="text-align:left">➰ <code>:curly_loop:</code></td>
<td style="text-align:left">〰️ <code>:wavy_dash:</code></td>
<td style="text-align:left">〽️ <code>:part_alternation_mark:</code></td>
</tr>
<tr>
<td style="text-align:left">🔱 <code>:trident:</code></td>
<td style="text-align:left">:black_square: <code>:black_square:</code></td>
<td style="text-align:left">:white_square: <code>:white_square:</code></td>
</tr>
<tr>
<td style="text-align:left">✅ <code>:white_check_mark:</code></td>
<td style="text-align:left">🔲 <code>:black_square_button:</code></td>
<td style="text-align:left">🔳 <code>:white_square_button:</code></td>
</tr>
<tr>
<td style="text-align:left">⚫️ <code>:black_circle:</code></td>
<td style="text-align:left">⚪️ <code>:white_circle:</code></td>
<td style="text-align:left">🔴 <code>:red_circle:</code></td>
</tr>
<tr>
<td style="text-align:left">🔵 <code>:large_blue_circle:</code></td>
<td style="text-align:left">🔷 <code>:large_blue_diamond:</code></td>
<td style="text-align:left">🔶 <code>:large_orange_diamond:</code></td>
</tr>
<tr>
<td style="text-align:left">🔹 <code>:small_blue_diamond:</code></td>
<td style="text-align:left">🔸 <code>:small_orange_diamond:</code></td>
<td style="text-align:left">🔺 <code>:small_red_triangle:</code></td>
</tr>
<tr>
<td style="text-align:left">🔻 <code>:small_red_triangle_down:</code></td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>设计美化</category>
      </categories>
  </entry>
  <entry>
    <title>NodeJs和vue安装与配置</title>
    <url>/2021/07/24/NodeJs%E5%92%8Cvue%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="nodejs和vue安装与配置"><a class="markdownIt-Anchor" href="#nodejs和vue安装与配置"></a> NodeJs和vue安装与配置</h1>
<h2 id="1-安装nodejs环境"><a class="markdownIt-Anchor" href="#1-安装nodejs环境"></a> 1、安装NodeJs环境</h2>
<p><a href="https://nodejs.org/en/download/">官网下载地址</a></p>
<p>1、下载msi安装文件并安装至个人开发环境目录，打开D:\Environment\NodeJs目录，新建node_global和node_cache文件夹。</p>
<p>2、管理员权限打开cmd命令行窗口，输入如下命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32&gt;npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\Environment\NodeJs\node_global&quot;</span></span><br><span class="line">C:\Windows\system32&gt;npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\Environment\NodeJs\node_cache&quot;</span></span><br></pre></td></tr></table></figure>
<p>3、配置环境变量</p>
<p>(1)系统环境变量Path新增：D:\Environment\NodeJs\node_global</p>
<p><img src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/image-20201204200902375.png" alt="" /></p>
<p>(2)新建环境变量Node_Path。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/image-20201204201236323.png" alt="" /></p>
<p>4、配置淘宝镜像源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="comment">#后面就可以用cnpm代替npm命令了。</span></span><br><span class="line"><span class="comment">#另外需要重新开启命令窗口cnpm才能生效。</span></span><br></pre></td></tr></table></figure>
<h2 id="2-vue安装"><a class="markdownIt-Anchor" href="#2-vue安装"></a> 2、vue安装</h2>
<p>1、输入如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32&gt;cnpm install --global vue-cli</span><br></pre></td></tr></table></figure>
<p>2、全局配置express框架</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Windows\system32&gt;cnpm install express -g</span><br><span class="line">C:\Windows\system32&gt;cnpm install -g express-generator</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端相关知识</category>
      </categories>
      <tags>
        <tag>NodeJs</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL免安装配置及Navicat破解安装</title>
    <url>/2021/07/24/MySQL%E5%85%8D%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8ANavicat%E7%A0%B4%E8%A7%A3%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="mysql免安装配置及navicat破解安装"><a class="markdownIt-Anchor" href="#mysql免安装配置及navicat破解安装"></a> MySQL免安装配置及Navicat破解安装</h1>
<h2 id="1-mysql免安装配置"><a class="markdownIt-Anchor" href="#1-mysql免安装配置"></a> 1、MySQL免安装配置</h2>
<p><a href="https://dev.mysql.com/downloads/mysql/">MySQL服务器官网下载链接</a></p>
<p>1、下载安装文件，解压至个人开发环境目录。</p>
<p>2、在D:\Environment\mysql-8.0.22目录下新建my.ini文件，文件内容如下。</p>
<p>（在文件资源管理器点击查看，勾选显示后缀，然后新建my.ini）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"><span class="comment"># 设置mysql的安装目录</span></span><br><span class="line">basedir=D:\mysql-5.7.22-winx64</span><br><span class="line"><span class="comment"># 设置mysql数据库的数据的存放目录，必须是data</span></span><br><span class="line">datadir=D:\mysql-5.7.22-winx64\data</span><br><span class="line"><span class="comment"># mysql端口</span></span><br><span class="line">port=3306</span><br><span class="line"><span class="comment"># 字符集</span></span><br><span class="line">character_set_server=utf8</span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure>
<p>3、管理员下打开cmd命令窗口，进入D:\Environment\mysql-8.0.22\bin目录。执行如下命令。出现service successfully installed。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld -install mysql</span><br></pre></td></tr></table></figure>
<p>4、初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure>
<p>初始化后出现data目录。</p>
<p>5、启动服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure>
<p>6、登录mysql，默认密码为空，直接回车。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>7、修改密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">alter user <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-navicat破解安装"><a class="markdownIt-Anchor" href="#2-navicat破解安装"></a> 2、Navicat破解安装</h2>
<p>1、下载Navicat数据库管理软件并安装。</p>
<p>2、破解工具：</p>
<p>链接：<a href="https://pan.baidu.com/s/1-fAmr0Cj-iAIZKXY6xoS4Q">https://pan.baidu.com/s/1-fAmr0Cj-iAIZKXY6xoS4Q</a><br />
提取码：lnrp</p>
<p>3、关闭杀毒安全软件，断网。管理员权限运行破解工具。</p>
<p>具体图文见：<a href="https://www.cnblogs.com/yunwangjun-python-520/p/13827824.html">https://www.cnblogs.com/yunwangjun-python-520/p/13827824.html</a></p>
<p>7f42c8469e94a99f37d1c98df0d8d56565a906be</p>
<h2 id="3-远程访问mysql常见问题"><a class="markdownIt-Anchor" href="#3-远程访问mysql常见问题"></a> 3、远程访问MySQL常见问题</h2>
<p>1、云服务器开启防火墙端口3306。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">启动： systemctl start firewalld</span><br><span class="line">查看状态： systemctl status firewalld / firewall-cmd state 这个命令也可以，只是信息会简单点</span><br><span class="line">停止： systemctl disable firewalld</span><br><span class="line">禁用： systemctl stop firewalld</span><br><span class="line">添加</span><br><span class="line">firewall-cmd <span class="attr">--zone</span>=public --add-port=<span class="number">80</span>/tcp --permanent   （--permanent永久生效，没有此参数重启后失效）</span><br><span class="line">重新载入，添加端口后重新载入才能起作用</span><br><span class="line">firewall-cmd --reload</span><br><span class="line">查看端口</span><br><span class="line">firewall-cmd <span class="attr">--zone</span>=public --query-port=<span class="number">80</span>/tcp</span><br><span class="line">删除端口</span><br><span class="line">firewall-cmd <span class="attr">--zone</span>=public --remove-port=<span class="number">80</span>/tcp --permanent</span><br><span class="line">查看开启了哪些服务</span><br><span class="line">firewall-cmd --list-services</span><br><span class="line">查看开启了哪些端口</span><br><span class="line">firewall-cmd --list-ports</span><br><span class="line">查看还有哪些服务可以打开</span><br><span class="line">firewall-cmd --get-services</span><br><span class="line">查看所有打开的端口：</span><br><span class="line">firewall-cmd <span class="attr">--zone</span>=public --list-ports</span><br><span class="line">更新防火墙规则：</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<p>2、MySQL配置文件添加可以访问的ip地址，默认为本机，修改如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind-adress=0.0.0.0</span><br></pre></td></tr></table></figure>
<p>接着设置可以所有主机可访问</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#登录mysql</span></span><br><span class="line">mysql -u root -p</span><br><span class="line"><span class="comment">#进入mysql数据库</span></span><br><span class="line">use mysql<span class="comment">;</span></span><br><span class="line"><span class="comment">#设置所有主机可以root用户登录</span></span><br><span class="line">update user set <span class="attr">host</span> = <span class="string">&#x27;%&#x27;</span> where user = <span class="string">&#x27;root&#x27;</span><span class="comment">; </span></span><br><span class="line"><span class="comment">#查看修改结果</span></span><br><span class="line">select host, user from user<span class="comment">; </span></span><br><span class="line"><span class="comment">#更新权限</span></span><br><span class="line">flush privileges<span class="comment">;</span></span><br><span class="line"><span class="comment">#重启mysql</span></span><br><span class="line">service mysqld restart</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>IP地址划分</title>
    <url>/2021/07/24/IP%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<h1 id="ip地址划分"><a class="markdownIt-Anchor" href="#ip地址划分"></a> IP地址划分</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p>
<p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;25525511135&quot;</span><br><span class="line">输出：[&quot;255.255.11.135&quot;,&quot;255.255.111.35&quot;]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">restoreIPAdress</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; address=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        doRestore(<span class="number">0</span>,address,res,s);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯框架</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRestore</span><span class="params">(<span class="keyword">int</span> k,List&lt;String&gt; address,StringBuilder res,String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">4</span>||s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">4</span>&amp;&amp;s.length()==<span class="number">0</span>)&#123;</span><br><span class="line">                address.add(res.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//注意此处有return。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()&amp;&amp;i&lt;=<span class="number">2</span>;i++)&#123;<span class="comment">//i&lt;=2是因为ip地址范围0-255</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>&amp;&amp;s.charAt(<span class="number">0</span>)==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//ip地址除第一位外其他位起始不能为0</span></span><br><span class="line">            &#125;</span><br><span class="line">            String part=s.subString(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(Integer.valueOf(part)&lt;=<span class="number">255</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.length()!=<span class="number">0</span>)&#123;</span><br><span class="line">                    part=<span class="string">&quot;.&quot;</span>+part;</span><br><span class="line">                    res.append(part);</span><br><span class="line">                &#125;</span><br><span class="line">            doRestore(k + <span class="number">1</span>, addresses,res, s.substring(i + <span class="number">1</span>));</span><br><span class="line">            res.delete(res.length() - part.length(), res.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//穷举</span></span><br><span class="line">        <span class="comment">//撤销</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU缓存机制</title>
    <url>/2020/07/11/LRU%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="lru缓存机制"><a class="markdownIt-Anchor" href="#lru缓存机制"></a> LRU缓存机制</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p>
<p>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。<br />
写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p>
<p>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>要让put和get操作的时间复杂度为O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。</p>
<p>通常哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。</p>
<p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p>
<img src="https://pic.leetcode-cn.com/9201fabe4dfdb5a874b43c325d39857182c8ec267f830649a52dda90a63d6671-file_1562356927818" style="zoom:50%;" />
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p>1、首先我们设计双链表的结点类，假定key和val都为int类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> key,val;</span><br><span class="line">    <span class="keyword">public</span> Node prev,next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key=k;</span><br><span class="line">        <span class="keyword">this</span>.val=v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、根据Node类构建双链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleList</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head,tail;<span class="comment">//虚拟首尾结点，头无前驱，尾无后继。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//链表元素个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DoubleList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.prev=head;</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在链表头部添加结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.next=head.next;</span><br><span class="line">        x.prev=head;</span><br><span class="line">        head.next.prev=x;</span><br><span class="line">        head.next=x;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除链表中的结点x</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Node x)</span></span>&#123;</span><br><span class="line">        x.prev.next=x.next;</span><br><span class="line">        x.next.prev=x.prev;</span><br><span class="line">        size--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除链表中最后一个结点，并返回该结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">removeLast</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tail.prev=head) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Node last = tail.prev;</span><br><span class="line">        delete(last);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、LRU缓存实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer,Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> DoubleList cache;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Capacity=capacity;</span><br><span class="line">        map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        cache=<span class="keyword">new</span> DoubleList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> val=map.get(key).val;</span><br><span class="line">        put(key,val);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        Node x=<span class="keyword">new</span> Node(key,val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;<span class="comment">//key存在，则更新值。</span></span><br><span class="line">            cache.delete(map.get(key));</span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            map.put(key,x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; <span class="comment">//key不存在，首先判断是否到达容量，达到则删除最末尾元素，然后将新元素添加到链表头。 </span></span><br><span class="line">            <span class="keyword">if</span>(Capacity==cache.size())&#123;</span><br><span class="line">            Node last=cache.removeLast();</span><br><span class="line">            map.delete(last.key);</span><br><span class="line">            &#125;</span><br><span class="line">            cache.addFirst(x);</span><br><span class="line">            map.put(key,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当缓存容量已满，我们不仅仅要删除最后一个 Node 节点，还要把 map 中映射到该节点的 key 同时删除，而这个 key 只能由 Node 得到。如果 Node 结构中只存储 val，那么我们就无法得知 key 是什么，就无法删除 map 中的键，造成错误。</p>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>乘积最大子数组</title>
    <url>/2020/07/11/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="乘积最大子数组"><a class="markdownIt-Anchor" href="#乘积最大子数组"></a> 乘积最大子数组</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给你一个整数数组 <code>nums</code> ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>我们只要记录前i的最小值, 和最大值, 那么 dp[i] = max(nums[i] * pre_max, nums[i] * pre_min, nums[i]), 这里0 不需要单独考虑, 因为当相乘不管最大值和最小值,都会置0</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> preMin=nums[<span class="number">0</span>],preMax=nums[<span class="number">0</span>],res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> temp1=<span class="number">0</span>,temp2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            temp1=preMin*nums[i];<span class="comment">//若之前为负数，当前数也为负数</span></span><br><span class="line">            temp2=preMax*nums[i];</span><br><span class="line">            preMax=Math.max(Math.max(temp1,temp2),nums[i]);</span><br><span class="line">            preMin=Math.min(Math.max(temp1,temp2),nums[i]);</span><br><span class="line">            res=Math.max(res,preMax);<span class="comment">//</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍</title>
    <url>/2020/07/10/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
    <content><![CDATA[<h1 id="打家劫舍"><a class="markdownIt-Anchor" href="#打家劫舍"></a> 打家劫舍</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。</p>
<p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第k (k&gt;2) 间房屋，有两个选项：</p>
<p>1、偷窃第 k间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k-2间房屋的最高总金额与第 k 间房屋的金额之和。</p>
<p>2、不偷窃第 k间房屋，偷窃总金额为前 k-1间房屋的最高总金额。</p>
<p>在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。</p>
<p>用 dp[i]表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：</p>
<p>dp[i]=max(dp[i-2]+nums[i],dp[i-1])</p>
<p>边界条件为：<br />
dp[0]=nums[0]<br />
dp[1]=max(nums[0],nums[1])</p>
<p>​</p>
<p>返回值dp[n-1]。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>]=Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            dp[i]=Math.max(dp[i-<span class="number">2</span>]+nums[i],dp[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿数量</title>
    <url>/2020/07/10/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<h1 id="岛屿数量"><a class="markdownIt-Anchor" href="#岛屿数量"></a> 岛屿数量</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<blockquote>
<p>输入:<br />
[<br />
[‘1’,‘1’,‘0’,‘0’,‘0’],<br />
[‘1’,‘1’,‘0’,‘0’,‘0’],<br />
[‘0’,‘0’,‘1’,‘0’,‘0’],<br />
[‘0’,‘0’,‘0’,‘1’,‘1’]<br />
]<br />
输出: 3<br />
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numsIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=grid.length||j&lt;<span class="number">0</span>||j&gt;=grid[<span class="number">0</span>].length||grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        grid[i][j]=<span class="string">&#x27;0&#x27;</span>;<span class="comment">//对访问过的元素置0，以免重复访问。</span></span><br><span class="line">        dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i,j+<span class="number">1</span>);</span><br><span class="line">        dfs(grid,i-<span class="number">1</span>,j);</span><br><span class="line">        dfs(grid,i+<span class="number">1</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bfs搜索岛屿"><a class="markdownIt-Anchor" href="#bfs搜索岛屿"></a> BFS搜索岛屿</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numsIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;grid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    bfs(grid,i,j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] grid,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span>[] cur=queue.remove();</span><br><span class="line">            i = cur[<span class="number">0</span>]; j = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i + <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i - <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j + <span class="number">1</span> &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j - <span class="number">1</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表</title>
    <url>/2020/07/09/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="环形链表"><a class="markdownIt-Anchor" href="#环形链表"></a> 环形链表</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="" /></p>
<p>说明：不允许修改给定的链表。</p>
<h2 id="方法一哈希表"><a class="markdownIt-Anchor" href="#方法一哈希表"></a> 方法一：（哈希表）</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; visited=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        ListNode node=head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(node))&#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            visited.add(node);</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法二双指针"><a class="markdownIt-Anchor" href="#方法二双指针"></a> 方法二：（双指针）</h2>
<p><strong>这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等。</strong></p>
<p>设置快慢指针，构造两次相遇，第一次相遇后快指针回到起点，然后两个指针以相同的步调前进。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            fast=fast.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>排序链表</title>
    <url>/2020/07/09/%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="排序链表"><a class="markdownIt-Anchor" href="#排序链表"></a> 排序链表</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>递归实现链表归并排序</strong></p>
<p><strong>1、分割</strong></p>
<p>找到当前链表<code>中点</code>，并从<code>中点</code>将链表断开（以便在下次递归 <code>cut</code> 时，链表片段拥有正确边界）；</p>
<ul>
<li>我们使用 fast,slow 快慢双指针法，链表有奇数个节点找到中点，偶数个节点找到中心左边的节点。</li>
<li>找到中点 slow 后，执行 slow.next = None 将链表切断。</li>
<li>递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。</li>
<li>cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。</li>
</ul>
<p><strong>2、合并</strong></p>
<p>将两个排序链表合并，转化为一个排序链表</p>
<ul>
<li>双指针法合并，建立辅助ListNode h 作为头部。</li>
<li>设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。</li>
<li>返回辅助ListNode h 作为头部的下个节点 h.next。</li>
<li>时间复杂度 O(l + r)，l, r 分别代表两个链表长度。</li>
</ul>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode fast=head,slow=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>&amp;&amp;fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ListNode tmp=slow.next;</span><br><span class="line">        slow.next=<span class="keyword">null</span>;</span><br><span class="line">        ListNode left=sortList(head);</span><br><span class="line">        ListNode right=sortList(tmp);</span><br><span class="line">        ListNode h=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode res=h;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="keyword">null</span>&amp;&amp; right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(left.val&lt;right.val)&#123;</span><br><span class="line">                h.next=left;</span><br><span class="line">                left=left.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                h.next=right;</span><br><span class="line">                right=right.next;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h.next=left==<span class="keyword">null</span>?right:left;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_00148</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(logn)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 待排序链表头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排序后链表的头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        quickSort(head, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对区间 [head, end) 排序</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 链表头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 链表尾结点（不包含）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != end) &#123;</span><br><span class="line">            ListNode q = partition(head, end);</span><br><span class="line">            quickSort(head, q);</span><br><span class="line">            quickSort(q.next, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">partition</span><span class="params">(ListNode head, ListNode end)</span> </span>&#123;<span class="comment">//将</span></span><br><span class="line">        <span class="keyword">int</span> x = head.val;</span><br><span class="line">        <span class="comment">// p 代表小于 x 的最后一个结点</span></span><br><span class="line">        ListNode p = head;</span><br><span class="line">        ListNode q = head.next;</span><br><span class="line">        <span class="keyword">while</span> (q != end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.val &lt; x) &#123;</span><br><span class="line">                p = p.next;</span><br><span class="line">                swap(p, q);</span><br><span class="line">            &#125;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(head, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(ListNode p, ListNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = p.val;</span><br><span class="line">        p.val = q.val;</span><br><span class="line">        q.val = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2>
<ul>
<li>当初始化fast = head; slow = head时，运用快慢指针方法最后两个指针的指向情况如下：
<ul>
<li>当链表长度为奇数时，<code>fast</code> 指向尾结点，<code>slow</code> 指向中心结点。</li>
<li>当链表长度为偶数时，<code>fast</code> 指向 <code>null</code>，<code>slow</code> 指向<strong>下</strong>中位数结点。</li>
</ul>
</li>
<li>当初始化fast = head.next; slow = head时，运用快慢指针方法最后两个指针的指向情况如下：
<ul>
<li>当链表长度为奇数时，<code>fast</code> 指向尾结点，<code>slow</code> 指向中心结点。</li>
<li>当链表长度为偶数时，<code>fast</code> 指向尾结点，<code>slow</code> 指向<strong>上</strong>中位数结点。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_00148</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(logn)</span></span><br><span class="line"><span class="comment">     * 不用额外创建数组，空间复杂度降低了，链表排序的最佳方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 待排序链表头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排序后链表的头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line">        ListNode a = sortList(head);</span><br><span class="line">        ListNode b = sortList(fast);</span><br><span class="line">        <span class="keyword">return</span> mergeList(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">mergeList</span><span class="params">(ListNode a, ListNode b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>) <span class="keyword">return</span> b;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">if</span> (a.val &lt; b.val) &#123;</span><br><span class="line">            a.next = mergeList(a.next, b);</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b.next = mergeList(a, b.next);</span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于题目要求空间复杂度为 <code>O(1)</code>，应该使用自底向上的归并排序。</p>
<p>“<strong>自顶向下</strong>”的归并排序。<br />
该类归并排序是算法设计中“分治”思想的典型应用。<br />
其实就是将数组分为两部分，然后<strong>递归</strong>地将两部分分别排序，将排序后的两个数组进行归并。</p>
<p>“<strong>自底向上</strong>”的归并排序。<br />
该类归并排序是先<strong>两两归并</strong>size=1的小数组，形成size=2的各对数组；然后再两两归并size=2数组，直到归并size=N的大数组。<br />
“自底向上”不需要用到递归，适合以链表形式组织的数据。</p>
<p><img src="http://static.oschina.net/uploads/space/2015/0801/191043_lNEp_1417725.jpg" alt="" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_00148</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自底向上的归并排序</span></span><br><span class="line"><span class="comment">     * 时间复杂度：O(nlogn)</span></span><br><span class="line"><span class="comment">     * 空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head 待排序链表头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 排序后链表的头结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (ListNode p = head; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">            ++n;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            ListNode cur = dummy;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + i &lt; n; j += i &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">                ListNode a = cur.next, b = cur.next;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; ++k) &#123;</span><br><span class="line">                    b = b.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; i &amp;&amp; r &lt; i &amp;&amp; b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a.val &lt; b.val) &#123;</span><br><span class="line">                        cur.next = a;</span><br><span class="line">                        cur = a;</span><br><span class="line">                        a = a.next;</span><br><span class="line">                        ++l;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        cur.next = b;</span><br><span class="line">                        cur = b;</span><br><span class="line">                        b = b.next;</span><br><span class="line">                        ++r;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; i) &#123;</span><br><span class="line">                    cur.next = a;</span><br><span class="line">                    cur = a;</span><br><span class="line">                    a = a.next;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (r &lt; i &amp;&amp; b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cur.next = b;</span><br><span class="line">                    cur = b;</span><br><span class="line">                    b = b.next;</span><br><span class="line">                    ++r;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.next = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转链表</title>
    <url>/2020/07/08/%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="旋转链表"><a class="markdownIt-Anchor" href="#旋转链表"></a> 旋转链表</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个链表，旋转链表，将链表每个节点向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><br><span class="line">输出: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">解释://每次右旋，相当于把末尾元素移到前面来。</span><br><span class="line">向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>我们的直觉是先把链表闭合成环，然后找到相应的位置断开，确定新的头尾。</p>
<p><img src="https://pic.leetcode-cn.com/e3371c6b03e3c8d3758dcf0b35a45d0a6b39c111373cf7b5bde53e14b6271a04-61.png" alt="" /></p>
<p>新的链表头位置：(n - k % n)</p>
<p>新的链表尾位置：(n - k % n - 1)</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//闭合成环</span></span><br><span class="line">        ListNode node=head;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">for</span>(len=<span class="number">1</span>;node.next!=<span class="keyword">null</span>;len++)&#123;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next=head;</span><br><span class="line">        <span class="comment">//找到新的头节点</span></span><br><span class="line">        ListNode newtail=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-k%len-<span class="number">1</span>;i++)&#123;<span class="comment">//获取新头结点的前一个结点，即断开后的尾结点。</span></span><br><span class="line">            newtail=newtail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode newhead=newtail.next;</span><br><span class="line">        <span class="comment">//断环</span></span><br><span class="line">        newtail.next=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newhead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>子集</title>
    <url>/2020/07/07/%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h1 id="子集"><a class="markdownIt-Anchor" href="#子集"></a> 子集</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p>**说明：**解集不能包含重复的子集。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路实现"><a class="markdownIt-Anchor" href="#思路实现"></a> 思路实现</h2>
<p>回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subSet(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsets=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; curSubset=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> size=<span class="number">0</span>;size&lt;nums.length;size++)&#123;<span class="comment">//对每个size进行回溯搜索，即从空集到满集。</span></span><br><span class="line">            backtrack(<span class="number">0</span>,subsets,curSubset,nums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subsets;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> start,List&lt;List&lt;Integer&gt;&gt; subsets,List&lt;Integer&gt; curSubset,<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curSubset.size()==size)&#123;</span><br><span class="line">            subsets.add(<span class="keyword">new</span> ArrayList&lt;&gt;(curSubset));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">        curSubset.add(nums[i]);</span><br><span class="line">        backtrack(i + <span class="number">1</span>, curSubset, subsets, size, nums);</span><br><span class="line">        curSubset.remove(curSubset.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="子集ii"><a class="markdownIt-Anchor" href="#子集ii"></a> 子集Ⅱ</h1>
<h2 id="问题陈述-2"><a class="markdownIt-Anchor" href="#问题陈述-2"></a> 问题陈述</h2>
<p>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    Arrays.sort(nums);<span class="comment">//</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; tempSubset = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];<span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">0</span>; size &lt;= nums.length; size++) &#123;</span><br><span class="line">        backtracking(<span class="number">0</span>, tempSubset, subsets, hasVisited, size, nums); <span class="comment">// 不同的子集大小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subsets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets, <span class="keyword">boolean</span>[] hasVisited,<span class="keyword">final</span> <span class="keyword">int</span> size, <span class="keyword">final</span> <span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tempSubset.size() == size) &#123;</span><br><span class="line">        subsets.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempSubset));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !hasVisited[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tempSubset.add(nums[i]);</span><br><span class="line">        hasVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        backtracking(i + <span class="number">1</span>, tempSubset, subsets, hasVisited, size, nums);</span><br><span class="line">        hasVisited[i] = <span class="keyword">false</span>;</span><br><span class="line">        tempSubset.remove(tempSubset.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最大正方形</title>
    <url>/2020/07/07/%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="最大正方形"><a class="markdownIt-Anchor" href="#最大正方形"></a> 最大正方形</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。</p>
<p>示例:</p>
<p>输入:</p>
<p>1 0 1 0 0<br />
1 0 1 1 1<br />
1 1 1 1 1<br />
1 0 0 1 0</p>
<p>输出: 4</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>动态规划的思想，你能想明白吗哈哈</strong></p>
<p>我们用 dp(i, j)表示以 (i, j) 为右下角，且只包含 1 的正方形的边长最大值。如果我们能计算出所有 dp(i, j) 的值，那么其中的最大值即为矩阵中只包含 1 的正方形的边长最大值，其平方即为最大正方形的面积。</p>
<p><strong>那么，怎么确定dp(i, j)呢</strong></p>
<p>如果该位置的值是 0，则 dp(i, j) = 0，因为当前位置不可能在由 1组成的正方形中；</p>
<p>如果该位置的值是 1，则 dp(i, j) 的值由其上方、左方和左上方的三个相邻位置的 dp值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p>
<p>dp(i, j)=min(dp(i−1, j), dp(i−1, j−1), dp(i, j−1))+1</p>
<p><strong>别忘了考虑边界情况</strong></p>
<p>虑边界条件。如果 i 和 j 中至少有一个为 0，也就是第一行和第一列，则以位置 (i, j)为右下角的最大正方形的边长只能是 1，因此 dp(i, j) = 1。</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">原始矩阵----------上述规则----------dp矩阵</span><br><span class="line"></span><br><span class="line">0 1 1 1 0                    0 1 1 1 0</span><br><span class="line">1 1 1 1 0                    1 1 2 2 0</span><br><span class="line">0 1 1 1 1                    0 1 2 3 1</span><br><span class="line">0 1 1 1 1                    0 1 2 3 2</span><br><span class="line">0 0 1 1 1                    0 0 1 2 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxSide=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>||matrix[<span class="number">0</span>].length==<span class="number">0</span>) <span class="keyword">return</span> maxSide;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> row=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j]=Math.min(Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>])+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxSide=Math.max(maxSide,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSide*maxSide;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>2的幂</title>
    <url>/2020/07/06/2%E7%9A%84%E5%B9%82/</url>
    <content><![CDATA[<h1 id="2的幂"><a class="markdownIt-Anchor" href="#2的幂"></a> 2的幂</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p>解法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//2的幂不会等于0.</span></span><br><span class="line">        <span class="keyword">while</span>(n%<span class="number">2</span>==<span class="number">0</span>)&#123;<span class="comment">//如果n是2的倍数</span></span><br><span class="line">            n/=<span class="number">2</span>;<span class="comment">//不断除2，若是2的幂最后值为1.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n==<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//位运算，对n&gt;0 &amp;&amp; n&amp;(n-1)==0,则n必为2的幂。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>反转字符串中的单词</title>
    <url>/2020/07/05/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h1 id="反转字符串中的单词"><a class="markdownIt-Anchor" href="#反转字符串中的单词"></a> 反转字符串中的单词</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>
<p>示例 1:</p>
<blockquote>
<p>输入: “Let’s take LeetCode contest”<br />
输出: “s’teL ekat edoCteeL tsetnoc”</p>
</blockquote>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p>解法一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    String words=s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(String word:words)&#123;</span><br><span class="line">        res.append(<span class="keyword">new</span> StringBulder(word).reverse().toString()+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString().trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="comment">//先反转整个字符串</span></span><br><span class="line">        reverse(cs, <span class="number">0</span>, cs.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; s.length() &amp;&amp; cs[j] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse(cs,i, j - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//此时cs[j]为空格，下一个不为空格</span></span><br><span class="line">            i = j + <span class="number">1</span>;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(cs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">            ++start;</span><br><span class="line">            --end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>回文数</title>
    <url>/2020/07/04/%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h1 id="回文数"><a class="markdownIt-Anchor" href="#回文数"></a> 回文数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p><strong>基础解法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将数字转为字符串，双指针首位判断。</span></span><br><span class="line"><span class="comment">//数字转字符串方法：String.valueOf(x);x.toString();&quot;&quot;+x;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        String s=String.valueOf(x);</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>基于数学理解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//如为负数，必不能回文</span></span><br><span class="line">        <span class="keyword">int</span> cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num=x;</span><br><span class="line">        <span class="keyword">while</span>(num!=<span class="number">0</span>)&#123;<span class="comment">//实现x反转</span></span><br><span class="line">            cur=cur*<span class="number">10</span>+num%<span class="number">10</span>;</span><br><span class="line">            num=num/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur==x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>买卖股票的最佳时机</title>
    <url>/2020/07/04/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="买卖股票的最佳时机"><a class="markdownIt-Anchor" href="#买卖股票的最佳时机"></a> 买卖股票的最佳时机</h1>
<h2 id="问题陈述情况1"><a class="markdownIt-Anchor" href="#问题陈述情况1"></a> 问题陈述(情况1)</h2>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>如果你<strong>最多只允许完成一笔交易</strong>（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</p>
<p>注意：你不能在买入股票前卖出股票。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>我们需要找出给定数组中两个数字之间的最大差值（即，最大利润）。此外，第二个数字（卖出价格）必须大于第一个数字（买入价格）。</p>
<p>形式上，对于每组 ii 和 jj（其中 j &gt; ij&gt;i）我们需要找出 \max(prices[j] - prices[i])max(prices[j]−prices[i])。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p>1、暴力法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxprofit</span><span class="params">(<span class="keyword">int</span>[] price)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;price.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;price.length;j++)&#123;</span><br><span class="line">                profit=Math.max(profit,price[j]-price[i])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、一次遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxprofit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minprice=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]&lt;minprice)&#123;</span><br><span class="line">                minprice=prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prices[i]-minprice&gt;profit)&#123;</span><br><span class="line">                profit=prices[i]-minprice;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题陈述情况2"><a class="markdownIt-Anchor" href="#问题陈述情况2"></a> 问题陈述（情况2）</h2>
<p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你<strong>可以尽可能地完成更多的交易</strong>（多次买卖一支股票）。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<h2 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析</h2>
<p>股票上升日：后一日股票价较前一日上升。可以买进并售出。</p>
<p>股票下降日：不买也不卖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxprofit</span><span class="params">(<span class="keyword">int</span>[] prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;prices.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-prices[i-<span class="number">1</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                profit+=prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>三角形最小路径和</title>
    <url>/2020/07/03/%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="三角形最小路径和"><a class="markdownIt-Anchor" href="#三角形最小路径和"></a> 三角形最小路径和</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</p>
<p>相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p>动态规划+自底向上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle==<span class="keyword">null</span>||triangle.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//判空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[triangle.size()+<span class="number">1</span>][triangle.size()+<span class="number">1</span>];<span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=triangle.size()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            List&lt;Integer&gt; rows=triangle.get(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;row.size();j++)&#123;</span><br><span class="line">                dp[i][j]=Math.min(dp[i+<span class="number">1</span>][j],dp[i+<span class="number">1</span>][j+<span class="number">1</span>])+rows.get(j);<span class="comment">//转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>验证回文串</title>
    <url>/2020/07/03/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="验证回文串"><a class="markdownIt-Anchor" href="#验证回文串"></a> 验证回文串</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p>
<p>**说明：**本题中，我们将空字符串定义为有效的回文串。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="keyword">null</span>||s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        s=s.toLowerCase();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>，j=s.length()-<span class="number">1</span>;i&lt;j;i++，j--)&#123;<span class="comment">//注意多条件for循环表达式写法，冒号只出现两次</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i)))&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j)))&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)!=s.charAt(j))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       String actual = s.replaceAll(<span class="string">&quot;[^A-Za-z0-9]&quot;</span>, <span class="string">&quot;&quot;</span>).toLowerCase();<span class="comment">//正则表达式匹配</span></span><br><span class="line">       String rev = <span class="keyword">new</span> StringBuffer(actual).reverse().toString();</span><br><span class="line">       <span class="keyword">return</span> actual.equals(rev);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相乘</title>
    <url>/2020/07/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h1 id="字符串相乘"><a class="markdownIt-Anchor" href="#字符串相乘"></a> 字符串相乘</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><img src="https://pic.leetcode-cn.com/34e85a782b3713633713b09b8729233222697d71585265641c004c0bcc93a314.jpg" alt="" /></p>
<p><strong><code>num1[i]</code> 和 <code>num2[j]</code> 的乘积对应的就是 <code>res[i+j]</code> 和 <code>res[i+j+1]</code> 这两个位置</strong>。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String m,String n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.equals(<span class="string">&quot;0&quot;</span>)||n.equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[m.length()+n.length()];<span class="comment">//结果位数为m，n长度之和。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> m1=m.charAt(i)-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//某数字字符减0字符等于该数字大小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> n1=n.charAt(j)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> sum=res[i+j+<span class="number">1</span>]+m1*n1;</span><br><span class="line">                res[i+j+<span class="number">1</span>]=sum%<span class="number">10</span>;</span><br><span class="line">                res[i+j]+=sum/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder str=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;res[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            str.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>杨辉三角</title>
    <url>/2020/07/03/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<h1 id="杨辉三角"><a class="markdownIt-Anchor" href="#杨辉三角"></a> 杨辉三角</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个正整数，输出该杨辉三角的每行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br><span class="line">杨辉三角：起始为1；每行开始和末尾都为1；中间的第i个元素等于上一行的第i个元素加上第i-1个元素之和。</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; yanghuiTriangle(<span class="keyword">int</span> rownums)&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; triangle=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(rownums==<span class="number">0</span>) <span class="keyword">return</span> triangle;</span><br><span class="line">        <span class="comment">//添加第一行元素</span></span><br><span class="line">        triangle.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        triangle.get(<span class="number">0</span>).add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;rownums;i++)&#123;</span><br><span class="line">            List&lt;Integer&gt; currow=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;Integer&gt; prerow=triangle.get(i-<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//第j行同样有j个元素,从第二个元素开始，到倒数第二个的计算</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;rownums;j++)&#123;</span><br><span class="line">                row.add(prerow.get(j-<span class="number">1</span>)+prerow.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//添加末尾元素</span></span><br><span class="line">            row.add(<span class="number">1</span>);</span><br><span class="line">            triangle.add(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> triangle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>填充每个结点的下一个右侧结点指针</title>
    <url>/2020/07/02/%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E7%BB%93%E7%82%B9%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="填充每个结点的下一个右侧结点指针"><a class="markdownIt-Anchor" href="#填充每个结点的下一个右侧结点指针"></a> 填充每个结点的下一个右侧结点指针</h1>
<p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p><img src="https://pic.leetcode-cn.com/c657e60fe795868e754741d7019055879d3fd9a5152c965391312f00779d6121-2.jpg" alt="" /></p>
<p><strong>思路一</strong>：</p>
<p>在二叉树层序遍历的基础上，对每一层进行右节点的连结，需判断右节点是否存在。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Queue&lt;Node&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">     </span><br><span class="line">        <span class="keyword">while</span>(queue.size()&gt;<span class="number">0</span>)&#123;<span class="comment">//</span></span><br><span class="line">            <span class="keyword">int</span> n=queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                Node node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(i&lt;n-<span class="number">1</span>)&#123;</span><br><span class="line">                    node.next=queue.peek();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>思路二</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个 node 左子树的 next , 就是 node 的右子树</span></span><br><span class="line"><span class="comment">//每个 node 右子树的 next, 就是 node next 的 左子树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        dfs(root,<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node,Node next)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.next=next;</span><br><span class="line">        dfs(node.left,node.right);</span><br><span class="line">        dfs(node.right,node.next!=<span class="keyword">null</span>? node.next.left:<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最接近的三数之和</title>
    <url>/2020/07/02/%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="最接近的三数之和"><a class="markdownIt-Anchor" href="#最接近的三数之和"></a> 最接近的三数之和</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个包括 <em>n</em> 个整数的数组 <code>nums</code> 和 一个目标值 <code>target</code>。找出 <code>nums</code> 中的三个整数，使得它们的和与 <code>target</code> 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,2,1,-4], target = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> ans=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;<span class="comment">//固定一个数，其他两个分别在首尾运动</span></span><br><span class="line">            <span class="keyword">int</span> start=i+<span class="number">1</span>,end=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(start&lt;end)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[start]+nums[end];</span><br><span class="line">                <span class="keyword">if</span>(Math.abs(target-ans)&gt;=Math.abs(target-sum))&#123;</span><br><span class="line">                    ans=sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;target) </span><br><span class="line">                    end--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target) </span><br><span class="line">                    start++;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>计算质数</title>
    <url>/2020/07/01/%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h1 id="计算质数"><a class="markdownIt-Anchor" href="#计算质数"></a> 计算质数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>统计所有小于非负整数 <em>n</em> 的质数的数量。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>质数：除了1和本身之外，没有别的因数。因此可以对1&lt;i&lt;n, 判断s%i==0？</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] primes = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];  <span class="comment">//创建整个素数数组</span></span><br><span class="line">    Arrays.fill(primes, <span class="keyword">true</span>);      <span class="comment">//初始化全部为素数</span></span><br><span class="line">    primes[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">    primes[<span class="number">1</span>] = <span class="keyword">false</span>;                  <span class="comment">//划掉0和1</span></span><br><span class="line">    <span class="keyword">int</span> sqrt = (<span class="keyword">int</span>)Math.sqrt(n);       <span class="comment">//设置上界</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= sqrt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!primes[i]) <span class="keyword">continue</span>;       <span class="comment">//不是素数，可以跳过</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> multi = i*i; multi &lt; n ; multi += i)&#123;</span><br><span class="line">            primes[multi] = <span class="keyword">false</span>;      <span class="comment">//划掉倍数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">boolean</span> prime : primes) &#123;      <span class="comment">//统计数组中素数的数量</span></span><br><span class="line">        <span class="keyword">if</span> (prime) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>从后序序列和中序序列构造二叉树</title>
    <url>/2020/06/27/%E4%BB%8E%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="从后序序列和中序序列构造二叉树"><a class="markdownIt-Anchor" href="#从后序序列和中序序列构造二叉树"></a> 从后序序列和中序序列构造二叉树</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前序序列 preorder = [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder = [9,3,15,20,7]</span><br><span class="line">后序遍历 postorder = [9,15,7,20,3]</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现模板和前序加中序一样的，唯一在递归序列的索引划分。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>,postorder,<span class="number">0</span>,postorder.length-<span class="number">1</span>,map);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> i_start,<span class="keyword">int</span> i_end,<span class="keyword">int</span>[] postorder,<span class="keyword">int</span> p_start,<span class="keyword">int</span> p_end,HashMap&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.length==<span class="number">0</span>||inorder.length==<span class="number">0</span>||p_start&gt;p_end||i_start&gt;i_end)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root_val=postorder[p_end];</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        <span class="keyword">int</span> i_root_index=map.get(root_val);</span><br><span class="line">        <span class="keyword">int</span> leftnum=i_root_index-i_start;</span><br><span class="line">        root.right=buildTreeHelper(inorder,i_root_index+<span class="number">1</span>,i_end,postorder,p_start+leftnum,p_end-<span class="number">1</span>,map);</span><br><span class="line">        </span><br><span class="line"> root.left=buildTreeHelper(inorder,i_start,i_root_index-<span class="number">1</span>,postorder,p_start,p_start+leftnum-<span class="number">1</span>,map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>把有序数组转换为二叉树</title>
    <url>/2020/06/26/%E6%8A%8A%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="把有序数组转换为二叉搜索树"><a class="markdownIt-Anchor" href="#把有序数组转换为二叉搜索树"></a> 把有序数组转换为二叉搜索树</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p>
<p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定有序数组: [-10,-3,0,5,9],</span><br><span class="line"></span><br><span class="line">一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</span><br><span class="line"></span><br><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line"> -10  5</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums=nums;</span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left=helper(left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right=helper(mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>验证二叉搜索树</title>
    <url>/2020/06/26/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="验证二叉搜索树"><a class="markdownIt-Anchor" href="#验证二叉搜索树"></a> 验证二叉搜索树</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p>
<p>假设一个二叉搜索树具有如下特征：</p>
<p>节点的左子树只包含小于当前节点的数。<br />
节点的右子树只包含大于当前节点的数。<br />
所有左子树和右子树自身必须也是二叉搜索树。</p>
<h2 id="问题解决"><a class="markdownIt-Anchor" href="#问题解决"></a> 问题解决</h2>
<p>根据中序遍历的特性，若为二叉搜索树，则中序结果必为有序，所以可以判断当前结点是否大于先前结点。</p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> pre=Long.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBST</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//访问左子树</span></span><br><span class="line">        <span class="keyword">if</span>(!isBST(root.left)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//访问当前结点，是否小于先前结点。</span></span><br><span class="line">        <span class="keyword">if</span>(root.val&lt;pre) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        pre=root.val;</span><br><span class="line">        <span class="comment">//访问右子树</span></span><br><span class="line">        <span class="keyword">return</span> isBST(root.right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>中序遍历</title>
    <url>/2020/06/26/%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>实现二叉树的中序遍历</p>
<h2 id="问题解决"><a class="markdownIt-Anchor" href="#问题解决"></a> 问题解决</h2>
<p><strong>1、递归法</strong></p>
<p>根据中序遍历“左根右”的特点，编写代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTravelsal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(list,root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; list,TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(list,root.left);</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        dfs(list,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、迭代法（基于栈）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTravelsal</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>||stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur=stack.pop();</span><br><span class="line">            list.add(cur.val);</span><br><span class="line">            cur=cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的层序及Z形遍历</title>
    <url>/2020/06/25/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E5%8F%8AZ%E5%BD%A2%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="二叉树的层序及z形遍历"><a class="markdownIt-Anchor" href="#二叉树的层序及z形遍历"></a> 二叉树的层序及Z形遍历</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>1、给你一个二叉树，请你返回其按 <strong>层序遍历和Z形遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p>
<p>示例：</p>
<p>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">层序返回结果：</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br><span class="line">Z形返回结果：</span><br><span class="line">[</span><br><span class="line"> [3],</span><br><span class="line"> [20,9],</span><br><span class="line"> [15,7],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历"><a class="markdownIt-Anchor" href="#层序遍历"></a> 层序遍历</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();<span class="comment">//双端队列</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(level);</span><br><span class="line">        <span class="comment">//res.add(0,level); 实现从最后一层开始打印。将每次的level放在第一位，之前在第一位的往后移。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="z形遍历"><a class="markdownIt-Anchor" href="#z形遍历"></a> Z形遍历</h2>
<p>1、解法一</p>
<p>和层次遍历一个模板，但是对层数多了一个奇偶判断，并对偶数层list进行反转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">         List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count%<span class="number">2</span>==<span class="number">0</span>) Collections.reverse(level);<span class="comment">//list反转</span></span><br><span class="line">        count++;</span><br><span class="line">        res.add(level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、解法二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Z_printBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt;  levelOrder(TreeNode root)&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>) ((LinkedList&lt;TreeNode&gt;) queue).add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queue.size();i--)&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(list.size()%<span class="number">2</span>==<span class="number">0</span>) tmp.addLast(node.val);</span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) ((LinkedList&lt;TreeNode&gt;) queue).add(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) ((LinkedList&lt;TreeNode&gt;) queue).add(node.right);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>从前序序列和中序序列构造二叉树</title>
    <url>/2020/06/25/%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="从前序和中序序列构造二叉树"><a class="markdownIt-Anchor" href="#从前序和中序序列构造二叉树"></a> 从前序和中序序列构造二叉树</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>由中序序列和前序序列构造二叉树。</p>
<h2 id="问题求解"><a class="markdownIt-Anchor" href="#问题求解"></a> 问题求解</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PI_BuildTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preOrder,<span class="keyword">int</span>[] inOrder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildHelper(preOrder,<span class="number">0</span>,preOrder.length,inOrder,<span class="number">0</span>,inOrder.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildHelper</span><span class="params">(<span class="keyword">int</span>[] preOrder,<span class="keyword">int</span> p_start,<span class="keyword">int</span> p_end,<span class="keyword">int</span>[] inOrder,<span class="keyword">int</span> i_start,<span class="keyword">int</span> i_end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_start==p_end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> root_val=preOrder[<span class="number">0</span>];</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        <span class="comment">//在中序中找到根结点位置</span></span><br><span class="line">        <span class="keyword">int</span> i_root_index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=i_start;i&lt;i_end;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inOrder[i]==root_val)&#123;</span><br><span class="line">                i_root_index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftNum=i_root_val-i_start;</span><br><span class="line">        root.left=buildHelper(preOrder,p_start+<span class="number">1</span>,p_start+leftNum+<span class="number">1</span>,inOrder,i_start,i_root_index);</span><br><span class="line">        root.right=buildHelper(inOrder,p_start+leftNum+<span class="number">1</span>,p_end,inOrder,i_root_index+<span class="number">1</span>,i_end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] preOrder=&#123;<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] inOrder=&#123;<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        PI_BuildTree pi_buildTree=<span class="keyword">new</span> PI_BuildTree();</span><br><span class="line">        pi_buildTree.buildTree(preOrder,inOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上边的代码很好理解，但存在一个问题，在中序遍历中找到根节点的位置每次都得遍历中序遍历的数组去寻找，参考这里 ，我们可以用一个HashMap把中序遍历数组的每个元素的值和下标存起来，这样寻找根节点的位置就可以直接得到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span>[] inorder)</span></span>&#123;</span><br><span class="line">        <span class="comment">//把中序序列存入一个HashMap</span></span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.length;i++)&#123;</span><br><span class="line">            map.put(inorder[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(preorder,<span class="number">0</span>,preorder.length,inorder,<span class="number">0</span>,inorder.length,map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTreeHelper</span><span class="params">(<span class="keyword">int</span>[] preorder,<span class="keyword">int</span> p_start,<span class="keyword">int</span> p_end,<span class="keyword">int</span>[] inorder,<span class="keyword">int</span> i_start,<span class="keyword">int</span> i_end,HashMap&lt;Integer,Integer&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_start==p_end) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> root_val=preorder[p_start];</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(root_val);</span><br><span class="line">        <span class="comment">//获取根结点在中序中的索引</span></span><br><span class="line">        <span class="keyword">int</span> i_root_index=map.get(root_val);</span><br><span class="line">        <span class="keyword">int</span> leftnum=i_root_index-i_start;</span><br><span class="line">        root.left=buildTreeHelper(preorder,p_start+<span class="number">1</span>,p_start+<span class="number">1</span>+leftnum,inorder,i_start,i_root_index,map);</span><br><span class="line">        root.right=buildTreeHelper(preorder,p_start+<span class="number">1</span>+leftnum,p_end,inorder,i_root_index+<span class="number">1</span>,i_end,map);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最大深度</title>
    <url>/2020/06/23/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="二叉树的最大深度"><a class="markdownIt-Anchor" href="#二叉树的最大深度"></a> 二叉树的最大深度</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一棵二叉树，求其深度。</p>
<h2 id="问题详解"><a class="markdownIt-Anchor" href="#问题详解"></a> 问题详解</h2>
<h3 id="1-递归"><a class="markdownIt-Anchor" href="#1-递归"></a> 1、递归</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDeep</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=maxDeep(root.left);</span><br><span class="line">        <span class="keyword">int</span> right=maxDeep(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于bfs的思想"><a class="markdownIt-Anchor" href="#基于bfs的思想"></a> 基于BFS的思想</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDeep</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    list.add(root);</span><br><span class="line">    <span class="keyword">int</span> maxDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">        maxDepth++;</span><br><span class="line">        <span class="keyword">int</span> levelsize=list.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;levelsize;i++)&#123;</span><br><span class="line">            TreeNode node=list.poll();</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) list.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) list.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于dfs的思想"><a class="markdownIt-Anchor" href="#基于dfs的思想"></a> 基于DFS的思想</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DFS迭代实现二叉树最大深度</span></span><br><span class="line"><span class="comment"> * 时间复杂度O(n)</span></span><br><span class="line"><span class="comment"> * 空间复杂度:线性表最差O(n)、二叉树完全平衡最好O(logn)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最大深度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxDepth2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Pair&lt;TreeNode, Integer&gt;&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    stack.push(<span class="keyword">new</span> Pair&lt;&gt;(root, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">int</span> maxDepth = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//DFS实现前序遍历，每个节点记录其所在深度</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        Pair&lt;TreeNode, Integer&gt; pair = stack.pop();</span><br><span class="line">        TreeNode node = pair.first;</span><br><span class="line">        <span class="comment">//DFS过程不断比较更新最大深度</span></span><br><span class="line">        maxDepth = Math.max(maxDepth, pair.second);</span><br><span class="line">        <span class="comment">//记录当前节点所在深度</span></span><br><span class="line">        <span class="keyword">int</span> curDepth = pair.second;</span><br><span class="line">        <span class="comment">//当前节点的子节点入栈，同时深度+1</span></span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(<span class="keyword">new</span> Pair&lt;&gt;(node.right, curDepth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(<span class="keyword">new</span> Pair&lt;&gt;(node.left, curDepth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中的最大矩形</title>
    <url>/2020/06/23/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h1 id="柱状图中的最大矩形"><a class="markdownIt-Anchor" href="#柱状图中的最大矩形"></a> 柱状图中的最大矩形</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>
<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png" alt="" /></p>
<p>如图，最大矩形面积为10。</p>
<h2 id="问题解决"><a class="markdownIt-Anchor" href="#问题解决"></a> 问题解决</h2>
<p>1、暴力法</p>
<p>设置两个指针，第一个指针<strong>i</strong>从第一个柱形到最后一个柱形，第二个指针<strong>j</strong>从i开始遍历到尾，实现穷举，每一轮找出一个最大面积。</p>
<p>2、代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Area=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;heights.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> h=Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;heights.length;j++)&#123;</span><br><span class="line">                h=Math.min(h,height[j]);</span><br><span class="line">                Area=Math.max(Area,(j-i+<span class="number">1</span>)*h);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵置零</title>
    <url>/2020/06/20/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="矩阵置零"><a class="markdownIt-Anchor" href="#矩阵置零"></a> 矩阵置零</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个 <em>m</em> x <em>n</em> 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a><strong>算法</strong>。**</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZero</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> R=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> C=matrix[<span class="number">0</span>].length;</span><br><span class="line">        Set&lt;Integer&gt; row=<span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        Set&lt;Integer&gt; col=<span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">       <span class="comment">//遍历原始矩阵，找到值为0的行标和列标。并存储起来。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;R;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;C;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">                    row.add(i);</span><br><span class="line">                    col.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//迭代原始矩阵，对于每个格子检查行 r 和列 c 是否在相应set中，如果是就将矩阵格子的值设为 0。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;R;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;C;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row.contains(i)||col.contains(j))&#123;</span><br><span class="line">                    matrix[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/2020/06/18/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="爬楼梯"><a class="markdownIt-Anchor" href="#爬楼梯"></a> 爬楼梯</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>**注意：**给定 <em>n</em> 是一个正整数。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>可考虑动态规划进行解决，每次只能爬一阶或两阶，也就是当前位置只能由前一个位置或前两个位置得到，于是列出转移方程dp[i]=dp[i-1]+dp[i-2]，即两种情况加和。继续判断起始情况，当台阶数为0，定义可能爬楼梯的情况为1，只有只有后面计算才符合转移方程；当台阶数为1，可能爬楼梯的情况为1。最后爬完楼梯，可能的情况就是dp[n]。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=(dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>单词搜索</title>
    <url>/2020/06/17/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h1 id="单词搜索"><a class="markdownIt-Anchor" href="#单词搜索"></a> 单词搜索</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个二维网格和一个单词，找出该单词是否存在于网格中。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;],</span><br><span class="line">  [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;],</span><br><span class="line">  [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">给定 word = &quot;ABCCED&quot;, 返回 true</span><br><span class="line">给定 word = &quot;SEE&quot;, 返回 true</span><br><span class="line">给定 word = &quot;ABCB&quot;, 返回 false</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p><strong>DFS</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用于标记是否已经找到了解</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span> || board[<span class="number">0</span>].length == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(board, i, j, word, <span class="number">0</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> i, <span class="keyword">int</span> j, String word, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == word.length()) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length </span><br><span class="line">                || board[i][j] != word.charAt(cur)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果没有找到解，则继续DFS</span></span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">            board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            <span class="keyword">boolean</span> ret1 = dfs(board, i + <span class="number">1</span>, j, word, cur + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">boolean</span> ret2 = dfs(board, i - <span class="number">1</span>, j, word, cur + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">boolean</span> ret3 = dfs(board, i, j + <span class="number">1</span>, word, cur + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">boolean</span> ret4 = dfs(board, i, j - <span class="number">1</span>, word, cur + <span class="number">1</span>);</span><br><span class="line">            board[i][j] = c;</span><br><span class="line">            <span class="keyword">return</span> ret1 || ret2 || ret3 || ret4;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//找到解了，直接结束DFS并返回，这就是剪枝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>附：一.System.arraycopy（两数组合并）使用的基本定义<br />
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</p>
<p>src:源数组;</p>
<p>srcPos:源数组要复制的起始位置;</p>
<p>dest:目的数组;</p>
<p>destPos:目的数组放置的起始位置;</p>
<p>length:复制的长度.<br />
————————————————</p>
<p><strong>回溯</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] direction=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExit</span><span class="params">(<span class="keyword">char</span>[][] board,String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(word==<span class="keyword">null</span>||word.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(board==<span class="keyword">null</span>||board.length==<span class="number">0</span>||board[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m=board.length;</span><br><span class="line">        n=board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;m;r++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;n;c++)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span> curLen, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">boolean</span>[][] visited, <span class="keyword">char</span>[][] board, String word)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(curLen==word.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;m || c&lt;<span class="number">0</span> || c&gt;n || visited[r][c] || board[r][c]!=word.charAt(curLen))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[r][c]=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//选择</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] d:direction)&#123;</span><br><span class="line">            <span class="keyword">if</span>(backtracking(curLen+<span class="number">1</span>,r+d[<span class="number">0</span>],r+d[<span class="number">1</span>],visited,board,word))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//撤销</span></span><br><span class="line">        visited[r][c]=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>不同路径</title>
    <url>/2020/06/15/%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="不同路径"><a class="markdownIt-Anchor" href="#不同路径"></a> 不同路径</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p>
<p>问总共有多少条不同的路径？</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><img src="https://pic.leetcode-cn.com/aeddbbf89e8b58c29a09b941ca5ec5298403a44f220fcf6f7689b48fce13397d-robot_maze.png" alt="" /></p>
<p>分析题意可知，机器人只能往下或右移动，也就是说当前格等于其左与其上的和。</p>
<p>转换为起点到终点的路径的话，则很明显，第一行和第一列的格子值都为1，也就是到达该格的路径只有一条，从左边来或从上边来。而对于中间的格子，可从左或上，格子值也就是可能的路径数等于左边加上边之和。</p>
<h2 id="问题求解"><a class="markdownIt-Anchor" href="#问题求解"></a> 问题求解</h2>
<p>代码一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] mn=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) mn[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++) mn[j][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                mn[i][j]=mn[i-<span class="number">1</span>][j]+mn[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mn[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最大子序和</title>
    <url>/2020/06/15/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="最大子序和"><a class="markdownIt-Anchor" href="#最大子序和"></a> 最大子序和</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>如何判断最大呢？可定义一个sum=0，result=nums[0]。遍历数组元素，如果sum&lt;=0，则表明对最大无益，直接跳到sum=nums[i]；若sum&gt;0，说明对最大有益，则sum+=nums[i]；如何每轮循环取最大值result=max(sum，result)。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxValue</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>,res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                sum=c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum+=c;</span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏</title>
    <url>/2020/06/13/%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h1 id="跳跃游戏"><a class="markdownIt-Anchor" href="#跳跃游戏"></a> 跳跃游戏</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置<strong>可以跳跃的最大长度</strong>。</p>
<p>判断你是否能够到达最后一个位置。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>贪心思路</strong></p>
<p>设想一下，对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 x+nums[x]，这个值大于等于 y，即x+nums[x]≥y，那么位置 y 也可以到达。</p>
<p>换句话说，对于每一个可以到达的位置 x，它使得 x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。</p>
<p>这样以来，我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用x+nums[x] 更新 最远可以到达的位置。</p>
<p>在遍历的过程中，如果 最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">int</span> rightmost=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;=rightmost)&#123;</span><br><span class="line">                rightmost=Math.max(rightmost,i+nums[i]);</span><br><span class="line">                <span class="keyword">if</span>(rightmost&gt;=len-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>合并区间</title>
    <url>/2020/06/13/%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="合并区间"><a class="markdownIt-Anchor" href="#合并区间"></a> 合并区间</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给出一个区间的集合，请合并所有重叠的区间。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals)&#123;</span><br><span class="line">        <span class="comment">//先按区间起始数排序</span></span><br><span class="line">        Arrays.sort(intervals,(v1,v2)-&gt;v1[<span class="number">0</span>]-v2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> idx=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] c:intervals)&#123;</span><br><span class="line">            <span class="keyword">if</span>(idx==-<span class="number">1</span>||c[<span class="number">0</span>]&gt;res[idx][<span class="number">1</span>])&#123;</span><br><span class="line">                res[++idx]=c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[idx][<span class="number">1</span>]=Math.max(res[idx][<span class="number">1</span>],c[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//Arrays的copyOf()方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。</span></span><br><span class="line">      <span class="comment">//copyOf()的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/2020/06/13/%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h1 id="加一"><a class="markdownIt-Anchor" href="#加一"></a> 加一</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p>
<p>最高位数字存放在数组的首位， 数组中<strong>每个元素只存储单个数字</strong>。</p>
<p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;<span class="comment">//从尾部开始，判断每位是否进位</span></span><br><span class="line">            nums[i]++;</span><br><span class="line">            nums[i]=nums[i]%<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>) <span class="keyword">return</span> nums;<span class="comment">//若无进位，直接返回尾数+1后的结果，否则把进位加到前一位（nums[i]++)。</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];<span class="comment">//直到遍历完还没有返回值的话，说明第一位还存在进位，需要扩充数组长度，并且第一位为1.</span></span><br><span class="line">        nums[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>字母异位词分组</title>
    <url>/2020/06/12/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h1 id="字母异位词分组"><a class="markdownIt-Anchor" href="#字母异位词分组"></a> 字母异位词分组</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>可以考虑使用HashMap来实现。键为字母异位词的排序结果，值为可能出现的各种组合。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    HashMap&lt;String, List&lt;String&gt;&gt; hash = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//HashMap键值对键不可以重复。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] s_arr = strs[i].toCharArray();</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(s_arr);</span><br><span class="line">        <span class="comment">//映射到 key</span></span><br><span class="line">        String key = String.valueOf(s_arr); </span><br><span class="line">        <span class="comment">//添加到对应的类中</span></span><br><span class="line">        <span class="keyword">if</span> (hash.containsKey(key)) &#123;</span><br><span class="line">            hash.get(key).add(strs[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;String&gt; temp = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            temp.add(strs[i]);</span><br><span class="line">            hash.put(key, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;(hash.values()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2020/06/07/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h1 id="接雨水"><a class="markdownIt-Anchor" href="#接雨水"></a> 接雨水</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="" /></p>
<p>如图，可接下6个单位的雨水。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>利用单调栈，单调栈就是永远保证栈内元素单调递增或递减。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">            <span class="comment">//当栈不空，判断当前指向height[i]是否大于上一个已入栈元素的高</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;height[stack.peek()]&lt;height[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> curIdx=stack.pop();</span><br><span class="line">                <span class="comment">//如果栈顶元素一直相等，那么一直pop出去，只留下第一个。</span></span><br><span class="line">                <span class="keyword">while</span>(!stack.isEmpty()&amp;&amp;height[stack.peek()]==height[curIdx])&#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> stackTop=stack.peek();</span><br><span class="line">                    <span class="comment">// stackTop此时指向的是此次接住的雨水的左边界的位置。右边界是当前的柱体，即i。</span></span><br><span class="line">                    <span class="comment">// Math.min(height[stackTop], height[i]) 是左右柱子高度的min，减去height[curIdx]就是雨水的高度。</span></span><br><span class="line">                    <span class="comment">// i - stackTop - 1 是雨水的宽度。</span></span><br><span class="line">                    ans += (Math.min(height[stackTop], height[i]) - height[curIdx]) * (i - stackTop - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.add(i);<span class="comment">//单调栈添加元素在此</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列</title>
    <url>/2020/06/07/%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="全排列"><a class="markdownIt-Anchor" href="#全排列"></a> 全排列</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>回溯</p>
<p><img src="https://pic.leetcode-cn.com/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png" alt="" /></p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        List&lt;Integer&gt; path=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        dfs(nums,len,<span class="number">0</span>,path,visited,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> len,<span class="keyword">int</span> depth,List&lt;Integer&gt; path,<span class="keyword">boolean</span>[] visited,List&lt;List&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(depth==len)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                path.add(nums[i]);</span><br><span class="line">                visited[i]=<span class="keyword">true</span>;</span><br><span class="line">                dfs(nums,len,depth+<span class="number">1</span>,path,visited,res);<span class="comment">//递归下一层</span></span><br><span class="line">                visited[i]=<span class="keyword">false</span>; </span><br><span class="line">                path.remove(path.size()-<span class="number">1</span>);<span class="comment">//去除某个元素。 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标准回溯算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permutelist=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums,permutelist,list,visited);</span><br><span class="line">        <span class="keyword">return</span> permutelist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; permutelist,List&lt;Integer&gt; list,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">//加入满足条件的结果。</span></span><br><span class="line">        <span class="keyword">if</span>(list.size()==nums.length)&#123;</span><br><span class="line">            permutelist.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//删除不合法的选择</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            visited[i]=<span class="keyword">true</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            <span class="comment">//进入下一层决策树</span></span><br><span class="line">            backtrack(nums,permutelist,list,visited);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            visited[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="全排列ii"><a class="markdownIt-Anchor" href="#全排列ii"></a> 全排列Ⅱ</h1>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>在实现上，和 Permutations 不同的是要先排序，然后在添加一个元素时，判断这个元素是否等于前一个元素，如果等于，并且前一个元素还未访问，那么就跳过这个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主函数</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permutelist=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);<span class="comment">//排序</span></span><br><span class="line">        <span class="keyword">boolean</span>[] visited=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">        backtrack(nums,permutelist,list,visited);</span><br><span class="line">        <span class="keyword">return</span> permutelist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums,List&lt;List&lt;Integer&gt;&gt; permutelist,List&lt;Integer&gt; list,<span class="keyword">boolean</span>[] visited)</span></span>&#123;</span><br><span class="line">        <span class="comment">//加入满足条件的结果。</span></span><br><span class="line">        <span class="keyword">if</span>(list.size()==nums.length)&#123;</span><br><span class="line">            permutelist.add(<span class="keyword">new</span> ArrayList&lt;&gt;(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="comment">//跳过重复</span></span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; !visited[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//删除不合法的选择</span></span><br><span class="line">            <span class="keyword">if</span>(visited[i])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//做选择</span></span><br><span class="line">            visited[i]=<span class="keyword">true</span>;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">            <span class="comment">//进入下一层决策树</span></span><br><span class="line">            backtrack(nums,permutelist,list,visited);</span><br><span class="line">            <span class="comment">//撤销选择</span></span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">            visited[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的第一个正数</title>
    <url>/2020/06/07/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h1 id="缺失的第一个正数"><a class="markdownIt-Anchor" href="#缺失的第一个正数"></a> 缺失的第一个正数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>将数组存入一个hashset，然后从i=1开始遍历，判断hashset中是否存在i元素，不存在则返回这个i，若一直到nums.length都存在，则返回nums.length+1。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        Set&lt;Integer&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:nums)&#123;</span><br><span class="line">            set.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(i))&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转图像</title>
    <url>/2020/06/07/%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h1 id="旋转图像"><a class="markdownIt-Anchor" href="#旋转图像"></a> 旋转图像</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>根据n×n矩阵旋转的特性，可知其能由原矩阵进行置换，然后对每行颠倒一下首尾得到。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=matrix.length;</span><br><span class="line">        <span class="comment">//转置(i,j对换)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[j][i];</span><br><span class="line">                matrix[j][i]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每行颠倒一下顺序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">                matrix[i][j]=matrix[i][n-j-<span class="number">1</span>];</span><br><span class="line">                matrix[i][n-j-<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>合并k个排序数组</title>
    <url>/2020/06/05/%E5%90%88%E5%B9%B6k%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="合并k个排序链表"><a class="markdownIt-Anchor" href="#合并k个排序链表"></a> 合并k个排序链表</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>合并 <em>k</em> 个排序链表，返回合并后的排序链表。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>两个排序链表合并会吧？然后k个链表就两两合并啦。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLinkedlist</span><span class="params">(ListNode[] lists)</span></span>&#123;</span><br><span class="line">        ListNode res=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode list:lists)</span><br><span class="line">            res=mergeTwoLists(res,list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            l1.next=mergeTwoLists(l1.next,l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        l2.next=mergeTwoLists(l1,l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个有序链表归并的迭代法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">        ListNode dummyNode=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode node=dummyNode;</span><br><span class="line">        <span class="keyword">while</span>(l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">                node.next=l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node.next=l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        node.next=l1==<span class="keyword">null</span>? l2:l1;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>两数相除</title>
    <url>/2020/06/04/%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h1 id="两数相除"><a class="markdownIt-Anchor" href="#两数相除"></a> 两数相除</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。</p>
<p>返回被除数 dividend 除以除数 divisor 得到的商。</p>
<h2 id="问题解决"><a class="markdownIt-Anchor" href="#问题解决"></a> 问题解决</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们可以以100/3为例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2^n是1，2，4，8...2^31这种数，当n为31时，这个数特别大，100/2^n是一个很小的数，肯定是小于3的，所以循环下来，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 当n=5时，100/32=3, 刚好是大于等于3的，这时我们将100-32*3=4，也就是减去了32个3，接下来我们再处理4，同样手法可以再减去一个3</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 所以一共是减去了33个3，所以商就是33</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这其中得处理一些特殊的数，比如divisor是不能为0的，Integer.MIN_VALUE和Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> negative;</span><br><span class="line">        negative = (dividend ^ divisor) &lt;<span class="number">0</span>;<span class="comment">//用异或来计算是否符号相异</span></span><br><span class="line">        <span class="comment">//全部取正数计算，最后加上正负。</span></span><br><span class="line">        <span class="keyword">long</span> t = Math.abs((<span class="keyword">long</span>) dividend);<span class="comment">//t 被除数</span></span><br><span class="line">        <span class="keyword">long</span> d= Math.abs((<span class="keyword">long</span>) divisor);<span class="comment">//d 除数</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">31</span>; i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((t&gt;&gt;i)&gt;=d) &#123;<span class="comment">//(t除2的i次方是否大于等于除数)</span></span><br><span class="line">                result+=<span class="number">1</span>&lt;&lt;i;<span class="comment">//加上2^i</span></span><br><span class="line">                t-=d&lt;&lt;i;<span class="comment">//此处相当于t=t-(d*2^i)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? -result : result;<span class="comment">//符号相异取反</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//左移。&lt;&lt; 相当于乘2   例：a=a&lt;&lt;2等同于a=a*2.</span></span><br><span class="line"><span class="comment">//右移。&gt;&gt; 相当于除2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索旋转排序数组</title>
    <url>/2020/06/04/%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="搜索旋转排序数组"><a class="markdownIt-Anchor" href="#搜索旋转排序数组"></a> 搜索旋转排序数组</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>搜索一个<strong>给定的目标值</strong>，如果数组中存在这个目标值，则<strong>返回它的索引</strong>，否则返回 -1 。</p>
<p>你可以假设数组中不存在重复的元素。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [4,5,6,7,0,1,2], target = 6</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>根据旋转数组的特性将其分为左右两段，二分查找。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lo=<span class="number">0</span>,hi=nums.length-<span class="number">1</span>,mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">            mid=lo+(hi-lo)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断nums[mid]在旋转数组的左段还是右段</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;=nums[lo])&#123;<span class="comment">//在左段</span></span><br><span class="line">                <span class="comment">//再判断target在mid的左边还是右边</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;=nums[lo]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    hi=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    lo=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//在右段</span></span><br><span class="line">                <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[hi])&#123;</span><br><span class="line">                    lo=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    hi=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项</title>
    <url>/2020/06/04/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="删除排序数组中的重复项"><a class="markdownIt-Anchor" href="#删除排序数组中的重复项"></a> 删除排序数组中的重复项</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个排序数组，你需要在 <strong>原地</strong> 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>定义两个指针p，q。p=0,q=1,若nums[q]！=nums[p]，则将nums[q]赋给nums[p+1]。如此，实现了一次遍历，原地删除。原地理解为只操作nums。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p=<span class="number">0</span>,q=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(q&lt;nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[p]!=nums[q])&#123;</span><br><span class="line">                nums[p+<span class="number">1</span>]=nums[q];</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            q++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/06/03/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a class="markdownIt-Anchor" href="#在排序数组中查找元素的第一个和最后一个位置"></a> 在排序数组中查找元素的第一个和最后一个位置</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>你的算法时间复杂度必须是 O(log n) 级别。</p>
<p>如果数组中不存在目标值，返回 [-1, -1]。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>定义一个存储该元素起始索引和终止索引两个元素的数组。初始化为{-1，-1}，从头开始遍历到第一个元素，赋给数组的第一个元素。如果第一个匹配索引找不到，直接返回{-1，-1}。如果第一个索引找到，则继续从数组尾开始遍历找到第二个匹配索引，赋给数组第二个元素。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchRange</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getRange(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] range=&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//找到target的第一个匹配下标索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;<span class="comment">//从头开始找第一个匹配</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]==target)&#123;</span><br><span class="line">                range[<span class="number">0</span>]=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找不到，直接返回（-1，-1）</span></span><br><span class="line">        <span class="keyword">if</span>(range[<span class="number">0</span>]==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> range;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到了第一个匹配索引，继续寻找第二个匹配索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=nums.length-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]==target)&#123;</span><br><span class="line">                range[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:range)</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        <span class="keyword">return</span> range;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">11</span>&#125;;</span><br><span class="line">        SearchRange searchRange=<span class="keyword">new</span> SearchRange();</span><br><span class="line">        searchRange.getRange(nums,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>括号生成</title>
    <url>/2020/06/03/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h1 id="括号生成"><a class="markdownIt-Anchor" href="#括号生成"></a> 括号生成</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>数字 <em>n</em> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[</span><br><span class="line">       &quot;((()))&quot;,</span><br><span class="line">       &quot;(()())&quot;,</span><br><span class="line">       &quot;(())()&quot;,</span><br><span class="line">       &quot;()(())&quot;,</span><br><span class="line">       &quot;()()()&quot;</span><br><span class="line">     ]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>使用深度优先遍历算法，定义左右括号的数目和当前字符串。如果左括号和右括号数目都为0，返回当前这个res。</p>
<p>否则，左括号还有剩余，拼接一个左括号；右括号还有剩余，拼接一个右括号。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(n, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, String curStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123; <span class="comment">// 左右括号都不剩余了，递归终止</span></span><br><span class="line">            res.add(curStr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果左括号还剩余的话，可以拼接左括号</span></span><br><span class="line">            dfs(left - <span class="number">1</span>, right, curStr + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; left) &#123; <span class="comment">// 如果右括号剩余多于左括号剩余的话，可以拼接右括号</span></span><br><span class="line">            dfs(left, right - <span class="number">1</span>, curStr + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>罗马数字转整数</title>
    <url>/2020/06/02/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="罗马数字转整数"><a class="markdownIt-Anchor" href="#罗马数字转整数"></a> 罗马数字转整数</h1>
<h2 id="问题产生"><a class="markdownIt-Anchor" href="#问题产生"></a> 问题产生</h2>
<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>
<h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2>
<p>按照题目的描述，可以总结如下规则：</p>
<p>罗马数字由 I,V,X,L,C,D,M 构成；<br />
当小值在大值的左边，则减小值，如 IV=5-1=4；<br />
当小值在大值的右边，则加小值，如 VI=5+1=6；<br />
由上可知，右值永远为正，因此最后一位必然为正。<br />
一言蔽之，把一个小值放在大值的左边，就是做减法，否则为加法。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RomeToInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rometoint</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> preNum=getValue(s.charAt(<span class="number">0</span>));<span class="comment">//第0位置为pre</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;<span class="comment">//第1位置为当前cur，与pre进行比较。</span></span><br><span class="line">            <span class="keyword">int</span> curNum=getValue(s.charAt(i));</span><br><span class="line">            <span class="keyword">if</span>(curNum&lt;=preNum)&#123;<span class="comment">//当前值小于等于先前值，则sum加上pre值</span></span><br><span class="line">                sum+=preNum;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sum-=preNum;<span class="comment">//否则减去pre值</span></span><br><span class="line">            &#125;</span><br><span class="line">            preNum=curNum;<span class="comment">//每次循环后pre跟着往后递推，跳出循环后，preNum等于最后一位。</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum+=preNum; <span class="comment">//循环跳出后，计算了前n-1的累积值，需要再加上最后一位。由上分析，最后一位必为正数。</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//罗马与阿拉伯数字转换表</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (ch)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:<span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:<span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:<span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:<span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">default</span>:<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s=<span class="string">&quot;XXVII&quot;</span>;</span><br><span class="line">        RomeToInt romeToInt=<span class="keyword">new</span> RomeToInt();</span><br><span class="line">        System.out.println(romeToInt.rometoint(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>电话号码的字母组合</title>
    <url>/2020/06/02/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="电话号码的字母组合"><a class="markdownIt-Anchor" href="#电话号码的字母组合"></a> 电话号码的字母组合</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="" /></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits==<span class="keyword">null</span>||digits.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character,String&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        backTrack(list, digits, map, <span class="number">0</span>, <span class="keyword">new</span> StringBuilder());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(List&lt;String&gt; list,String digits,Map&lt;Character,String&gt; map,<span class="keyword">int</span> index,StringBuilder sb)</span></span>&#123;</span><br><span class="line">        <span class="comment">// recursion teminator</span></span><br><span class="line">        <span class="keyword">if</span> (sb.length() == digits.length()) &#123;</span><br><span class="line">            list.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process current logic</span></span><br><span class="line">        String value = map.get(digits.charAt(index));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; value.length(); j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// drill down</span></span><br><span class="line">            backTrack(list, digits, map, index + <span class="number">1</span>, sb.append(value.charAt(j)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// reverse states</span></span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits==<span class="keyword">null</span>||digits.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String[] letter_Map=&#123;<span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        res.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.length();i++)&#123;<span class="comment">//length用作函数调用时加括号</span></span><br><span class="line">            String letters=letter_Map[digits.charAt(i)-<span class="string">&#x27;0&#x27;</span>];<span class="comment">//某字符减去0字符等于该字符对应的数字。</span></span><br><span class="line">            <span class="keyword">int</span> size=res.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line">                String temp=res.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;letters.length();k++)&#123;</span><br><span class="line">                    res.add(temp+letters.charAt(k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>另解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  Map&lt;String, String&gt; phone = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">    put(<span class="string">&quot;2&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;4&quot;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;5&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;6&quot;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;7&quot;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;8&quot;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">    put(<span class="string">&quot;9&quot;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">  &#125;&#125;;</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String combination, String next_digits)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if there is no more digits to check</span></span><br><span class="line">    <span class="keyword">if</span> (next_digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// the combination is done</span></span><br><span class="line">      output.add(combination);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if there are still digits to check</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// iterate over all letters which map </span></span><br><span class="line">      <span class="comment">// the next available digit</span></span><br><span class="line">      String digit = next_digits.substring(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">//返回第一个数字</span></span><br><span class="line">      String letters = phone.get(digit);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++) &#123;<span class="comment">//letters表示该数字在phone中对应的字符串</span></span><br><span class="line">        String letter = phone.get(digit).substring(i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// append the current letter to the combination</span></span><br><span class="line">        <span class="comment">// and proceed to the next digits</span></span><br><span class="line">        backtrack(combination + letter, next_digits.substring(<span class="number">1</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (digits.length() != <span class="number">0</span>)</span><br><span class="line">      backtrack(<span class="string">&quot;&quot;</span>, digits);</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/2020/06/02/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="三数之和"><a class="markdownIt-Anchor" href="#三数之和"></a> 三数之和</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意：答案中不可以包含重复的三元组。</strong></p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>双指针法思路</strong>：</p>
<ol>
<li>先将数组由小到大排序。</li>
<li>固定3个指针中的一个k，初始化为数组第一个元素索引0, 然后i=k+1，j=nums.length-1。k&lt;nums.length-2,循环遍历。</li>
<li>若nums[k]&gt;0,显然后面元素都大于0，直接break。</li>
<li>若num[i]==nums[++i], 重复元素，直接continue跳过。</li>
<li>循环过程中判断nums[k]+nums[i]+nums[j]==0? 符合加入list，不符合继续遍历，同样对++i，–j，若重复则直接跳到不重复元素处。</li>
</ol>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeSum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; getthreeSum(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        Arrays.sort(nums);<span class="comment">//对数组进行排序</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;nums.length-<span class="number">2</span>;k++)&#123;<span class="comment">//固定一个k，判断i，j</span></span><br><span class="line">            <span class="keyword">if</span>(nums[k]&gt;<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//num[k]&gt;0则直接跳出</span></span><br><span class="line">            <span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;nums[k]==nums[k-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//对k，当前nums[k]和前一个元素nums[k-1]相等的话，为避免重复跳过。</span></span><br><span class="line">            <span class="keyword">int</span> i=k+<span class="number">1</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j)&#123;<span class="comment">//i,j相遇则跳出循环</span></span><br><span class="line">                <span class="keyword">int</span> sum=nums[k]+nums[i]+nums[j];</span><br><span class="line">                <span class="keyword">if</span>(sum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]==nums[++i]);<span class="comment">//和小于0，则i++。另外此处的while很巧妙，对nums[i]与下一个元素nums[++i]相等的情况直接跳过。while之后直接到了一个新的nums[i]元素。</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]==nums[--j]);<span class="comment">//此处j与上同。</span></span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[k],nums[i],nums[j])));<span class="comment">//else情况sum==0，加入list。</span></span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]==nums[++i]);<span class="comment">//继续++i，--j直到i==j。</span></span><br><span class="line">                    <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]==nums[--j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//多个ArrayList遍历输出</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator it = list.iterator(); it.hasNext();) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;-<span class="number">4</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        ThreeSum threeSum=<span class="keyword">new</span> ThreeSum();</span><br><span class="line">        threeSum.getthreeSum(nums);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的倒数第n个结点</title>
    <url>/2020/06/02/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACn%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="删除链表的倒数第n个结点"><a class="markdownIt-Anchor" href="#删除链表的倒数第n个结点"></a> 删除链表的倒数第n个结点</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>定义一个pre结点，pre.next=head。然后定义两个指针first，second。first先走n步，然后一起走，当first为空跳出，此时second指向了被删结点的前一个结点，执行删除。最后返回pre.next。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        ListNode pre=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        pre.next=head;</span><br><span class="line">        ListNode first=pre,second=pre;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            first=first.next;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(first.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            first=first.next;</span><br><span class="line">            second=second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        second.next=second.next.next;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2020/06/01/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="排序算法汇总"><a class="markdownIt-Anchor" href="#排序算法汇总"></a> 排序算法汇总</h1>
<p><img src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200603174343.png" alt="" /></p>
<h2 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h2>
<p><strong>思路</strong>：俩俩交换，大的放在后面，第一次排序后最大值已在数组末尾。需要n-1次排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="comment">//装载临时变量</span></span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">//记录是否发生了置换，0，没有置换；1，置换了。</span></span><br><span class="line">        <span class="keyword">int</span> isChange;</span><br><span class="line">        <span class="comment">//记录执行次数</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//外层循环表示排序的趟数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//每排序一趟就重新初始化为0</span></span><br><span class="line">            isChange=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//内层循环表示当前趟需要比较的次数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array.length-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//两两比较，前大于后，则交换。</span></span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp=array[j];</span><br><span class="line">                    array[j]=array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>]=temp;</span><br><span class="line">                    <span class="comment">//发生了置换</span></span><br><span class="line">                    isChange=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果该趟排序未发生置换，说明后面有序，不必走完所有趟。</span></span><br><span class="line">            <span class="keyword">if</span>(isChange==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印输出排序后的序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:array)</span><br><span class="line">            System.out.print(c+<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        BubbleSort bubbleSort=<span class="keyword">new</span> BubbleSort();</span><br><span class="line"></span><br><span class="line">        bubbleSort.bubbleSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h2>
<p><strong>思路</strong>：找到数组中最大的元素，与数组最后一位元素交换。当只有一个数时，则不需要选择了，因此需要<code>n-1</code>趟排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="comment">//记录当前趟数最大值的角标</span></span><br><span class="line">        <span class="keyword">int</span> pos;</span><br><span class="line">        <span class="comment">//外层循环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//每趟pos重新置0</span></span><br><span class="line">            pos=<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//内层循环得到该趟最大值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;array.length-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j]&gt;array[pos])&#123;</span><br><span class="line">                    pos=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//该趟最大值与最后一个数交换</span></span><br><span class="line">            <span class="keyword">int</span> temp=array[pos];</span><br><span class="line">            array[pos]=array[array.length-i-<span class="number">1</span>];</span><br><span class="line">            array[array.length-i-<span class="number">1</span>]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:array)</span><br><span class="line">            System.out.print(c+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        SelectSort selectSort=<span class="keyword">new</span> SelectSort();</span><br><span class="line">        selectSort.selectSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h2>
<p><strong>思路</strong>：将一个元素插入到已有序的数组中，在初始时未知是否存在有序的数据，因此将元素<strong>第一个元素看成是有序的</strong>。与有序的数组进行比较，<strong>比它大则直接放入，比它小则移动数组元素的位置，找到个合适的位置插入</strong>。当只有一个数时，则不需要插入了，因此需要<code>n-1</code>趟排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="comment">//外层循环控制排序趟数，从1开始是因为把第0位视作有序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=array[i];</span><br><span class="line">            <span class="comment">//如果前一位（已排序的数据）比当前数据大，则进行循环比较后归为有序</span></span><br><span class="line">            <span class="keyword">int</span> j=i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;array[j]&gt;temp)&#123;</span><br><span class="line">                array[j+<span class="number">1</span>]=array[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            array[j+<span class="number">1</span>]=temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:array)</span><br><span class="line">            System.out.print(c+<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        InsertSort insertSort=<span class="keyword">new</span> InsertSort();</span><br><span class="line">        insertSort.insertSort(array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a class="markdownIt-Anchor" href="#快速排序"></a> 快速排序</h2>
<p><strong>思路</strong>：在数组中找一个元素(节点)，比它小的放在节点的左边，比它大的放在节点右边。一趟下来，比节点小的在左边，比节点大的在右边。不断执行这个操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=L;</span><br><span class="line">        <span class="keyword">int</span> j=R;</span><br><span class="line">        <span class="comment">//支点</span></span><br><span class="line">        <span class="keyword">int</span> pivot=array[(L+R)/<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            <span class="comment">//寻找比支点小的数</span></span><br><span class="line">            <span class="keyword">while</span> (pivot&lt;array[j])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//寻找比支点大的数</span></span><br><span class="line">            <span class="keyword">while</span> (pivot&gt;array[i])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将右边比支点小的数与左边比支点大的数进行交换</span></span><br><span class="line">            <span class="keyword">if</span>(i&lt;=j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp=array[i];</span><br><span class="line">                array[i]=array[j];</span><br><span class="line">                array[j]=temp;</span><br><span class="line"></span><br><span class="line">                i++;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上述while循环之后，完成了第一轮划分，j指向了pivot-1，i指向了pivot+1</span></span><br><span class="line">        <span class="keyword">if</span>(L&lt;j)&#123;</span><br><span class="line">            quickSort(array,L,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(R&gt;i)&#123;</span><br><span class="line">            quickSort(array,i,R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        QuickSort quickSort=<span class="keyword">new</span> QuickSort();</span><br><span class="line">        quickSort.quickSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:array)</span><br><span class="line">            System.out.print(c+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h2>
<p><strong>思路</strong>：将<strong>两个</strong>已<strong>排好序</strong>的数组<strong>合并</strong>成<strong>一个有序</strong>的数组,称之为归并排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mergerSort 划分原数组</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">// static方法就是没有this的方法。在static方法内部不能调用非静态方法，反过来是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本身来调用static方法。这实际上正是static方法的主要用途。(简而言之)方便在没有创建对象的情况下来进行调用（方法/变量）。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个元素，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(L==R) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> M=(L+R)/<span class="number">2</span>;</span><br><span class="line">            mergeSort(array,L,M);</span><br><span class="line">            mergeSort(array,M+<span class="number">1</span>,R);</span><br><span class="line">            merge(array,L,M+<span class="number">1</span>,R);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//归并</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> L,<span class="keyword">int</span> M,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义左右数组，并分别存储array元素。</span></span><br><span class="line">        <span class="keyword">int</span>[] leftArray=<span class="keyword">new</span> <span class="keyword">int</span>[M-L];</span><br><span class="line">        <span class="keyword">int</span>[] rightArray=<span class="keyword">new</span> <span class="keyword">int</span>[R-M+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&lt;M;i++)&#123;</span><br><span class="line">            leftArray[i-L]=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=M;i&lt;=R;i++)&#123;</span><br><span class="line">            rightArray[i-M]=array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右数组比较，小的放入新的array。</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k=L;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;leftArray.length&amp;&amp;j&lt;rightArray.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(leftArray[i]&lt;rightArray[j])&#123;</span><br><span class="line">                array[k]=leftArray[i];</span><br><span class="line">                k++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                array[k]=rightArray[j];</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左数组元素还没比完，直接放入array</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;leftArray.length)&#123;</span><br><span class="line">            array[k]=leftArray[i];</span><br><span class="line">            k++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右数组元素还没比完，直接放入array</span></span><br><span class="line">        <span class="keyword">while</span>(j&lt;rightArray.length)&#123;</span><br><span class="line">            array[k]=rightArray[j];</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array=&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        MergeSort ms=<span class="keyword">new</span> MergeSort();</span><br><span class="line">        ms.mergeSort(array,<span class="number">0</span>,array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:array)</span><br><span class="line">            System.out.print(c+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrays=&#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        maxheapify(arrays,arrays.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> size=arrays.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arrays.length;i++)&#123;</span><br><span class="line">            <span class="comment">//将当前堆顶元素（最大值）交换到数组倒数第一位、第二位、……</span></span><br><span class="line">            <span class="keyword">int</span> temp=arrays[<span class="number">0</span>];</span><br><span class="line">            arrays[<span class="number">0</span>]=arrays[arrays.length-<span class="number">1</span>-i];</span><br><span class="line">            arrays[arrays.length-<span class="number">1</span>-i]=temp;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            heapify(arrays,<span class="number">0</span>,size);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:arrays)</span><br><span class="line">            System.out.print(c+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arrays,<span class="keyword">int</span> currentrootnode,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentrootnode&lt;size)&#123;</span><br><span class="line">            <span class="keyword">int</span> left=currentrootnode*<span class="number">2</span>+<span class="number">1</span>;<span class="comment">//当前结点的左子结点索引</span></span><br><span class="line">            <span class="keyword">int</span> right=currentrootnode*<span class="number">2</span>+<span class="number">2</span>;<span class="comment">//当前结点的右子结点索引</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> max=currentrootnode;<span class="comment">//最大值结点索引初始化为当前结点</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arrays[max]&lt;arrays[left])&#123;<span class="comment">//若当前结点值小于左子结点，则最大值结点索引=left</span></span><br><span class="line">                    max=left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(right&lt;size)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arrays[max]&lt;arrays[right])&#123;<span class="comment">//若当前结点值小于左子结点，则最大值结点索引=right</span></span><br><span class="line">                    max=right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max!=currentrootnode)&#123; <span class="comment">//如果最大值结点索引不等于当前结点索引，交换最大值结点为当前结点</span></span><br><span class="line">                <span class="keyword">int</span> temp=arrays[max];</span><br><span class="line">                arrays[max]=arrays[currentrootnode];</span><br><span class="line">                arrays[currentrootnode]=temp;</span><br><span class="line"></span><br><span class="line">                heapify(arrays,max,size);<span class="comment">//</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成一次建堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxheapify</span><span class="params">(<span class="keyword">int</span>[] arrays,<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=size-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            heapify(arrays,i,size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>算法思维之二分法</title>
    <url>/2020/06/01/%E7%AE%97%E6%B3%95%E6%80%9D%E7%BB%B4%E4%B9%8B%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<h1 id="算法思维之二分法"><a class="markdownIt-Anchor" href="#算法思维之二分法"></a> 算法思维之二分法</h1>
<h2 id="二分查找框架"><a class="markdownIt-Anchor" href="#二分查找框架"></a> 二分查找框架</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：寻找一个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> right = nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1、为什么 while 循环的条件中是 &lt;=，而不是 &lt;</strong>？</p>
<p>答：因为初始化 <code>right</code> 的赋值是 <code>nums.length - 1</code>，即最后一个元素的索引，而不是 <code>nums.length</code>。</p>
<p>这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 <code>[left, right]</code>，后者相当于左闭右开区间 <code>[left, right)</code>，因为索引大小为 <code>nums.length</code> 是越界的。</p>
<p>我们这个算法中使用的是前者 <code>[left, right]</code> 两端都闭的区间。<strong>这个区间其实就是每次进行搜索的区间</strong>。</p>
<p>什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br></pre></td></tr></table></figure>
<p>但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？<strong>搜索区间为空的时候应该终止</strong>，意味着你没得找了，就等于没找到嘛。</p>
<p><code>while(left &lt;= right)</code> 的终止条件是 <code>left == right + 1</code>，写成区间的形式就是 <code>[right + 1, right]</code>，或者带个具体的数字进去 <code>[3, 2]</code>，可见<strong>这时候区间为空</strong>，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。</p>
<p><code>while(left &lt; right)</code> 的终止条件是 <code>left == right</code>，写成区间的形式就是 <code>[left, right]</code>，或者带个具体的数字进去 <code>[2, 2]</code>，<strong>这时候区间非空</strong>，还有一个数 2，但此时 while 循环终止了。也就是说这区间 <code>[2, 2]</code> 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。</p>
<p><strong>2、为什么</strong> <strong><code>left = mid + 1</code><strong><strong>，</strong></strong><code>right = mid - 1</code>****？我看有的代码是</strong> <strong><code>right = mid</code></strong> <strong>或者</strong> <strong><code>left = mid</code>****，没有这些加加减减，到底怎么回事，怎么判断</strong>？</p>
<p>答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。</p>
<p>刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 <code>[left, right]</code>。那么当我们发现索引 <code>mid</code> 不是要找的 <code>target</code> 时，下一步应该去搜索哪里呢？</p>
<p>当然是去搜索 <code>[left, mid-1]</code> 或者 <code>[mid+1, right]</code> 对不对？<strong>因为</strong> <strong><code>mid</code></strong> <strong>已经搜索过，应该从搜索区间中去除</strong>。</p>
<p><strong>3、此算法有什么缺陷</strong>？</p>
<p>答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。</p>
<p>比如说给你有序数组 <code>nums = [1,2,2,2,3]</code>，<code>target</code> 为 2，此算法返回的索引是 2，没错。但是如果我想得到 <code>target</code> 的左侧边界，即索引 1，或者我想得到 <code>target</code> 的右侧边界，即索引 3，这样的话此算法是无法处理的。</p>
<p>这样的需求很常见，<strong>你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了</strong>。</p>
<p>我们后续的算法就来讨论这两种二分查找的算法。</p>
<h2 id="寻找左侧边界的二分搜索"><a class="markdownIt-Anchor" href="#寻找左侧边界的二分搜索"></a> 寻找左侧边界的二分搜索</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 搜索区间为 [left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="寻找右侧边界的二分搜索"><a class="markdownIt-Anchor" href="#寻找右侧边界的二分搜索"></a> 寻找右侧边界的二分搜索</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 这里改成收缩左侧边界即可</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里改为检查 right 越界的情况，见下图</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>1、<strong>基本的二分查找算法</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">因为我们初始化 right = nums.length - <span class="number">1</span></span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+<span class="number">1</span> 和 right = mid-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br></pre></td></tr></table></figure>
<p>2、<strong>寻找左侧边界的二分查找</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br></pre></td></tr></table></figure>
<p>3、<strong>寻找右侧边界的二分查找：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + <span class="number">1</span></span><br><span class="line">所以最后无论返回 left 还是 right，必须减一</span><br></pre></td></tr></table></figure>
<p>4、<strong>统一化处理：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多水的容器</title>
    <url>/2020/06/01/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="盛最多水的容器"><a class="markdownIt-Anchor" href="#盛最多水的容器"></a> 盛最多水的容器</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>**说明：**你不能倾斜容器，且 <em>n</em> 的值至少为 2。</p>
<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="" /></p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>定义两个指针i，j。i指向容器左壁索引，j指向容器右壁索引，判断谁高度小，然后i小的话i++；j小j–。当i&lt;j时不断获得面积并返回最大值。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=height.length-<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            res=height[i]&lt;height[j]? Math.max(res,height[i++]*(j-i)):Math.max(res,height[j--]*(j-i));</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> res; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>整数反转</title>
    <url>/2020/06/01/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h1 id="整数反转"><a class="markdownIt-Anchor" href="#整数反转"></a> 整数反转</h1>
<h2 id="解法一转换为字符串进行反转"><a class="markdownIt-Anchor" href="#解法一转换为字符串进行反转"></a> 解法一：转换为字符串进行反转</h2>
<p><strong>思路</strong>：将整数转换为字符串进行反转，数字溢出使用异常捕获。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        String str=<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=<span class="string">&quot;-&quot;</span>+<span class="keyword">new</span> StringBuffer(String.valueOf(x).substring(<span class="number">1</span>)).reverse().toString();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str=<span class="keyword">new</span> StringBuffer(String.valueOf(x)).reverse().toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str=<span class="string">&quot; &quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            res=Integer.valueOf(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>知识点补充</strong>：</p>
<ul>
<li>
<p>**Integer.parseInt(s)**​的作用就是把字符串s解析成有符号的int基本类型。</p>
</li>
<li>
<p>Integer.parseInt(s)多次解析同一个字符串得到的int基本类型数据是相等的，可以直接通过“==”进行判断是否相等。</p>
</li>
<li>
<p>**Integer.valueOf(s)**把字符串s解析成Integer对象类型，返回的integer 可以调用对象中的方法。</p>
</li>
<li>
<p>Integer.valueOf(s)多次解析相同的一个字符串时，得到的是Integer类型的对象，得到的对象有时是同一个对象，有时是不同的对象，要根据把s字符串解析的整数值的大小进行决定：如果s字符串对应的整数值在 -128—127之间，则解析出的Integer类型的对象是同一个对象；如果s字符串对应的整数值不在-128~127之间，则解析出的Integer类型的对象不是同一个对象。不管对象是否相等，对象中的value值是相等的。</p>
</li>
</ul>
<h2 id="解法二求余倒转法"><a class="markdownIt-Anchor" href="#解法二求余倒转法"></a> 解法二：求余倒转法</h2>
<p><strong>思路</strong>：如1234，先1234%10得4，然后1234/10=123；继续123%10=3，然后123/10=12；继续12%10=2，然后12/10=1。然后就可以得到4321。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//每次取末尾数字</span></span><br><span class="line">            <span class="keyword">int</span> temp=x%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断是否大于最大32位整数</span></span><br><span class="line">            <span class="keyword">if</span>(res&gt;<span class="number">214748364</span>||res==<span class="number">214748364</span>&amp;&amp;temp&gt;<span class="number">7</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否 小于 最小32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res&lt;-<span class="number">214748364</span> || (res==-<span class="number">214748364</span> &amp;&amp; temp&lt;-<span class="number">8</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res=res*<span class="number">10</span>+temp;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共前缀</title>
    <url>/2020/06/01/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h1 id="最长公共前缀"><a class="markdownIt-Anchor" href="#最长公共前缀"></a> 最长公共前缀</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>
<p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出: &quot;fl&quot;</span><br></pre></td></tr></table></figure>
<h2 id="问题解决"><a class="markdownIt-Anchor" href="#问题解决"></a> 问题解决</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;<span class="comment">//判断字符数组是否为空</span></span><br><span class="line">        String prefix=strs[<span class="number">0</span>];<span class="comment">//假设第一个字符串就是最长前缀</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(strs[i].indexOf(prefix)!=<span class="number">0</span>)&#123;<span class="comment">//如果不存在，即起始索引不等于0</span></span><br><span class="line">                prefix=prefix.substring(<span class="number">0</span>,prefix.length()-<span class="number">1</span>);<span class="comment">//不断去除prefix的尾部字符继续比较</span></span><br><span class="line">                <span class="keyword">if</span>(prefix.isEmpty()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;<span class="comment">//无公共前缀，返回&quot;&quot;。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//str.indexOf(String s)函数。判断str字符串是否有匹配的子串s，返回子串s的起始索引。</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2020/06/01/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="最长回文子串"><a class="markdownIt-Anchor" href="#最长回文子串"></a> 最长回文子串</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<p>示例一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br></pre></td></tr></table></figure>
<h2 id="暴力解法"><a class="markdownIt-Anchor" href="#暴力解法"></a> 暴力解法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongPalindrome</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;<span class="comment">//判断是否回文</span></span><br><span class="line">        <span class="keyword">char</span>[] str=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=str[str.length-i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLongPalindrome</span><span class="params">(String s)</span></span>&#123;<span class="comment">//穷举字符串s所有的子字符串，逐一判断并记录最大值。</span></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        String ans=<span class="string">&quot; &quot;</span>;<span class="comment">//注意此处用ans记录最后结果。</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()&lt;<span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">                String res=s.substring(i,j);<span class="comment">//动态判断用的res</span></span><br><span class="line">                <span class="keyword">if</span>(res.length()&gt;max&amp;&amp;isPalindrome(res))&#123;</span><br><span class="line">                    ans=s.substring(i,j);</span><br><span class="line">                    max=Math.max(max,ans.length());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s=<span class="string">&quot;abdbafr&quot;</span>;</span><br><span class="line">        LongPalindrome longPalindrome=<span class="keyword">new</span> LongPalindrome();</span><br><span class="line">        System.out.println(longPalindrome.getLongPalindrome(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划解法"><a class="markdownIt-Anchor" href="#动态规划解法"></a> 动态规划解法</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strLen = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxStart = <span class="number">0</span>;  <span class="comment">//最长回文串的起点</span></span><br><span class="line">        <span class="keyword">int</span> maxEnd = <span class="number">0</span>;    <span class="comment">//最长回文串的终点</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;  <span class="comment">//最长回文串的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[strLen][strLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; strLen; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; r; l++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(l) == s.charAt(r) &amp;&amp; (r - l &lt;= <span class="number">2</span> || dp[l + <span class="number">1</span>][r - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[l][r] = <span class="keyword">true</span>;<span class="comment">//r-l&lt;=2表示字符串只有2个或3个字符。</span></span><br><span class="line">                    <span class="keyword">if</span> (r - l + <span class="number">1</span> &gt; maxLen) &#123;<span class="comment">//更新最大长度</span></span><br><span class="line">                        maxLen = r - l + <span class="number">1</span>;</span><br><span class="line">                        maxStart = l;</span><br><span class="line">                        maxEnd = r;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxStart, maxEnd + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode精选题练习</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的公共祖先</title>
    <url>/2020/05/29/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="二叉树的公共祖先"><a class="markdownIt-Anchor" href="#二叉树的公共祖先"></a> 二叉树的公共祖先</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个<strong>二叉树</strong>, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p>
<p><strong>说明</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉树中。</li>
</ul>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>递归解析</strong>：</p>
<p><strong>终止条件</strong>：<br />
当越过叶节点，则直接返回 null ；<br />
当 root 等于 p, q，则直接返回 root ；</p>
<p><strong>递推工作</strong>：<br />
开启递归左子节点，返回值记为 left ；<br />
开启递归右子节点，返回值记为 right ；</p>
<p><strong>返回值</strong>： 根据 left和 right ，可展开为四种情况；<br />
当 left和 right 同时为空 ：说明 root 的左 / 右子树中都不包含 p,q，返回 null；<br />
当 left和 right 同时不为空 ：说明 p, q分列在 root的 异侧 （分别在 左 / 右子树），因此 root为最近公共祖先，返回 root；<br />
当 left 为空 ，right 不为空 ：p,q都不在 root的左子树中，直接返回 right。具体可分为两种情况：<br />
p,q其中一个在 root的 右子树 中，此时 right 指向 p（假设为 p）；<br />
p,q两节点都在 root 的 右子树 中，此时的 right指向 最近公共祖先节点 ；<br />
当 left不为空 ， right为空 ：与情况 3. 同理；</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getCommenParent</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left=getCommenParent(root.left,p,q);<span class="comment">//在左子结点找到p</span></span><br><span class="line">        TreeNode right=getCommenParent(root.right,p,q);<span class="comment">//在右子结点找到p</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root;<span class="comment">//left!=null&amp;&amp;right!=null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://pic.leetcode-cn.com/0724b87055c4bc4d744ab64775e6eefa348777c0ea0b07a00ff917773f4b494e-Picture18.png" alt="" /></p>
<p>代码的执行及返回过程见上图，顺序3——5——6——2——7（返回left=7）——4（返回right=4）——（left！=null&amp;&amp;right！=null）返回root=2——（left=null）返回right=2——1——0——8——（返回null）——（right=null）返回left=2。即最终结点。</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的最近公共祖先</title>
    <url>/2020/05/29/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="二叉搜索树的最近公共祖先"><a class="markdownIt-Anchor" href="#二叉搜索树的最近公共祖先"></a> 二叉搜索树的最近公共祖先</h1>
<h1 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h1>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p>
<p>示例：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong></p>
<ul>
<li>
<p>所有节点的值都是唯一的。</p>
</li>
<li>
<p>p、q 为不同节点且均存在于给定的二叉搜索树中。</p>
</li>
</ul>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>由于为二叉搜索树，左结点值小于根结点，右结点值大于根结点。如果p、q结点值小于根，则向左子树遍历；如果p、q结点值大于根，则向右子树遍历；否则，返回当前根结点。具体可以上述荔枝举例看到。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getCommenParent</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val&lt;root.val&amp;&amp;q.val&lt;root.val)&#123;</span><br><span class="line">            root=root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(p.val&gt;root.val&amp;&amp;q.val&gt;root.val)&#123;</span><br><span class="line">            root=root.right;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>构建乘积数组</title>
    <url>/2020/05/29/%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="构建乘积数组"><a class="markdownIt-Anchor" href="#构建乘积数组"></a> 构建乘积数组</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个数组A[ ]，请构建一个数组B[ ]，其中B的元素B[i]=A[0]×A[1]×……×A[i-1]×A[i+1]×……×A[n-1]。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>分析题意，可知B[i]等于A[i]左边的元素乘积再乘以A[i]右边元素乘积。</p>
<p><img src="https://pic.leetcode-cn.com/6056c7a5009cb7a4674aab28505e598c502a7f7c60c45b9f19a8a64f31304745-Picture1.png" alt="" /></p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArr(<span class="keyword">int</span>[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span>(a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;<span class="comment">//计算左边的乘积</span></span><br><span class="line">            b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//计算右边的乘积</span></span><br><span class="line">            tmp *= a[i + <span class="number">1</span>];</span><br><span class="line">            b[i] *= tmp; <span class="comment">//b[i]等于左右相乘。</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>圆圈中最后剩下的数字</title>
    <url>/2020/05/28/%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="圆圈中最后剩下的数字"><a class="markdownIt-Anchor" href="#圆圈中最后剩下的数字"></a> 圆圈中最后剩下的数字</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>0,1,……,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。</p>
<p>例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。</p>
<h2 id="问题解法"><a class="markdownIt-Anchor" href="#问题解法"></a> 问题解法</h2>
<p><strong>基于ArrayList实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            idx=(idx+m-<span class="number">1</span>)%n;<span class="comment">//此式可获得每轮第m个元素</span></span><br><span class="line">            list.remove(idx);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>基于约瑟夫环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最后一轮剩下2个人，所以从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>队列的最大值</title>
    <url>/2020/05/27/%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="队列的最大值"><a class="markdownIt-Anchor" href="#队列的最大值"></a> 队列的最大值</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>使用一个队列和一个双端队列实现，普通队列用来插入和删除， 双端队列用来存储maxvalue。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//队列：插入和删除</span></span><br><span class="line">    deque = <span class="keyword">new</span> LinkedList&lt;&gt;();  <span class="comment">//双端队列：获取最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> deque.size()&gt;<span class="number">0</span>?deque.peek():-<span class="number">1</span>;  <span class="comment">//双端队列的队首为que的最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    queue.offer(value);  <span class="comment">//value入队</span></span><br><span class="line">    <span class="keyword">while</span>(deque.size()&gt;<span class="number">0</span> &amp;&amp; deque.peekLast()&lt;value)&#123;</span><br><span class="line">        deque.pollLast();  <span class="comment">//将deq队尾小于value的元素删掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    deque.offerLast(value);  <span class="comment">//将value放在deq队尾</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = queue.size()&gt;<span class="number">0</span>?queue.poll():-<span class="number">1</span>;  <span class="comment">//获得队首元素</span></span><br><span class="line">    <span class="keyword">if</span>(deque.size()&gt;<span class="number">0</span> &amp;&amp; tmp==deque.peek())&#123;</span><br><span class="line">        deque.poll();  <span class="comment">//如果出队的元素是当前最大值，将deq的队首出队</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="queue和deque知识点补充"><a class="markdownIt-Anchor" href="#queue和deque知识点补充"></a> Queue和Deque知识点补充</h1>
<h2 id="queue"><a class="markdownIt-Anchor" href="#queue"></a> Queue</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在队尾添加一个元素：offer()</span><br><span class="line"></span><br><span class="line">2. 在队首移除一个元素：poll()</span><br><span class="line"></span><br><span class="line">3. 获取队列头部元素：peek()</span><br></pre></td></tr></table></figure>
<h2 id="deque"><a class="markdownIt-Anchor" href="#deque"></a> Deque</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. offerFirst()/pollFirst() 检索并(插入)删除此双端队列的第一个元素，null如果此双端队列为空，则返回。</span><br><span class="line"></span><br><span class="line">2. offerLast()/pollLast() 检索并(插入)删除此双端队列的最后一个元素，null如果此双端队列为空，则返回。</span><br><span class="line"></span><br><span class="line">3.peekFirst()/peekLast() 检索但不删除此双端队列的第一个(最后一个)元素，null如果此双端队列为空，则返回。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>左旋转字符串</title>
    <url>/2020/05/27/%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="左旋转字符串"><a class="markdownIt-Anchor" href="#左旋转字符串"></a> 左旋转字符串</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&quot;abcdefg&quot;和数字2，该函数将返回左旋转两位得到的结果&quot;cdefgab&quot;。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>字符串切片</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.substring(n, s.length()) + s.substring(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>StringBuilder拼接</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; n + s.length(); i++)</span><br><span class="line">            res.append(s.charAt(i % s.length()));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>String</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseLeftWords</span><span class="params">(String s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &lt; n + s.length(); i++)</span><br><span class="line">            res += s.charAt(i % s.length());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的连续正数序列</title>
    <url>/2020/05/27/%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="和为s的连续正数序列"><a class="markdownIt-Anchor" href="#和为s的连续正数序列"></a> 和为s的连续正数序列</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：target = 9</span><br><span class="line">输出：[[2,3,4],[4,5]]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>使用滑动窗口，i，j初始指向第一个元素，累计和，若小于target，j++；若大于target，i–；若相等，则存入一个array。具体见下。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] getContinueSequence(<span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i&lt;=target/<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//假设窗口左边界i=target/2, i+1=target/2 +1,那么i + (i+1) = target+1,即最小的窗口的元素之和就已经比target大了，所以当i&gt;=target/2时不可能有一个窗口长度&gt;=2的答案。</span></span><br><span class="line">         <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">             sum+=j;</span><br><span class="line">             j++;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">             sum-=i;</span><br><span class="line">             i++;</span><br><span class="line">         &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[j-i];</span><br><span class="line">             <span class="keyword">for</span>(<span class="keyword">int</span> k=i;k&lt;j;k++)&#123;</span><br><span class="line">                 arr[k-i]=k; </span><br><span class="line">             &#125;     </span><br><span class="line">         &#125;</span><br><span class="line">            list.add(arr);</span><br><span class="line">            sum-=i;<span class="comment">//与上述i&lt;=target/2相应，sum需减左边界值，继续下一轮判断。</span></span><br><span class="line">            i++;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][]);<span class="comment">//返回一个二维数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转单词顺序</title>
    <url>/2020/05/26/%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="翻转单词顺序"><a class="markdownIt-Anchor" href="#翻转单词顺序"></a> 翻转单词顺序</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&quot;I am a student. “，则输出&quot;student. a am I”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入: &quot;  hello world!  &quot;</span><br><span class="line">输出: &quot;world! hello&quot;</span><br><span class="line">解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>先对字符串去除首位空格，定义i，j指向字符串尾，i–，当i为空格返回第一个字符串；然后继续i–，当i不是空格，j指向i。重复，用stringbuilder存储。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseWords</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        s=s.trim();</span><br><span class="line">        <span class="keyword">int</span> i=s.length()-<span class="number">1</span>,j=i;</span><br><span class="line">        StringBuilder res=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>)&#123;<span class="comment">//必须再加这一层循环判断，不然第二个while判断到空就结束了。</span></span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;s.charAt(i)!=<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            res.append(s.substring(i+<span class="number">1</span>,j+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>);<span class="comment">//substring（i，j）函数：即得到从i开始，到j-1结尾的字符串。注意此处substring两个s都是小写。</span></span><br><span class="line">            <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            j=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();<span class="comment">//将StringBuilder转化为String。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>读木心诗二三句</title>
    <url>/2020/05/26/%E8%AF%BB%E6%9C%A8%E5%BF%83%E8%AF%97%E4%BA%8C%E4%B8%89%E5%8F%A5/</url>
    <content><![CDATA[<h1 id="读木心诗二三句"><a class="markdownIt-Anchor" href="#读木心诗二三句"></a> 读木心诗二三句</h1>
<p>木心的诗，感觉语言上特别有古意与情味，其诗描写故景往事者读之令人口齿含香，即刻诵之。今日夏初梅雨，摘之二三，与时消夏。</p>
<center>
<h2 id="少年朝食"><a class="markdownIt-Anchor" href="#少年朝食"></a> 少年朝食</h2>
<center>
    清早阳光<br>
    照明高墙一角<br>
    喜鹊喀喀叫<br>
    天井花坛葱茏<br>
    丫鬟悄声报用膳<br>
    紫檀圆桌<br>
    四碟端陈<br>
    姑苏酱鸭<br>
    平湖糟蛋<br>
    撕蒸笋<br>
    豆干末子拌马兰头<br>
    莹白的暖暖香粳米粥<br>
    没有比粥更温柔的了<br>
    东坡、剑南皆嗜粥<br>
    念予毕生流离红尘<br>
    就找不到一个似粥温柔之人<br>
    吁，予仍频忆江南古镇<br>
    梁昭明太子读书于我家后园<br>
    窗前的银杏树是六朝之前的<br>
    昔南塘春半、风和马嘶<br>
    日长无事蝴蝶飞<br>
</center>
<h2 id="大卫"><a class="markdownIt-Anchor" href="#大卫"></a> 大卫</h2>
<center>
莫倚偎我<br>
我习于冷<br>
志于成冰<br>
莫倚偎我<br>
别走近我<br>
我正升焰<br>
万木俱焚<br>
别走近我<br>
</center>
<h2 id="清嘉录"><a class="markdownIt-Anchor" href="#清嘉录"></a> 清嘉录</h2>
<center>
**其一**
<br>
平明舟出山庄<br>
万枝垂柳，烟雨迷茫<br>
回眺岸上土屋亦如化境<br>
舟子挽纤行急<br>
误窜层网中，遂致勃谿<br>
登岸相劝，几为乡人窘<br>
偿以百钱，始悻悻散<br>
    <br>
行百余里，滩险日暮<br>
约去港口数里以泊<br>
江潮大来，荻芦如雪<br>
肃肃与风相抟<br>
是夕正望，月似紫铜盘<br>
水势益长，澎湃声起<br>
俄闻金山蒲牢动，漏下矣<br>
    <br>
**其二**
<br>
梅雨时备缸瓮收旧雨水<br>
供烹茶，曰梅水<br>
梅天多雨，雨水极佳<br>
贮之味经年不变<br>
人于初交黄梅时收雨<br>
以其甘滑胜山泉<br>
</center>
<p>​</p>
<h2 id="从前慢"><a class="markdownIt-Anchor" href="#从前慢"></a> 从前慢</h2>
<center>
记得早先少年时<br>
大家诚诚恳恳<br>
说一句是一句<br>
清早上火车站<br>
长街黑暗无行人<br>
卖豆浆的小店冒着热气<br>
    <br>
从前的日色变得慢<br>
车、马、邮件都慢<br>
一生只够爱一个人<br>
    <br>
从前的锁也好看<br>
钥匙精美有样子<br>
你锁了，人家就懂了<br>
</center>
<h2 id="魏玛早春"><a class="markdownIt-Anchor" href="#魏玛早春"></a> 魏玛早春</h2>
<center>
有一株树<br>
曾见一株这样的树<br>
冬季晴和了几天<br>
不觉彤云叆叇<br>
万千乌鸦出林<br>
聒鸣飞旋<br>
乡民谓之噪雪<br>
称彤云为酿雪<br>
风凛冽<br>
行人匆匆回家<br>
曾见一株树在这样的时日<br>
枝头齐茁蓓蕾<br>
淡绛的星星点点密布楂条<br>
长势迅速梢端尤累累若不胜载<br>
际此霙雪纷纷下<br>
无数花苞仰雪绽放<br>
雪片愈大愈紧<br>
群花朵朵舒展<br>
树高十米<br>
干围一点五米<br>
叶如樟似杨<br>
顶冠直径十余米<br>
花状类乎扶桑之樱<br>
色与雪同<br>
吐香清馥<br>
冬季中下几遭雪<br>
发几度花<br>
霰霙之夕<br>
寂然不应<br>
初雪之顷无气息<br>
四野积雪丰厚<br>
便闲幽馨流播<br>
昼夜氤氲<br>
雪销<br>
花凋谢<br>
植物志上没有这株树的学名<br>
中国洞庭湖之南湘省 洞口县 水口山<br>
树在那里已两百多年<br>
</center>
<h2 id="爪哇国"><a class="markdownIt-Anchor" href="#爪哇国"></a> 爪哇国</h2>
<center>
从前的人真有趣<br>
他们要形容荒唐<br>
便说“一错错到了爪哇国”<br>
他们以为爪哇是最远的了<br>
你想明朝人有多可爱<br>
</center>
<h2 id="如偈"><a class="markdownIt-Anchor" href="#如偈"></a> 如偈</h2>
<center>
晚晴风光好<br>
大梦觉犹眠<br>
每忆儿时景<br>
莲叶何田田<br>
</center>
<h2 id="谑庵片简"><a class="markdownIt-Anchor" href="#谑庵片简"></a> 谑庵片简</h2>
<center>
隆恩寺无他奇<br>
独大会明堂百余丈<br>
可玩月<br>
径下有云深庵<br>
五月，啖其樱桃<br>
八月，落其苹果<br>
樱桃人啖后百鸟俱来<br>
绿羽翠翎者，白身朱咮者<br>
嘈嘈各呈妙音<br>
</center>
<h2 id="京师五月"><a class="markdownIt-Anchor" href="#京师五月"></a> 京师五月</h2>
<center>
石榴花正开<br>
照眼鲜明<br>
居人每与夹竹桃列中庭<br>
榴竹之间，配以鱼缸<br>
朱鳞数尾游漾其中<br>
几于家家如此<br>
</center>
<h2 id="我"><a class="markdownIt-Anchor" href="#我"></a> 我</h2>
<center>
我是一个在黑暗中大雪纷飞的人哪<br>
</center>
<h2 id="浣花溪归"><a class="markdownIt-Anchor" href="#浣花溪归"></a> 浣花溪归</h2>
<center>
出成都门<br>
左万里桥<br>
西折，溪流纤秀长曲<br>
如连环，如玦色<br>
如鉴，如琅玕<br>
窈然深碧<br>
潆回城下<br>
皆浣花溪之委也<br>
</center>
<h2 id="夏日山居"><a class="markdownIt-Anchor" href="#夏日山居"></a> 夏日山居</h2>
<center>
遍地悬铃木<br>
树叶杂花横生<br>
紫檀，木兰，石榴<br>
扇形的棕榈<br>
油润润的乌柏<br>
<br>
朝暾初升<br>
小丘上阳光已很强烈<br>
芬芳的雾闪着兰晕<br>
林薮蓊郁，群峦后<br>
终年积雪的巍巍高峰<br>
</center>]]></content>
      <categories>
        <category>芳林拾记</category>
      </categories>
      <tags>
        <tag>古意</tag>
        <tag>故景</tag>
      </tags>
  </entry>
  <entry>
    <title>0~n-1中缺失的数字</title>
    <url>/2020/05/25/0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="0~n-1中缺失的数字"><a class="markdownIt-Anchor" href="#0~n-1中缺失的数字"></a> 0~n-1中缺失的数字</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,3]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>对于查找类问题，可使用二分法解决。</p>
<p>由题意，该序列为0~n-1的递增序列中少掉了一个数字，故有，当nums[i]=i时可以知道前i个元素是没有缺失的，</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getElementNotIn</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> m=(i+j)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[m]==m)&#123;</span><br><span class="line">            i=m+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                j=m-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数</title>
    <url>/2020/05/24/%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h1 id="丑数"><a class="markdownIt-Anchor" href="#丑数"></a> 丑数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>我们把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 10</span><br><span class="line">输出: 12</span><br><span class="line">解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol>
<li>1是丑数。</li>
<li>n不超过1690。</li>
</ol>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<blockquote>
<p>丑数的递推性质： 丑数只包含因子 2, 3, 52,3,5 ，因此有 “丑数 == 某较小丑数 × 某因子” （例如：10=5×2）。</p>
</blockquote>
<p>动态规划解析：</p>
<p><strong>状态定义</strong>：设动态规划列表dp，dp[i]代表第i+1个丑数。</p>
<p><strong>转移方程</strong>：</p>
<p>1.当索引a，b，c满足以下条件时，dp[i]为三种情况的最小值。</p>
<p>2.每轮计算dp[i]后，需要更新索引a，b，c的值，使其始终满足方程条件。即分别判断dp[i]和dp[a]×2,dp[b]×3,dp[c]×5的大小关系，若相等则对应索引a，b，c加1。</p>
<p>dp[i]=min(dp[a]×2,dp[b]×3,dp[c]×5)</p>
<p><strong>初始状态</strong>：</p>
<p>dp[0]=1,由题意第一个丑数为1。</p>
<p><strong>返回值</strong>：</p>
<p>dp[n-1]。即返回第n个丑数。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>, n3 = dp[b] * <span class="number">3</span>, n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(n2, n3), n5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2) a++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3) b++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n5) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次只出现一次的字符</title>
    <url>/2020/05/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="第一次只出现一次的字符"><a class="markdownIt-Anchor" href="#第一次只出现一次的字符"></a> 第一次只出现一次的字符</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;abaccdeff&quot;</span><br><span class="line">返回 &quot;b&quot;</span><br><span class="line"></span><br><span class="line">s = &quot;&quot; </span><br><span class="line">返回 &quot; &quot;</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>将字符串转为字符数组，逐个遍历存入HashMap，其他key为字符，value为：若map中没有该字符，置为true；有该字符，置为false，通过map.containsKey( )得到。</p>
<p>遍历map，得到第一个值为true的元素便是。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstUniqueChar</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstunichar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Boolean&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] res=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:res)</span><br><span class="line">            <span class="comment">//巧妙判断：出现多次必为false，出现一次的为true。</span></span><br><span class="line">            map.put(c,!map.containsKey(c));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:res) <span class="comment">//巧用这种for循环，获取循环元素。而且这种for循环可不加大括号。</span></span><br><span class="line">            <span class="keyword">if</span>(map.get(c))</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String s=<span class="string">&quot;abass&quot;</span>;</span><br><span class="line">        FirstUniqueChar firstUniqueChar=<span class="keyword">new</span> FirstUniqueChar();</span><br><span class="line">        System.out.println(firstUniqueChar.firstunichar(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的第k大元素</title>
    <url>/2020/05/22/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="二叉搜索树的第k大元素"><a class="markdownIt-Anchor" href="#二叉搜索树的第k大元素"></a> 二叉搜索树的第k大元素</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一棵二叉搜索树，请找出其中第k大的节点。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>由二叉搜索树的特点，知其中序遍历序列有序，为递增序列。这里可以仿中序弄一个倒中序（右根左）然后得到一个递减序列，第k个元素即为第k大节点。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KElementBST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKthElement</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,list);</span><br><span class="line">        <span class="keyword">return</span> list.get(k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二叉搜索树中序有序，可倒中序遍历，正好得到降序序列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            helper(root.right,list);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            helper(root.left,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        KElementBST kElementBST=<span class="keyword">new</span> KElementBST();</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">        root.left=<span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.right=<span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        System.out.println(kElementBST.getKthElement(root, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉树</title>
    <url>/2020/05/21/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="平衡二叉树"><a class="markdownIt-Anchor" href="#平衡二叉树"></a> 平衡二叉树</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>深度遍历每个结点，判断其左右子树高度之差是否&lt;=1。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(deepth(root.left)-deepth(root.right))&lt;=<span class="number">1</span>&amp;&amp;isBalanced(root.left)&amp;&amp;isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(deepth(root.left),deepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>岁月的恍惚与生命的迷失</title>
    <url>/2020/05/20/%E5%B2%81%E6%9C%88%E7%9A%84%E6%81%8D%E6%83%9A%E4%B8%8E%E7%94%9F%E5%91%BD%E7%9A%84%E8%BF%B7%E5%A4%B1/</url>
    <content><![CDATA[<p>人生的二十几岁，似乎是每个人的成长蜕变的时刻，我的生命，以一贯的孤独与失意肆意行走着。</p>
<p>小时候，在乡村，教育资源的匮乏使得我们并没有学习到过多的知识，更多的日子里，是在田间地头玩着、和小伙伴打打闹闹。坐在老屋的门口，穿着奶奶补了又补的衣裳，吃着地里种的甜瓜。一天好像就是三餐和到处溜达寻思着把弄一些自己做的小玩具。</p>
<p>小学一到四年级的时候，在村里，只有两个上了年纪的老师给我们教语文和数学，偶尔校长教我们画画。读五六年级的时候，从村里去了乡里的小学，开始认识更多的老师，是女孩子，而且比较年轻，最记得我们的语文老师，好几次找到我说我语文学的不错，作文写的很好，那个时候，其实能读到的东西并不多，我们家除了学校给发的语文课本和一点课外阅读就是两本字典，一本是新编汉语字典，是我外公给我的，我还清楚的记得他送我这本字典的那天，他叫我去到他住的屋子，打开一扇木制的柜橱，然后找到一个木盒子，把这本字典取出来给我，让我好好去认字，于是我便毕恭毕敬的接受了，还有一本是我姐买来的成语字典，总记得夏天无事的时候，就爱翻开这两本字典。</p>
<p>快小学毕业的时候，有一次我姐的朋友约她去城里的上顿渡买学习辅导书，回来的时候给我买了两本，厚厚的，小升初的语文和数学辅导书，才开始有压力起来，感觉到学习是一件很困难的事情，特别是对着实在不知道怎么做的数学题。为了写完那两本花了好多钱买的书，我开始用铅笔做，做的很痛苦，因为大部分写不来，后面还是去读了初中，市里有两所很好的中学，当时的印象是特别会读书的人才能去到那里读书，不然就是有关系家里很有钱买进去。后面我是去了邻镇的一个普通的中学，我妈找了一个认识的人得到了一个听说教的还不错的老师的联系方式，然后在开学那天买了几盒很好的香烟和我们家养的几只鸭子去了那个老师的家，然后交了学费报了名。那是我第一次看见一个感觉很大的学校还有好多的学生。</p>
<p>于是，我的整个中学生涯就在那度过了，初一是很快乐的，因为有同村的也在那上学，也认识了一些新同学，我们经常课后一起嬉戏玩闹，还有一个特别年轻可爱的英语实习老师，可能是刚毕业来实习，所以特别认真与和蔼，和我们学生打成一片，我也因此学的很认真，初一的课程大抵不是很难的，每次月考我总能在年级上排到前三十名。后面学期末学校突然组建了一个快班，读两年初中然后直接升本校高中，并且不用交学费了。因为只有一年，后面又有了物理与化学，以至于我们中考前课程并没有上完，后面暑假补了很久的课，大部分人留在本校上高中了。</p>
<p>上了高中之后就感觉数学、物理、化学都变得很难很难，自己的脑子似乎不够用了，然后每天课程满满的还有作业，除了吃饭和睡觉每天都待在教室里，午休也是得在教室，晚上也有晚自习，周末也只有一个晚上和一个下午是没有课的。活在匆忙学习中的我再也没有玩耍的机会，那些初一认识的同学也没见过面了，高中的生活给我的感觉就是压抑而自卑，我成了那个基本上不说话也不离课桌的人。那个时候，学校门口总会有卖书的来，比较便宜，于是我开始读到更多的书，也喜欢上那些美好的文字。平日里，爱逛这四季的校园，和唯一一个关系比较好的同班同学说起这是什么花这是什么树，哪里长了什么果子。我们常常在体育课的时候来逛校园并说着许多话。</p>
<p>那年高考，我也没有考好，离二本线还差了四十多分，然后家里让我复读了，班主任老师还是给我填了志愿，后面得到景德镇陶瓷学院的录取通知。但是因为决定复读就没有去了。复读是去了临川一中，在老校区的补习班，能感觉到这里的老师还是比较厉害的，大部分讲的能听懂，生物老师是一个很伶俐的女老师，课讲的挺好而且经常给我们说一些别的东西。化学老师也还可以，物理老师就有点凶巴巴的，上课的时候要是没人回应他就不讲了，然后我们实在答不了他也只能讲着，英语老师是一个比较憨厚而且有点胖的女老师，感觉也挺好的，数学老师是我们班主任，不太管我们。呃，我竟然对语文老师没有印象了，甚至想不起来他是什么样子，我喜欢的语文。后来我和语文课代表在同一所大学。</p>
<p>大学后，在江西理工大学，在高考的独木桥上去到了一个本科学校，然而学了一个软件工程加机械设计制造及其自动化背景的专业，并没有学到很多东西，那个时候的我也不知道要怎么学习，未来是怎样也一无所知，但是第一次来到大学，与高中完全不一样的学习环境，逐渐也随遇而安着。大学现在想来确实过的太舒坦了，除了日常上课，写一点作业，我并没有长远的想法。在大一下学期，机缘巧合加入了一个校外的演讲培训组织再远演说，后来是叫随心说，然后那段时间认识了许多同龄的伙伴，并经常一块去其他的学校宣传或者听课。在那里让我第一次感觉到和一群人做一些事情的快乐。可能由于自己性格的原因，我并没有机会改变自己上台胆怯的现状，但还是得到了一些锻炼，也庆幸认识了一些很不错的朋友。后来，帮着平台招来新一届学生，我们便逐渐很少有机会去了，大二下学期后就算是退出了。也是从那之后，忽然喜欢上一个女生，是同校一个同学的朋友，因为某些共同的爱好然后在一块玩了几次。大三上学期的时候，我们单独又见过几次，是她约我一起去看电影，那个时候的我，第一次感觉到和一个很不错的女孩子一起玩的快乐，就不自觉喜欢上她了。大三上结束的那个新年，意识到自己专业学习的不足，决定准备考研，也同时是圆自己的一个名校梦，在一个亲戚朋友的推荐下报考了大连理工大学。准备考研的那段时间里，除了每日的科目复习，对那个女孩子的追求也没有停止过，但是我很失败了，并没有成功。期间也见了好几次，在一块的时候的感觉真的特别美好，满足且快乐。但是不见的时候不快乐居多，我那时仿佛成了一个很奇葩的扑火的飞蛾。</p>
<p>后面如愿考上了大连理工大学，但是并没有感到快乐，体检完我的身体似乎出了点问题，好像是一年的抑郁所致，我记不清那一年里我独自一个人经常因为不开心到处游荡，去了很多别的学校，去了江边，去到一片无人的山丘上坐着发呆，经常夜里没有发出声音的泪流满面。从医院回到家后，开始写毕业论文，那段时间认识了长亭姐姐，长亭姐姐名钱辰，江苏南通人。她让我感觉到一个女孩子的美好与慈悲，性格简直不能太好，若你读她写的文字，你会觉得她就像是一个不染纤尘的仙女。我说我喜欢摄影，其实我最开始并没有对摄影有追求，是因为喜欢的那个女生她挺会拍照的，发在朋友圈的图片感觉特别美好，而且与她有过一起去看花拍花的经历。后面我也不自觉想把照片拍的很好看，我的相机便是长亭姐姐转给我的。那段时间，在家的我经常出去拍一些景物，基本上把抚州所有地方都走了个遍并不断重复着。后面因为论文答辩再回了一次学校，见了一下那个女生，并把相机送给她拍，那天晚上，我们去了赣江边，下着小雨，我给她打伞，其实想起来和她约经常碰上下雨天，幸或不幸否，下雨确实挺不方便的，一身湿。但也因为下雨都是我给她打伞我们的距离似乎很近，近的以为我这辈子的伴侣就是她了。陷入爱情中的男子总是很奇妙的，我亦不能幸免。答辩那会也是最后见到陪伴了四年的五个室友，虽然平常只和一个同乡的室友关系比较好。答辩完的那个晚上，我们班聚餐，那些学习好的以及班干和老师围坐一桌，我则快乐的和我的室友们在一块。</p>
<p>…</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
      <tags>
        <tag>迷失</tag>
        <tag>岁月</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表的第一个公共节点</title>
    <url>/2020/05/20/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="两个链表的第一个公共结点"><a class="markdownIt-Anchor" href="#两个链表的第一个公共结点"></a> 两个链表的第一个公共结点</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入两个链表，找出它们的第一个公共节点。</p>
<p>如下面的两个链表**：**</p>
<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/160_statement.png" alt="" /></p>
<p>在结点c1开始相交。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<h3 id="分析一"><a class="markdownIt-Anchor" href="#分析一"></a> 分析一：</h3>
<p>先得到A，B链的长度，若A长，则A先走A-B个长度；若B长，则B先走B-A个长度。然后一起走，直到两者相等，返回当前结点。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sulotion</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersection</span><span class="params">(ListNode headA,ListNode headB)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> lengthA=getLength(headA),lengthB=getLength(headB);</span><br><span class="line">        ListNode first=headA,second=headB;</span><br><span class="line">        <span class="keyword">if</span>(lengthA&gt;lengthB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lengthA-lengthB;i++)&#123;</span><br><span class="line">                first=first.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lengthB-lengthA;i++)&#123;</span><br><span class="line">                second=second.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(first!=second)&#123;</span><br><span class="line">            first=first.next;</span><br><span class="line">            second=second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(ListNode temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(ListNode node=temp;node!=<span class="keyword">null</span>;node=node.next,length++);<span class="comment">//学习此类循环</span></span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析二"><a class="markdownIt-Anchor" href="#分析二"></a> 分析二：</h3>
<p>我们使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p>
<p>这样，两个结点就实现了同步，最后若相等，即是公共节点。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersection</span><span class="params">(ListNode headA,ListNode headB)</span></span>&#123;</span><br><span class="line">        ListNode first=headA,second=headB;</span><br><span class="line">        <span class="keyword">while</span>(first!=second)&#123;</span><br><span class="line">            first=first!=<span class="keyword">null</span>? first.next:headB;</span><br><span class="line">            second=second!=<span class="keyword">null</span>? second.next:headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中数字出现的次数</title>
    <url>/2020/05/19/%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="数组中数字出现的次数"><a class="markdownIt-Anchor" href="#数组中数字出现的次数"></a> 数组中数字出现的次数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>一个整型数组 nums里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,1,4,6]</span><br><span class="line">输出：[1,6] 或 [6,1]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>你知道异或吗？</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumbers(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">       <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">       <span class="comment">//将数组所有元素进行异或，最后的结果一定是那两个单一数字的异或结果。看上图示例</span></span><br><span class="line">       <span class="comment">//用示例[4,4,6,1]最后的抑或结果就是 6和1异或的结果 7</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;nums.length ; i++) &#123;</span><br><span class="line">           sum^=nums[i];<span class="comment">//异或符^</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> first = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">//通过与运算找到result第一个不为0的首位，7=&gt;0111，也就是第一位</span></span><br><span class="line">       <span class="keyword">while</span>((sum&amp;first)==<span class="number">0</span>)&#123;</span><br><span class="line">           first=first&lt;&lt;<span class="number">1</span>;<span class="comment">//二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//first为1，所以我们可以根据数组元素的二进制低位第一位是否为1，将数组分为2类，</span></span><br><span class="line">       <span class="comment">// 示例数组可以分为     低位第一位为0：[4,4,6]     低位第一位为1：[1]</span></span><br><span class="line">       <span class="comment">//此时再将两个数组两两异或就可以得到最终结果。</span></span><br><span class="line">       <span class="keyword">int</span> result[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">           <span class="comment">//将数组分类。</span></span><br><span class="line">           <span class="keyword">if</span>((nums[i]&amp;first)==<span class="number">0</span>)&#123;<span class="comment">//&amp;按位与</span></span><br><span class="line">               result[<span class="number">0</span>]^=nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               result[<span class="number">1</span>]^=nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串转换整数</title>
    <url>/2020/05/19/%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="字符串转换整数"><a class="markdownIt-Anchor" href="#字符串转换整数"></a> 字符串转换整数</h1>
<p>请你来实现一个 <code>atoi</code> 函数，使其能将字符串转换成整数。</p>
<p>提示：本题中的空白字符只包括空格字符 ’ ’ 。<br />
假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231,  231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;42&quot;</span><br><span class="line">输出: 42</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;   -42&quot;</span><br><span class="line">输出: -42</span><br><span class="line">解释: 第一个非空白字符为 &#x27;-&#x27;, 它是一个负号。</span><br><span class="line">     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;4193 with words&quot;</span><br><span class="line">输出: 4193</span><br><span class="line">解释: 转换截止于数字 &#x27;3&#x27; ，因为它的下一个字符不为数字。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;words and 987&quot;</span><br><span class="line">输出: 0</span><br><span class="line">解释: 第一个非空字符是 &#x27;w&#x27;, 但它不是数字或正、负号。</span><br><span class="line">     因此无法执行有效的转换。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;-91283472332&quot;</span><br><span class="line">输出: -2147483648</span><br><span class="line">解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 </span><br><span class="line">     因此返回 INT_MIN (−231) 。</span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> solution&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars=s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> len=chars.length;</span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//去掉前导空格</span></span><br><span class="line">        <span class="keyword">while</span>(idx&lt;len&amp;&amp;<span class="keyword">char</span>[idx]==<span class="string">&#x27; &#x27;</span>)&#123;<span class="comment">//此处需判断idx是否小于len</span></span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx==len) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//若去掉前导空格到了末尾。</span></span><br><span class="line">        <span class="comment">//判断是否为负数</span></span><br><span class="line">        <span class="keyword">boolean</span> negative=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">char</span>[idx]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            negative=<span class="keyword">true</span>;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">char</span>[idx]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!Character.isDigit(<span class="keyword">char</span>[idx]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;len&amp;&amp;Character.isDigit(<span class="keyword">char</span>[idx]))&#123;</span><br><span class="line">            <span class="keyword">int</span> digit=<span class="keyword">char</span>[idx]-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//规律：任何数字字符减去0字符得到该字符对应的数字。ascall码</span></span><br><span class="line">            <span class="keyword">if</span>(ans&gt;(Integer.MAX_VALUE-digit)/<span class="number">10</span>)&#123;</span><br><span class="line">                <span class="comment">//判断是否越界</span></span><br><span class="line">                <span class="comment">//本来应该是 ans * 10 + digit &gt; Integer.MAX_VALUE</span></span><br><span class="line">                <span class="comment">// 但是 *10 和 + digit 都有可能越界，所有都移动到右边去就可以了。</span></span><br><span class="line">                <span class="keyword">return</span> negative? Integer.MIN_VALUE : Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            ans=ans*<span class="number">10</span>+digit;<span class="comment">//后续的digit陆续加入下一位，前一位乘10.</span></span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative? -ans:ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>统计数字在排序数组中出现的次数</title>
    <url>/2020/05/18/%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="统计数字在排序数组中出现的次数"><a class="markdownIt-Anchor" href="#统计数字在排序数组中出现的次数"></a> 统计数字在排序数组中出现的次数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>统计一个数字在排序数组中出现的次数。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>使用二分法分别找到该数字区的 左边界 left和 右边界 right ，易得数字 target 的数量为 right - left - 1 。</p>
<p>如上例 left=7，right=10。</p>
<p><strong>初始化</strong>： 左边界 i = 0，右边界 j = len(nums) - 1 。<br />
循环二分： 当闭区间 [i, j]无元素时跳出；<br />
计算中点 m = (i + j) / 2（向下取整）；<br />
若 nums[m] &lt; target ，则 target 在闭区间 [m + 1, j]中，因此执行 i = m + 1；<br />
若 nums[m] &gt; target ，则 target 在闭区间 [i, m - 1] 中，因此执行 j = m - 1；<br />
若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；左边界 left在闭区间 [i, m-1]中。因此分为以下两种情况：<br />
若查找 右边界 right ，则执行 i = m + 1；（跳出时 i指向右边界）<br />
若查找 左边界 left，则执行 j = m - 1 ；（跳出时 j 指向左边界）<br />
返回值： 应用两次二分，分别查找 right和 left ，最终返回 right - left - 1即可。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 搜索右边界 right</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= target) i = m + <span class="number">1</span>;<span class="comment">//注意此处&lt;=target，如此当i&gt;j时，得到右边界i。</span></span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right = i;</span><br><span class="line">        <span class="comment">// 若数组中无 target ，则提前返回</span></span><br><span class="line">        <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] != target) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 搜索左边界 right</span></span><br><span class="line">        i = <span class="number">0</span>; j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt; target) i = m + <span class="number">1</span>;<span class="comment">//此处&lt;target,当i&gt;j时，得到左边界j。</span></span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = j;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>把数组排成最小的数</title>
    <url>/2020/05/17/%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="把数组排成最小的数"><a class="markdownIt-Anchor" href="#把数组排成最小的数"></a> 把数组排成最小的数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,30,34,5,9]</span><br><span class="line">输出: &quot;3033459&quot;</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li>
<li>拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0</li>
</ul>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>将数字转化为字符串进行比较。如“3”，“30”比较方法：错位组合比较，330和303，得303更小。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">//判断数组是否为空</span></span><br><span class="line">        <span class="keyword">int</span> n=nums.length;</span><br><span class="line">        String[] minArray=<span class="keyword">new</span> String[n];   <span class="comment">//定义一个字符串数组放入整数元素并用空格隔开。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            minArray[i]=nums[i]+<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(minArray,(s1,s2)-&gt;(s1+s2).compareTo(s2+s1));<span class="comment">//字符串数组排序。使用lamda表达式作为内部函数进行比较。</span></span><br><span class="line">        String output=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(String str:minArray) <span class="comment">//输出数组排成的最小数字符串</span></span><br><span class="line">        output+=str;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Java空字符串与null区别：</strong></p>
<p>1、类型<br />
null表示的是一个对象的值，而并不是一个字符串。例如声明一个对象的引用，String a = null ;<br />
&quot;&quot;表示的是一个空字符串，也就是说它的长度为0。例如声明一个字符串String str = “” ;</p>
<p>2、内存分配<br />
String str = null ; 表示声明一个字符串对象的引用，但指向为null，也就是说还没有指向任何的内存空间；<br />
String str = “”;  表示声明一个字符串类型的引用，其值为&quot;&quot;空字符串，这个str引用指向的是空字符串的内存空间；</p>
<p><strong>Arrays.sort(minArray,(s1,s2)-&gt;(s1+s2).compareTo(s2+s1))解析：</strong><br />
对minArray进行排序，排序方法为对其中的元素s1、s2使用比较方法：s1+s2与s2+s1连接后数值大小比较</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>无重复字符的最长子串</title>
    <url>/2020/05/17/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="无重复字符的最长子串"><a class="markdownIt-Anchor" href="#无重复字符的最长子串"></a> 无重复字符的最长子串</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>可使用滑动窗口解题，定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复。</p>
<p>初始化start，end为窗口的首尾，皆指向字符串第一个字符；end++，在不出现重复的情况下将新元素加入map，并每轮记录当前窗口的最大值；若出现了重复，则start移动到该重复元素。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfsubString</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=s.length(),res=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;end&lt;n;end++)&#123;</span><br><span class="line">            <span class="keyword">char</span> curr=s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(curr))&#123;</span><br><span class="line">                start=Math.max(map.get(curr),start);<span class="comment">//初始map.get(end)==0</span></span><br><span class="line">            &#125;</span><br><span class="line">            res=Math.max(res,end-start+<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(end),end+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>把数字翻译成字符串</title>
    <url>/2020/05/16/%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="把数字翻译成字符串"><a class="markdownIt-Anchor" href="#把数字翻译成字符串"></a> 把数字翻译成字符串</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 12258</span><br><span class="line">输出: 5</span><br><span class="line">解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>此题类似于小孩爬楼梯，一次可爬一级或两级。可运用动态规划的思想解题。</p>
<p>0-25翻译为26个字母，在区间[10,25]内，如11，可翻译为bb或l。不在此区间的话则只能单个翻译。</p>
<p>记数字num第i位数字为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,数字num的位数为n。</p>
<p><strong>状态定义</strong>：设动态规划列表 dp ，dp[i] 代表以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>为结尾的数字的翻译方案数量。</p>
<p><strong>转移方程</strong>：若<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>组成的两位数字可以被翻译，则dp[i]=dp[i-1]+dp[i-2]   10<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo></mrow><annotation encoding="application/x-tex">x_i\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span></span></span></span>[10,25];</p>
<p>否则，dp[i]=dp[i-1]     10<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">x_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>+<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>∈</mo></mrow><annotation encoding="application/x-tex">x_i\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6891em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span></span></span></span>[0,10)<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∩</mo></mrow><annotation encoding="application/x-tex">\cap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.55556em;vertical-align:0em;"></span><span class="mord">∩</span></span></span></span>(25,99]。</p>
<p><strong>初始状态</strong>：dp[0]=dp[1]=1</p>
<p><strong>返回值</strong>：dp[n]</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String s = String.valueOf(num);</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            String tmp = s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="keyword">int</span> c = tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : a;</span><br><span class="line">            b = a;  <span class="comment">//推进</span></span><br><span class="line">            a = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>subString用法</strong></p>
<ul>
<li>str＝str.substring(int beginIndex);</li>
</ul>
<p>截取掉str从首字母起长度为beginIndex的字符串，将剩余字符串赋值给str；</p>
<ul>
<li>str＝str.substring(int beginIndex，int endIndex);</li>
</ul>
<p>截取str中从beginIndex开始至endIndex结束时的字符串，并将其赋值给str;</p>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>整数中1出现的次数</title>
    <url>/2020/05/16/%E6%95%B4%E6%95%B0%E4%B8%AD1%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="整数中1出现的次数"><a class="markdownIt-Anchor" href="#整数中1出现的次数"></a> 整数中1出现的次数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。</p>
<p>例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<h2 id="问题解法"><a class="markdownIt-Anchor" href="#问题解法"></a> 问题解法</h2>
<p>将从各位至最高位出现1的次数累加即可得到。</p>
<p>记当前位为cur，cur的左边所有位记为高位high；cur的右边所有位记为低位low；<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><msup><mn>0</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">10^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span>记为位因子digit。</p>
<p><strong>某位中出现1的次数计算方法</strong></p>
<ol>
<li>
<p>当cur=0时，此位1的个数计算公式为：high×digit。</p>
</li>
<li>
<p>当cur=1时，此位1的个数计算公式为：high×digit+low+1。</p>
</li>
<li>
<p>当cur=2，3，4，5，6，7，8，9时，此位1的个数计算公式为：（high+1）×digit。</p>
</li>
</ol>
<p><strong>变量递推</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> high != <span class="number">0</span> <span class="keyword">or</span> cur != <span class="number">0</span>   <span class="comment">//当 high 和 cur 同时为 0 时，说明已经越过最高位，因此跳出</span></span><br><span class="line">   low += cur * digit    <span class="comment">//将 cur 加入 low ，组成下轮 low</span></span><br><span class="line">   cur = high % <span class="number">10</span>      <span class="comment">//下轮 cur 是本轮 high 的最低位</span></span><br><span class="line">   high /= <span class="number">10</span>          <span class="comment">//将本轮 high 最低位删除，得到下轮 high</span></span><br><span class="line">   digit *= <span class="number">10</span>        <span class="comment">//位因子每轮 × 10</span></span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CountOne</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countDigitsOne</span><span class="params">(<span class="keyword">int</span>[] data)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">int</span> high=data/<span class="number">10</span>,cur=data%<span class="number">10</span>,low=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>,digit=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(high!=<span class="number">0</span>||cur!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur==<span class="number">0</span>)    res+=high*digit;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cur==<span class="number">1</span>)    res+=high*digit+low+<span class="number">1</span>; </span><br><span class="line">            <span class="keyword">else</span>    res+=(high+<span class="number">1</span>)*digit; </span><br><span class="line">            <span class="comment">//变量递推</span></span><br><span class="line">            low+=cur*digit;</span><br><span class="line">            cur=high%<span class="number">10</span>;</span><br><span class="line">            high/=<span class="number">10</span>;</span><br><span class="line">            digit*=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>礼物的最大价值</title>
    <url>/2020/05/16/%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="礼物的最大价值"><a class="markdownIt-Anchor" href="#礼物的最大价值"></a> 礼物的最大价值</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>可使用动态规划解决此题。</p>
<p><strong>状态定义</strong>：设动态规划矩阵dp，dp[i,j]代表从棋盘的左上角开始，到达[i,j]单元格能拿到最多礼物的累积值。</p>
<p><strong>转移方程</strong>：</p>
<ol>
<li>
<p>当i=0，j=0时，为起始元素。</p>
</li>
<li>
<p>当i=0，j$\ne$0时，为矩阵第一行元素，只可能从左边到达。</p>
</li>
<li>
<p>当i$\ne$0，j=0时，为矩阵第一列元素，只可能从上边到达。</p>
</li>
<li>
<p>当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi mathvariant="normal">≠</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">i\ne0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi mathvariant="normal">≠</mi><mn>0</mn></mrow><annotation encoding="application/x-tex">j\ne0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>时，可从左边或上边到达，据题意取两者中的最大值</p>
</li>
</ol>
<p><strong>初始状态</strong>：dp[0][0]=grid[0][0]。</p>
<p><strong>返回值</strong>：dp[m-1][n-1],其中m，n为矩阵的长宽，即返回dp右下角元素。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m=grid.length;</span><br><span class="line">        <span class="keyword">int</span> n=grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>&amp;&amp;j==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>) grid[i][j]+=grid[i][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) grid[i][j]+=grid[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j]+=Math.max(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中出现一次的数字Ⅱ</title>
    <url>/2020/05/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97%E2%85%A1/</url>
    <content><![CDATA[<h1 id="数组中出现一次的数字ii"><a class="markdownIt-Anchor" href="#数组中出现一次的数字ii"></a> 数组中出现一次的数字Ⅱ</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>解法一</strong></p>
<p>可考虑用一个HashMap来存，key为数字，value为出现次数。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleNumber</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSingleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c)) &#123;</span><br><span class="line">                map.put(c, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(c, map.get(c) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key: map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(key).equals(<span class="number">1</span>))&#123;</span><br><span class="line">               result=key;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        SingleNumber singleNumber=<span class="keyword">new</span> SingleNumber();</span><br><span class="line">        System.out.println(singleNumber.getSingleNumber(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>解法二</strong></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//a为对应位的1出现2次的记录，b为对应位出现1次的记录，ab共同组成该位出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>,b =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            b = ~a&amp;(b^i);</span><br><span class="line">            a = ~b&amp;(a^i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>数据流中的中位数</title>
    <url>/2020/05/15/%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="数据流中的中位数"><a class="markdownIt-Anchor" href="#数据流中的中位数"></a> 数据流中的中位数</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) / 2 = 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br />
double findMedian() - 返回目前所有元素的中位数。</p>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]</span><br><span class="line">[[],[1],[2],[],[3],[]]</span><br><span class="line">输出：[null,null,null,1.50000,null,2.00000]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>可将数据流保存在一个列表中，并将其有序排列，在添加元素时保持有序，中位数即其中间元素。</p>
<p>进一步，可考虑使用堆来优化时间复杂度。</p>
<p>建立一个小堆顶A，一个大堆顶B，各保存列表的一半元素。且规定：</p>
<ul>
<li>
<p>A保存较大的一部分，长度为n/2，n为偶数；长度为n+1/2，n为奇数。</p>
</li>
<li>
<p>B保存较小的一部分，长度为n/2，n为偶数；长度为n-1/2，n为奇数。</p>
</li>
</ul>
<p>中位数返回堆顶元素的和的一半即得。</p>
<p><strong>增加元素</strong></p>
<p>设元素总数为 N = m + n ，其中 m 和 n 分别为 A 和 B 中的元素个数。</p>
<ul>
<li>当 m=n，即N为偶数：需向A添加一个元素。实现方法：将新元素放入B，并将B的堆顶元素（大的数）放入A。</li>
<li>当N为奇数，需向B添加一个元素（因为B少一个）。实现方法：将新元素放入A，并将A的堆顶元素（小的数）放入B。</li>
</ul>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MediumFinder</span></span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MediumFinder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A=<span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        B=<span class="keyword">new</span> PriorityQueue&lt;&gt;((x,y)-&gt;(y-x)); <span class="comment">//java实现大堆顶。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size()!=B.size())&#123;</span><br><span class="line">            A.add(num);</span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            B.add(num);</span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedium</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.size()!==B.size()? A.peek():(A.peek()+B.peek())/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2020/05/14/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h1 id="多数元素"><a class="markdownIt-Anchor" href="#多数元素"></a> 多数元素</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<h3 id="方法一-哈希表"><a class="markdownIt-Anchor" href="#方法一-哈希表"></a> 方法一  哈希表</h3>
<p>我们可以用一个哈希表来存储每个元素出现的次数，key为数值，value为出现次数。然后遍历HashMap寻找value大于1/2 length的数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;Integer,Integer&gt; <span class="title">countNums</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; count=<span class="keyword">new</span> Map&lt;Integer,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!count.containsKey(num))&#123;</span><br><span class="line">                count.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count.put(num,count.get(num)+<span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; counts = countNums(nums);</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; majorityEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (majorityEntry == <span class="keyword">null</span> || entry.getValue() &gt; majorityEntry.getValue()) &#123;</span><br><span class="line">                majorityEntry = entry;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> majorityEntry.getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法二-排序"><a class="markdownIt-Anchor" href="#方法二-排序"></a> 方法二   排序</h3>
<p>将数组进行从小到大排序，出现次数超过一半以上必定出现在中间位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法三-摩尔投票法"><a class="markdownIt-Anchor" href="#方法三-摩尔投票法"></a> 方法三  摩尔投票法</h3>
<p>票数和： 由于众数出现的次数超过数组长度的一半；若记 众数 的票数为+1 ，非众数 的票数为 -1 ，则一定有所有数字的 票数和 &gt; 0。<br />
票数正负抵消： 设数组 nums 中的众数为 x，数组长度为 n 。若 nums 的前 a 个数字的 票数和 =0 ，则 数组后 (n−a) 个数字的 票数和一定仍 &gt;0，即后 (n-a)个数字的 众数仍为 x 。</p>
<p>算法流程:<br />
初始化： 票数统计 votes = 0 ， 众数 x；<br />
循环抵消： 遍历数组 nums 中的每个数字 num ；<br />
当 票数 votes 等于 0，则假设 当前数字 num 为 众数 x ；<br />
当 num = x 时，票数 votes 自增 1 ；否则，票数 votes 自减 1 。<br />
返回值： 返回 众数 x 即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vote=<span class="number">0</span>,x=<span class="number">0</span>,count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vote==<span class="number">0</span>) x=num;</span><br><span class="line">        vote+=num==x? <span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//验证是否为众数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num==x) count++;</span><br><span class="line">        <span class="keyword">return</span> count&gt;nums.length/<span class="number">2</span>? x:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2020/05/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dp%EF%BC%89/</url>
    <content><![CDATA[<h1 id="动态规划dp"><a class="markdownIt-Anchor" href="#动态规划dp"></a> 动态规划（dp）</h1>
<h2 id="递归与动态规划"><a class="markdownIt-Anchor" href="#递归与动态规划"></a> 递归与动态规划</h2>
<p>动态规划是自底向上，递归树是自顶向下。</p>
<p><strong>自顶向下</strong>：从一个规模较大的问题向下逐渐分解。如斐波那契问题，计算 f(20)，逐步分解到f(1)、f(2)，然后返回结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">Fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归虽然代码优雅，但是数值过大可能会算不出来。</span></span><br></pre></td></tr></table></figure>
<p><strong>自底向上</strong>：从最底下、最简单的问题开始往上推，也就是动态规划的思想，通过循环迭代得到结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用动态规划计算斐波那契数列</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(N+<span class="number">1</span>,<span class="number">0</span>)</span></span>;<span class="comment">//dp数组初始化</span></span><br><span class="line">    dp[<span class="number">1</span>]=dp[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。</p>
<p><strong>问题是否能用动态规划解决的是这些”小问题“会不会被被重复调用。</strong></p>
<h2 id="能用动态规划解决的问题"><a class="markdownIt-Anchor" href="#能用动态规划解决的问题"></a> 能用动态规划解决的问题</h2>
<p><strong>1、问题的答案依赖于问题的规模，也就是问题的所有答案构成了一个数列。</strong></p>
<p><strong>2、大规模问题的答案可以由小规模问题的答案递推得到，也就是</strong><img src="https://www.zhihu.com/equation?tex=f%28n%29" alt="[公式]" /><strong>的值可以由</strong><img src="https://www.zhihu.com/equation?tex=%5C%7Bf%28i%29%7Ci%3Cn%5C%7D" alt="[公式]" /><strong>中的个别求得。</strong></p>
<h2 id="应用动态规划"><a class="markdownIt-Anchor" href="#应用动态规划"></a> 应用动态规划</h2>
<p>1、建立状态转移方程</p>
<p>2、缓存和复用以往结果</p>
<p>3、按顺序从小往大算</p>
<h2 id="经典题型"><a class="markdownIt-Anchor" href="#经典题型"></a> 经典题型</h2>
<h3 id="连续子数组的最大和"><a class="markdownIt-Anchor" href="#连续子数组的最大和"></a> 连续子数组的最大和</h3>
<p><strong>问题陈述</strong></p>
<p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p>
<p>要求时间复杂度为O(n)。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure>
<p><strong>思路分析</strong></p>
<p>连续子数组，和最大，我们可以用dp的思想来解决此类问题，</p>
<p>走一遍nums数组元素，初始值为dp[0]=-2,从dp[1]开始判断，若之前和大于0，则加上；若小于0，则dp[i]=nums[i]。</p>
<p>并定义res存储最大值，res初始化为nums[0]，并与每次的dp[i]比较取最大值。</p>
<p>通过上述分析：即知转移条件为：**dp[i]=nums[i]     当dp[i-1]&lt;0; **</p>
<p>​                                                          <strong>dp[i]=nums[i]+dp[i-1]      当dp[i-1]&gt;0</strong>。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处代码与上思想一致，只是dp[]覆盖了原来的nums数组。即新的nums数组即为dp。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i-<span class="number">1</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                nums[i]=nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[i]+=nums[i-<span class="number">1</span>];</span><br><span class="line">            &#125; </span><br><span class="line">            res=Math.max(res,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树中和为某一值的路径</title>
    <url>/2020/05/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="二叉树中和为某一值的路径"><a class="markdownIt-Anchor" href="#二叉树中和为某一值的路径"></a> 二叉树中和为某一值的路径</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例:<br />
给定如下二叉树，以及目标和 sum = 22。</p>
<pre><code>          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
</code></pre>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>对每一层进行递归迭代，下一次的sum为sum减去当前已访问结点值。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;<span class="function">List&lt;Integer&gt; <span class="title">pathSum</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        recurr(root,sum);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recurr</span><span class="params">(TreeNode root,<span class="keyword">int</span> res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        res-=root.val;</span><br><span class="line">        <span class="keyword">if</span>(res==<span class="number">0</span>&amp;&amp;root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">            list.add(<span class="keyword">new</span> LinkedList&lt;&gt;(path));</span><br><span class="line">        recurr(root.left,res);</span><br><span class="line">        recurr(root.right,res);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的后序遍历序列</title>
    <url>/2020/05/09/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="二叉搜索树的后序遍历序列"><a class="markdownIt-Anchor" href="#二叉搜索树的后序遍历序列"></a> 二叉搜索树的后序遍历序列</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  2   6</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>示例 1：</p>
<p>输入: [1,6,3,2,5]<br />
输出: false</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>二叉搜索树：左子树的值小于根，右子树的值大于根。</p>
<p>后序遍历：左右根。如上示例，后序遍历为13265。</p>
<img src="https://pic.leetcode-cn.com/4a2780853b72a0553194773ff65c8c81ddcc4ee5d818cb3528d5f8dd5fa3b6d8-Picture1.png" style="zoom:50%;" />
<p>递归判断：具体见代码注释。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recurr</span>(postorder,<span class="number">0</span>,postorder.<span class="built_in">size</span>()<span class="number">-1</span>); <span class="comment">//递归判断，初始化i=0，j=postorder.size()-1</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recurr</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; postorder,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//结点数小于等于1的情况</span></span><br><span class="line">        <span class="keyword">int</span> p=i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p]&lt;postorder[j]) p++; <span class="comment">//小于根结点的为左子树</span></span><br><span class="line">        <span class="keyword">int</span> m=p;  <span class="comment">//记录此时的p，如上例为6</span></span><br><span class="line">        <span class="keyword">while</span>(postorder[p]&gt;postorder[j]) p++; <span class="comment">//大于根结点的为右子树，p++后若为正确的后序序列则p==j</span></span><br><span class="line">        <span class="keyword">return</span> p==j&amp;&amp;<span class="built_in">recurr</span>(postorder,i,m<span class="number">-1</span>)&amp;&amp;<span class="built_in">recurr</span>(postorder,m,j<span class="number">-1</span>); <span class="comment">//继续判断下一级的左右子树，即132和6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPostorder</span><span class="params">(<span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span>[] postorder, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//说明子树节点数&lt;=1</span></span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &lt; postorder[j]) p++;</span><br><span class="line">        <span class="keyword">int</span> m = p;</span><br><span class="line">        <span class="keyword">while</span>(postorder[p] &gt; postorder[j]) p++;</span><br><span class="line">        <span class="keyword">return</span> p == j &amp;&amp; recur(postorder, i, m - <span class="number">1</span>) &amp;&amp; recur(postorder, m, j - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>复制带随机指针的链表</title>
    <url>/2020/05/09/%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="复制带随机指针的链表"><a class="markdownIt-Anchor" href="#复制带随机指针的链表"></a> 复制带随机指针的链表</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。</p>
<p>要求返回这个链表的 深拷贝。</p>
<p>我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：</p>
<p>val：一个表示 Node.val 的整数。<br />
random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</p>
<p>示例：</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png" alt="" /></p>
<blockquote>
<p>输入：head = [[3,null],[3,0],[3,null]]<br />
输出：[[3,null],[3,0],[3,null]]</p>
</blockquote>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>浅拷贝与深拷贝</strong></p>
<p>浅拷贝只复制指针的指向，即a和b共用同一个内存空间。深拷贝则开辟了一个新的内存空间用以存储该内容。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<p><strong>回溯法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment">    public Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val,Node _next,Node _random) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">        random = _random;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> solution&#123;</span><br><span class="line">    <span class="comment">//HashMap中旧结点存储为键，新结点存储为值。</span></span><br><span class="line">    HashMap&lt;Node,Node&gt; visitedHash=<span class="keyword">new</span> HashMap&lt;Node,Node&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">copeRandomList</span><span class="params">(Node head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//如果存在当前结点，直接返回它的复制。</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.visitedHash.containsKey(head))  <span class="keyword">return</span> <span class="keyword">this</span>.visitedHash.get(head);</span><br><span class="line">        <span class="comment">//若不存在，则创建一个新结点。</span></span><br><span class="line">        Node node=<span class="keyword">new</span> Node(head.val,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//将其放入HashMap</span></span><br><span class="line">        <span class="keyword">this</span>.visitedHash.put(head,node);</span><br><span class="line">        <span class="comment">//循环下一结点</span></span><br><span class="line">        node.next=<span class="keyword">this</span>.copeRandomList(head.next);</span><br><span class="line">        node.random=<span class="keyword">this</span>.copeRandomList(head.random);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>O(n)空间迭代法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">      <span class="comment">// Visited dictionary to hold old node reference as &quot;key&quot; and new node reference as the &quot;value&quot;</span></span><br><span class="line">  HashMap&lt;Node, Node&gt; visited = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line"><span class="comment">//获取复制结点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">getClonedNode</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If the node exists then</span></span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Check if the node is in the visited dictionary</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.visited.containsKey(node)) &#123;</span><br><span class="line">        <span class="comment">// If its in the visited dictionary then return the new node reference from the dictionary</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.visited.get(node);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise create a new node, add to the dictionary and return it</span></span><br><span class="line">        <span class="keyword">this</span>.visited.put(node, <span class="keyword">new</span> Node(node.val, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.visited.get(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//复制带有random指针的链表。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Node <span class="title">copyRandomList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node oldNode = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating the new head node.</span></span><br><span class="line">    Node newNode = <span class="keyword">new</span> Node(oldNode.val);</span><br><span class="line">    <span class="keyword">this</span>.visited.put(oldNode, newNode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate on the linked list until all nodes are cloned.</span></span><br><span class="line">    <span class="keyword">while</span> (oldNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Get the clones of the nodes referenced by random and next pointers.</span></span><br><span class="line">      newNode.random = <span class="keyword">this</span>.getClonedNode(oldNode.random);</span><br><span class="line">      newNode.next = <span class="keyword">this</span>.getClonedNode(oldNode.next);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Move one step ahead in the linked list.</span></span><br><span class="line">      oldNode = oldNode.next;</span><br><span class="line">      newNode = newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.visited.get(head);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的压入、弹出序列</title>
    <url>/2020/05/01/%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈的压入-弹出序列"><a class="markdownIt-Anchor" href="#栈的压入-弹出序列"></a> 栈的压入、弹出序列</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定一个入栈序列，可能存在多种出栈序列。然后我们给定一个出栈序列，判断它是否是正确的出栈序列。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<ul>
<li>按入栈序列逐个入栈并判断当前栈顶元素是否和出栈序列元素相等，若相等则出栈该元素，同时出栈序列指向下一个元素。</li>
<li>继续入栈，继续判断。若为合理的出栈序列，最后栈必空。</li>
</ul>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackPop_sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">is_StackPop_sequence</span><span class="params">(<span class="keyword">int</span>[] in,<span class="keyword">int</span>[] out)</span></span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>,n=out.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;in.length;i++)&#123;</span><br><span class="line">            stack.push(in[i]);</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty()&amp;&amp;j&lt;n&amp;&amp;stack.peek()==out[j])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] in=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] out=&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        StackPop_sequence stackPop_sequence=<span class="keyword">new</span> StackPop_sequence();</span><br><span class="line">        System.out.println(stackPop_sequence.is_StackPop_sequence(in,out));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/2020/05/01/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5&amp;%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="顺时针打印矩阵螺旋矩阵"><a class="markdownIt-Anchor" href="#顺时针打印矩阵螺旋矩阵"></a> 顺时针打印矩阵&amp;螺旋矩阵</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
<p>示例 1：</p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]<br />
输出：[1,2,3,6,9,8,7,4,5]<br />
示例 2：</p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]<br />
输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p><strong>空值处理</strong>：当matrix为空时，直接返回空列表。</p>
<p><strong>初始化</strong>：左右上下四个边界l，r，t，b。</p>
<p><strong>循环打印</strong>：</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cirlcle_printMatrix</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] spiralOrder(<span class="keyword">int</span>[][] matrix)&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right.</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom.</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="螺旋矩阵"><a class="markdownIt-Anchor" href="#螺旋矩阵"></a> 螺旋矩阵</h2>
<p>给定一个正整数 <em>n</em>，生成一个包含 1 到 <em>n^2</em>所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span> t=<span class="number">0</span>,b=n-<span class="number">1</span>,l=<span class="number">0</span>,r=n-<span class="number">1</span>,num=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tar=n*n;</span><br><span class="line">        <span class="keyword">int</span>[][] mat=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">while</span>(num&lt;=tar)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;i++) mat[t][i]=++num;</span><br><span class="line">            <span class="keyword">if</span>(++t&gt;b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t;i&lt;=b;i++) mat[i][r]=++num;</span><br><span class="line">            <span class="keyword">if</span>(--r&lt;l) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=l;i--) mat[b][i]=++num;</span><br><span class="line">            <span class="keyword">if</span>(--b&lt;t) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=b;i&gt;=t;i--) mat[i][l]=++num;</span><br><span class="line">            <span class="keyword">if</span>(++l&gt;r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的镜像</title>
    <url>/2020/05/01/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="二叉树的镜像"><a class="markdownIt-Anchor" href="#二叉树的镜像"></a> 二叉树的镜像</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如输入：</span><br><span class="line">       4</span><br><span class="line">      /  \</span><br><span class="line">     2    7</span><br><span class="line">    /\    /\</span><br><span class="line">   1  3  6  9 </span><br><span class="line">镜像输出：</span><br><span class="line">​      4</span><br><span class="line">​    /   \</span><br><span class="line">    7     2</span><br><span class="line">   / \   / \</span><br><span class="line">  9   6 3   1</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>如何实现镜像反转，其实就是从上到下对每个结点的左右结点进行交换，如果存在左（右）结点一个为空，则同样与空结点进行交换。</p>
<p>考虑栈结构的特性，可以用栈暂存结点。先根结点入栈，当栈不空，定义输出镜像为弹出的栈顶元素。继续，如果根结点的左结点不空，加入左结点；右结点不空，加入右结点。然后实现交换左右结点。</p>
<p>如此，实现。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree_Mirror</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">treeMirror</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;         <span class="comment">//判断树是否为空</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//定义类型为TreeNode的栈</span></span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;     <span class="comment">//循环输出镜像二叉树元素</span></span><br><span class="line">            TreeNode node=stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) stack.push(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) stack.push(node.right);</span><br><span class="line">            TreeNode curr=node.left;   <span class="comment">//交换左右结点</span></span><br><span class="line">            node.left=node.right;</span><br><span class="line">            node.right=curr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前结点已经是左叶子，那就是叶子左空结点与有空结点交换，然后wlile判断输出该叶子结点，继续右叶子如此。</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>从上到下打印二叉树</title>
    <url>/2020/05/01/%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="从上到下打印二叉树"><a class="markdownIt-Anchor" href="#从上到下打印二叉树"></a> 从上到下打印二叉树</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定二叉树: [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">​     3</span><br><span class="line">​    / \</span><br><span class="line">    9  20</span><br><span class="line">​      / \</span><br><span class="line">      15  7</span><br><span class="line">返回：</span><br><span class="line">[3,9,20,15,7]</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>按层遍历输出的话可想到BFS（宽度优先遍历）。由此可用LinkedList结构的队列存储TreeNode，结点值存在ArrayList，然后以数组方式遍历输出。</p>
<p>具体步骤：</p>
<ul>
<li>
<p>若为空，直接返回一个空数组。</p>
</li>
<li>
<p>根结点入队，根（首次为根，后续为队列下一结点）结点出队存入ArrayList，判断根结点的左右结点是否为空，不空则加入队列。这样不断入队出队，直到队列为空。</p>
</li>
<li>
<p>以数组方式打印出ArrayList元素。</p>
</li>
</ul>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS_printBT</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">levelPrint</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;()&#123;&#123;add(root);&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node= queue.poll();</span><br><span class="line">            list.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BFS_printBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] levelOrder(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ans.size();i++)&#123;</span><br><span class="line">            res[i]=ans.get(i);</span><br><span class="line">            System.out.println(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.left=<span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.right=<span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">        BFS_printBinaryTree bfs_printBinaryTree=<span class="keyword">new</span> BFS_printBinaryTree();</span><br><span class="line">        bfs_printBinaryTree.levelOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="相关知识点"><a class="markdownIt-Anchor" href="#相关知识点"></a> 相关知识点</h2>
<h3 id="arraylist和linkedlist比较"><a class="markdownIt-Anchor" href="#arraylist和linkedlist比较"></a> ArrayList和LinkedList比较</h3>
<h4 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h4>
<ul>
<li>ArrayList是线性表（数组）</li>
<li>get（）  直接获取某个元素，复杂度为O(1)。</li>
<li>add（）  添加元素，复杂度O(1)。</li>
<li>add（index，e） 在第e个元素后加入元素，起后元素需要后移，复杂度为O(n)。</li>
<li>remove（）  删除元素，其后元素需要后移，复杂度为O(n)。</li>
</ul>
<h4 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h4>
<ul>
<li>LinkedList是链表。</li>
<li>get（）  获取某个元素，依次遍历，复杂度为O(n)。</li>
<li>add（）  添加元素，复杂度O(1)。</li>
<li>add（index，e） 在第e个元素后加入元素，先查找到第e个元素，然后指针指向操作，整个过程复杂度为O(n)。</li>
<li>remove（）  删除元素，直接指针指向，复杂度为O(1)。</li>
</ul>
<h3 id="queue的remove和poll方法"><a class="markdownIt-Anchor" href="#queue的remove和poll方法"></a> queue的remove（）和poll（）方法</h3>
<ul>
<li>Queue 中 remove() 和 poll() 都是用来从队列头部删除一个元素。</li>
<li>在队列元素为空的情况下，remove() 方法会抛出NoSuchElementException异常，poll() 方法只会返回 null 。</li>
</ul>
<h2 id="实现打印每一层后换行输出"><a class="markdownIt-Anchor" href="#实现打印每一层后换行输出"></a> 实现打印每一层后换行输出</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelorder(TreeNode root)&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">//&#123;&#123;3&#125;,&#123;9,20&#125;,&#123;15,7&#125;&#125;</span></span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>) queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; tmp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123; <span class="comment">//初始化为当前queue的size，第一次size为1，第二次为2，第三次为2</span></span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            tmp.add(node.val); <span class="comment">//tmp添加node</span></span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现之字形打印"><a class="markdownIt-Anchor" href="#实现之字形打印"></a> 实现之字形打印</h2>
<p>第一行从左到右打印，第二行从右到左打印，依次交替~</p>
<p>思路：BFS+双端队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root)&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="keyword">null</span>) queue.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; tmp=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=queue.size();i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            TreeNode node=queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(res.size()%<span class="number">2</span>==<span class="number">0</span>) tmp.addLast(node.val);</span><br><span class="line">            <span class="keyword">else</span> tmp.addFirst(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另：反转 list  可直接用</p>
<p>Collections.reverse( list );</p>
</blockquote>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>对称二叉树</title>
    <url>/2020/05/01/%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="对称二叉树"><a class="markdownIt-Anchor" href="#对称二叉树"></a> 对称二叉树</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</span><br><span class="line"></span><br><span class="line">​   1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br><span class="line">但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</span><br><span class="line"></span><br><span class="line">​   1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">    3   3</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>考虑递归实现，先判断树是否为空，不空继续，递归判断其左结点和右结点是否相同。如果其左和右为空，返回true；如果左为空或者右为空或者左与右不相等，返回false；不空的话继续判断左的左和右的右，左的右和右的左。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Symmetric_BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//空也是对称呀</span></span><br><span class="line">        <span class="keyword">return</span> recurrison(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recurrison</span><span class="params">(TreeNode left,TreeNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>&amp;&amp;right==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="keyword">null</span>||right==<span class="keyword">null</span>||left.val!=right.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recurrison(left.left,right.right)&amp;&amp;recurrison(left.right,right.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//main函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        root.left=<span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        root.right=<span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        Symmetric_BinaryTree symmetric_binaryTree=<span class="keyword">new</span> Symmetric_BinaryTree();</span><br><span class="line">        System.out.println(symmetric_binaryTree.isSymmetric(root));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>包含min函数的栈</title>
    <url>/2020/05/01/%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h1 id="包含min函数的栈"><a class="markdownIt-Anchor" href="#包含min函数的栈"></a> 包含min函数的栈</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<blockquote>
<p>示例:</p>
<p>MinStack minStack = new MinStack();<br />
minStack.push(-2);<br />
minStack.push(0);<br />
minStack.push(-3);<br />
minStack.min();   --&gt; 返回 -3.<br />
minStack.pop();<br />
minStack.top();      --&gt; 返回 0.<br />
minStack.min();   --&gt; 返回 -2.</p>
</blockquote>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>普通栈的push和pop操作的时间复杂度为O(1)，但是获取min则需要遍历一遍，复杂度为O(n)。</p>
<p>如此，我们考虑使用一个辅助栈来实现。</p>
<p>主栈：用于存储所有元素，实现正常的出入栈操作，获取栈顶元素等。</p>
<p>辅助栈：用于另存入主栈元素出现的最小元素，如先存入第一个入主栈元素，后面入栈元素依次与之比较，若更小，则继续存入，确保最小元素永远在辅助栈的栈顶。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Min_Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Stack&lt;Integer&gt; A,B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Min_Stack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        A=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        B=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        A.add(x);</span><br><span class="line">        <span class="keyword">if</span>(B.isEmpty()||B.peek()&gt;=x)<span class="comment">//判断栈空只能用isEmpty，或者是peek=-1。不能用null</span></span><br><span class="line">            B.add(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.pop().equals(B.peek()))<span class="comment">//每次弹出最小元素</span></span><br><span class="line">            B.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> A.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> B.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>自叙</title>
    <url>/2020/04/26/%E8%87%AA%E5%8F%99/</url>
    <content><![CDATA[<p>他到底是一个什么样的人他自己也说不明白，他是一个有着和三毛一样心思的男子，痴迷古典文化，向往人世间一切美好的情愫，他念旧他深情他平庸他另类。关于他的故事，实在多的如长夏夜夜满天的繁星，望去点点的璀璨亦是同样的神秘且遥不可及。</p>
<p>他喜欢明末的张岱。崇祯五年十二月，余住西湖。大雪三日，湖中人鸟声俱绝。是日更定矣，余拏一小舟，拥毳衣炉火，独往湖心亭看雪……<br />
为景而痴，为遇陌路相谈者欢，莫说相公痴，更有痴似相公者！</p>
<p>他喜欢林黛玉，是一个彻底的红楼迷，红楼和诗词铺就了他青春的色彩，他自诩为书中的贾宝玉，可他却又未有过贾宝玉的身世遭逢，他是一个辛苦遭逢的红尘畸零客。他更对林黛玉有莫名的好感，那种好，就像是前世的已然相知，她的音容笑貌一颦一蹙一言一行他都如数家珍呀！是呆了傻了！是一生的相思病呀！他只记得花明月暗，薄雾轻笼的秋夜，他和她相偎相诺自此一万年也舍不去的深情呀！</p>
<p>他喜欢沈三白 ，沈三白何其有幸，遇上芸娘。何其有幸 ，得葆一片痴心赤性。他实在喜欢《浮生六记》里的每一个字，闺房记乐，闲情记趣，坎坷记愁，浪游记快……一生的起承转合都在里头了，他的记忆又何尝不丰，他以后也是要写一部《浮生六记》的，《红楼梦》开篇“满纸荒唐言，一把辛酸泪，都云作者痴，谁解其中味”，那么，他就是那个一心人，他不要大观园的热闹，只要天南地北的双宿双飞，在尾页留一句: “来世卿为男子，我为女子相从。”</p>
<p>这样的话，说出来便足以惊世骇俗，是不足为外人道也，如果他说了，那是真的就是一辈子了。世间男子一生说的念的都是女子，好像没了女子，男子便少去了一缕精魂。</p>
<p>纳兰容若的“一生一代一双人”；仓央嘉措的“转山转水转佛塔，不为修来生，只为途中与你相见”；苏东坡的“夜来幽梦忽还乡，小轩窗，正梳妆”；辛弃疾的“倩何人唤取？红巾翠袖，揾英雄泪”；陆游的“伤心桥下春波绿，曾是惊鸿照影来”；李商隐的“何当共剪西窗烛，却话巴山夜雨时”；李煜的“画堂南畔见，一向偎人颤，奴为出来难，教人恣意怜”……</p>
<p>我忽然深深的怅惘，这世上还有哪样的男子是不一样的，兰陵笑笑生写《金瓶梅》，西门庆和潘金莲便是这俗人世界的男欢女爱的代表，寻常老百姓也有他的拙荆。似乎找不到了，某个深秋，我独自彳亍在西子湖畔，经慕才亭过西泠桥到孤山放鹤亭，相传“梅妻鹤子”的林处士一生不娶，植梅放鹤，但他墓中的端砚和玉簪或许又说明他也是有心上人的，只是心上人无意于他了，或许是这样的。漫揾两行泪，相离处士家。<br />
我遥望着络绎不绝的人们走上了断桥……</p>
<p>可是此刻，雨打孤山冷，江边潮已生。</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
      <tags>
        <tag>心迹</tag>
      </tags>
  </entry>
  <entry>
    <title>读《琅嬛文集》录</title>
    <url>/2020/04/24/%E8%AF%BB%E3%80%8A%E7%90%85%E5%AC%9B%E6%96%87%E9%9B%86%E3%80%8B%E5%BD%95/</url>
    <content><![CDATA[<h1 id="读琅嬛文集录"><a class="markdownIt-Anchor" href="#读琅嬛文集录"></a> 读《琅嬛文集》录</h1>
<p>近来读张岱《琅嬛文集》，遇见许多赏心悦目的文字，摘录此篇分享给大家。</p>
<p>故知世间山川、云物、水火、草木、色声、香味，莫不有冰雪之气；其所以恣人挹取受用之不尽者，莫深于诗文。</p>
<p>山之有空翠，气之有沆瀣，月之有烟霜，竹之有苍蒨，食味之有生鲜，古铜之有青绿，玉石之有胞浆，诗之有冰雪，皆是物也。苏长公曰：“子由近作《栖贤僧堂记》，读之惨凉，觉崩崖飞瀑，逼人寒栗。”噫！此岂可与俗人道哉！笔墨之中，崖瀑何从来哉！</p>
<p>​                                            ——一卷冰雪文序</p>
<p>余幼遵大父教，不读朱注。凡看经书，未尝敢以各家注疏横据胸中。正襟危坐，朗诵白文数十余过，其意义忽然有省。间有不能强解者，无意无义，贮之胸中。或一年，或二年，或读他书，或听人议论，或见山川云物鸟兽虫鱼，触目惊心，忽于此书有悟，取而出之，名曰《四书遇》。盖“遇”之云者，谓不于其家，不于其寓，直于途次之中邂逅遇之也。古人见道旁蛇斗而悟草书，见公孙大娘舞剑器而笔法大进，盖真有以遇之也。古人精思静悟，钻研已久，而石火电光，忽然灼露，其机神摄合，政不知从何处着想也。举子十年攻苦于风檐寸晷之中，构成七艺，而主司以醉梦之余，忽然相投，如磁引铁，如珀摄刍，相悦以解。直欲以全副精神注之，其所遇之奥窍，真有不可得而自解者矣。推而究之，色声香味触发中间无不有遇之一窍，特留以待深心明眼之人，邂逅相遇，遂成莫逆耳。</p>
<p>余遭乱离两载，东奔西走，身无长物，委弃无余。独于此书，收之箧底，不遗只字。</p>
<p>​                                               ——四书遇序</p>
<p>鸡鸣枕上，夜气方回，因想余生平：繁华靡丽，过眼皆空，五十年来，总成一梦。今当黍熟黄粱，车旋蚁穴，当作如何消受？遥思往事，忆即书之，持向佛前，一一忏悔。不次岁月，异年谱也；不分门类，别志林也。偶拈一则，如游旧径，如见故人，城郭人民，翻用自喜，真所谓痴人前不得说梦矣。</p>
<p>昔有西陵脚夫，为人担酒，失足破其瓮，念无以偿，痴坐伫想曰：“得是梦便好。”一寒士乡试中式，方赴鹿鸣宴，恍然犹忆非真，自啮其臂曰：“莫是梦否？”一梦耳，惟恐其非梦，又惟恐其是梦，其为痴人则一也。余今大梦将寤，犹事雕虫，又是一番梦呓。因叹慧业文人，名心难化，政如邯郸梦断，漏尽钟鸣，卢生遗表，犹思摹拓二王，以流传后世。则其名根一点，坚固如佛家舍利，劫火猛烈，犹烧之不失也。</p>
<p>​                                             ——陶庵梦忆序</p>
<p>周又新先生每啜茶，辄道白门闵文水。尝曰：“恨不令宗子见。”一日，文水至越，访又新先生，携茶具，急至予舍。余时在武陵不值，后归，甚懊丧。</p>
<p>戊寅余至白门。甫登岸，即往桃叶渡访文水。时日晡矣，余至文水家，文水亦他出。余坐久。余意文水一少年好事者，及至，则瞿瞿一老子，与余叙款曲，愕愕如野鹿不可接。方欲纵谈，而老子忽起曰：“余杖忘某所，去取杖。”起席竟去。余曰：“今日岂可空去？”待其返，更定矣。老子睨余曰：“客尚在耶？客尚在何为者？”余曰：“周又老尝道闵先生精饮事，愿借余沥以解渴思。”文水喜，即自起当炉，茶旋煮，速如风雨。导至一室，幽窗净几，荆溪壶及成宣窑瓷瓯十余具，皆精绝。余问老子曰：“此茶何产？”老子曰：“阆苑茶也。”余再啜之，曰：“莫绐余，是阆苑制法而味不似。”老子昵笑曰：“客知是何产？”余再啜之，曰：“何其似罗嵑甚也？”老子吐舌曰：“奇！奇！”余问水曰：“何水？”老子曰：“惠水。”余又曰：“莫绐余，惠水至此千里，岂有水之圭角毫芒不动，生磊若是乎？”老子曰：“不复敢隐。舍间取水，必俟惠山人静夜分涸其井，淘洗数次，至黎明，涓流初满，载以大瓮，藉以文石。舟非风则勿行，水体不劳，水性不熟，故与他泉特异。”又吐舌曰：“奇奇！”言未毕，老子自去。少顷，一壶满斟余曰：“客啜此。”余曰：“香扑烈甚，味浑厚，此春茶也，向瀹者的是秋采。”老子大笑曰：“余年七十，精饮事五十余年，未尝见客之赏鉴若此之精也。五十年知己，无出客右，岂周又老谆谆向余道山阴有张宗老者，得非客乎？”余又大笑。遂相好如生平欢，饮啜无虚日。</p>
<p>​                                                ——茶史序</p>
<p>盖闻地有高人，品格与山川并重；亭遗古迹，梅花偕姓氏俱香。名流虽已代迁，胜事自须人补。在孤山逸老，高洁韵同秋水，孤清操比寒梅。疏影横斜，远映西湖清浅；暗香浮动，长陪夜月黄昏。今乃人去山空，依然水流花放。瑶葩洒雪，乱点冢上苔痕；玉树迷烟，恍堕林间鹤羽。兹来韵友，欲步先贤，补种千梅，重开孤屿。凌寒三友，蚤结九里松篁；破腊一枝，远谢六桥桃柳。[插图]想水边半树，点缀冰花；待披雪后横枝，低昂铁干。美人来自林下，高士卧于山中。白石苍厓，拟筑草亭招素鹤；浓山淡水，闲锄明月种梅花。有志竟成，无约不践。将与罗浮争艳，还期庾岭分香。实为林处士之功臣，亦是苏东坡之胜友。吾辈常劳梦想，应有宿缘。哦《曲江诗》，便见孤芳风韵；读《广平赋》，尚思铁石心肠。共策灞水之驴，且向段桥踏雪；遥期漆园之蝶，群来林墓寻梅。莫负佳期，用追芳躅。</p>
<p>​                                          ——补孤山种梅序</p>
<p>昔有一僧人与一士子同宿夜航船，士子高谈阔论，僧畏慑，卷足而寝。僧听其语有破绽，乃曰：“请问相公，澹台灭明是一个人，是两个人？”士子曰：“是两个人。”僧曰：“这等，尧舜是一个人两个人？”士子曰：“自然是一个人。”僧人乃笑曰：“这等说起来，且待小僧伸伸脚。</p>
<p>​                                             ——夜航船序</p>
<p>余生不辰，阔别西湖二十八载。然西湖无日不入吾梦中，而梦中之西湖实未尝一日别余也。前甲午、丁酉，两至西湖，如涌金门、商氏之楼外楼、祁氏之偶居、钱氏余氏之别墅，及余家之寄园一带湖庄，仅存瓦砾。则是余梦中所有者，反为西湖所无。及至断桥一望，凡昔日之歌楼舞榭，弱柳夭桃，如洪水渰没，百不存一矣。余乃急急走避，谓余为西湖而来，今所见若此，反不若保吾梦中之西湖为得计也。因想余梦与李供奉异，供奉之梦天姥也，如神女名姝，梦所未见，其梦也幻。余之梦西湖也，如家园眷属，梦所故有，其梦也真。</p>
<p>今余僦居他氏，已二十二载，梦中犹在故居。旧役小傒，今已白头，梦中仍是总角。夙习未除，故态难脱。而今而后，余但向蝶庵岑寂，蘧榻纡徐，惟吾旧梦是保，一派西湖景色，犹端然未动也。儿曹诘问，偶为言之，总是梦中说梦，非魇即呓也。余犹山中人归自海上，盛称海错之美，乡人竞来共舐其眼。嗟嗟，金齑瑶柱，过舌即空，则舐眼亦何救其馋哉？第作《梦寻》七十二则，留之后世，以作西湖之影。</p>
<p>​                                             ——西湖梦寻序</p>
<p>幸生胜地，鞋靸间饶有山川，喜作闲人，酒席间只谈风月。野航恰受，不逾两三；便榼随行，各携一二。僧上凫下，觞止茗生。谈笑杂以诙谐，陶写赖此丝竹。兴来即出，可趁樵风：日暮辄归，不因剡雪。愿邀同志，用续前游。</p>
<p>​                                            ——游山小启</p>
<p>会稽佳山水，甲于天下，而霞蔚云蒸，尤聚于山阴道上。故随足所至，皆胜地名山。王右军卜居兹土，于千岩万壑中，独取兰亭一席地。其景物风华，定当妙绝千古。且余少时见兰亭墨刻，岩峦奇峭，亭榭巍峨，曲水流觞，浴鹅涤砚。开卷视之，不禁神往。</p>
<p>​                                             ——古兰亭辩</p>
<p>蜀人张岱，陶庵其号也。少为纨绔子弟，极爱繁华，好精舍，好美婢，好娈童，好鲜衣，好美食，好骏马，好华灯，好烟火，好梨园，好鼓吹，好古董，好花鸟，兼以茶淫橘虐，书蠹诗魔。劳碌半生，皆成梦幻。年至五十，国破家亡，避迹山居，所存者破床碎几，折鼎病琴，与残书数帙，缺砚一方而已。布衣蔬食，常至断炊。回首二十年前，真如隔世。</p>
<p>初字宗子，人称石公，即字石公。好著书，其所成者有《石匮书》《张氏家谱》《义烈传》《琅嬛文集》《明易》《大易用》《史阙》《四书遇》《梦忆》《说铃》《昌谷解》《快园道古》《傒囊十集》《西湖梦寻》《一卷冰雪文》行世。</p>
<p>生于万历丁酉八月二十五日卯时，鲁国相大涤翁之树子也。母曰陶宜人。幼多痰疾，养于外大母马太夫人者十年。外太祖云谷公宦两广，藏生牛黄丸盈数簏，自余囡地以至十有六岁，食尽之而厥疾始瘳。六岁时，大父雨若翁携余之武林，遇眉公先生跨一角鹿，为钱唐游客，对大父曰：“闻文孙善属对，吾面试之”，指屏上李白骑鲸图曰：“太白骑鲸，采石江边捞夜月。”余应曰：“眉公跨鹿，钱唐县里打秋风。”眉公大笑起跃曰：“那得灵隽若此，吾小友也。”欲进余以千秋之业，岂料余之一事无成也哉？</p>
<p>甲申以后，悠悠忽忽，既不能觅死，又不能聊生，白发婆娑，犹视息人世。恐一旦溘先朝露，与草木同腐，因思古人如王无功、陶靖节、徐文长皆自作墓铭，余亦效颦为之。甫构思，觉人与文俱不佳，辍笔者再。虽然，第言吾之癖错，则亦可传也已。曾营生圹于项王里之鸡头山，友人李研斋题其圹曰：“呜呼，有明著述鸿儒陶庵张长公之圹。”伯鸾高士，冢近要离，余故有取于项里也。明年，年跻七十，死与葬，其日月尚不知也，故不书。</p>
<p>铭曰：穷石崇，斗金谷。盲卞和，献荆玉。老廉颇，战涿鹿。赝龙门，开史局。馋东坡，饿孤竹。五羖大夫，焉肯自鬻。空学陶潜，枉希梅福。必也寻三外野人，方晓我之衷曲。</p>
<p>​                                            ——自为墓志铭</p>
<p>昔日东坡思栗里，良穗怀新，写尽澄心纸。今见平畴如绿绮，翻来白浪潮头起。野老豚蹄心更侈，篝满瓯窭，奢愿还无已。处处军输如吸髓，敢云畎亩忘庚癸。</p>
<p>​                                               ——平畴麦浪</p>
<p>何必微萤量数斛，遇夜嬉游，囊火燃山谷。怎比渔灯千万簇，星星炤出田畴绿。疑是天河成反覆，遍野疏星，连住招摇宿。此际神槎乘博陆，支机石冷空杼柚。</p>
<p>​                                              ——孤村渔火</p>
<p>雪巘晴光如缺列，闪烁凝晴，入眼翻成瞥。一幅鹅绫无缁涅，条条水道如轨辙。山入秋湖皆小垤，滋蔓难图，迢递如瓜瓞。余到洛伽心胆裂，银狮蹴起潮头雪。</p>
<p>​                                              ——三山霁雪</p>
]]></content>
      <categories>
        <category>芳林拾记</category>
      </categories>
      <tags>
        <tag>古典文化品读</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/2020/04/21/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="反转链表"><a class="markdownIt-Anchor" href="#反转链表"></a> 反转链表</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>先将结点一个个存入栈，然后逐次弹栈取出。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reverse_LinkList</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseLinklist</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;  <span class="comment">//判断链表是否为空，非常重要。</span></span><br><span class="line">        Stack&lt;ListNode&gt; stack=<span class="keyword">new</span> Stack();         <span class="comment">//定义一个ListNode类型的栈</span></span><br><span class="line">        ListNode first=head;         <span class="comment">//定义一个初始化结点等于head</span></span><br><span class="line">        <span class="keyword">while</span>(first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(first);</span><br><span class="line">            first=first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=stack.pop();  <span class="comment">//定义头结点为第一个弹栈元素</span></span><br><span class="line">        first=head;          <span class="comment">//定义初始化结点等于此处的head</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            first.next=stack.pop();</span><br><span class="line">            first=first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        first.next=<span class="keyword">null</span>; <span class="comment">//弹栈完成，置next为空。</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">        head.next=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        head.next.next=<span class="keyword">new</span> ListNode(<span class="number">9</span>);</span><br><span class="line">        Reverse_LinkList reverse_linkList=<span class="keyword">new</span> Reverse_LinkList();</span><br><span class="line">        System.out.println(reverse_linkList.reverseLinklist(head).val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双指针迭代"><a class="markdownIt-Anchor" href="#双指针迭代"></a> 双指针迭代</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverselist</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">        ListNode cur=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp=cur.next;<span class="comment">//暂存当前结点的next</span></span><br><span class="line">            cur.next=pre;<span class="comment">//将当前结点的next指向pre</span></span><br><span class="line">            cur=temp;<span class="comment">//cur往后</span></span><br><span class="line">            pre=cur;<span class="comment">//pre往后</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;<span class="comment">//当cur为空跳出循环，pre正好指向末尾元素，且实现了指向反转。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列及旋转数组找最小值</title>
    <url>/2020/04/21/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%8F%8A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC/</url>
    <content><![CDATA[<h1 id="斐波那契数列及旋转数组找最小值"><a class="markdownIt-Anchor" href="#斐波那契数列及旋转数组找最小值"></a> 斐波那契数列及旋转数组找最小值</h1>
<h2 id="问题陈述一"><a class="markdownIt-Anchor" href="#问题陈述一"></a> 问题陈述一</h2>
<p>写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：</p>
<blockquote>
<p>F(0) = 0,   F(1) = 1<br />
F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br />
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
</blockquote>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态规划的思想</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i]=(dp[i-<span class="number">1</span>]+dp[i-<span class="number">2</span>])%<span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>((v[i<span class="number">-1</span>]+v[i<span class="number">-2</span>])%<span class="number">1000000007</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题陈述二"><a class="markdownIt-Anchor" href="#问题陈述二"></a> 问题陈述二</h2>
<blockquote>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。</p>
</blockquote>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>由旋转数组的特性我们可以其旋转部分与原始部分分别有序，考虑二分法。</p>
<h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayMinValue</span><span class="params">(<span class="keyword">int</span>[] number)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=number.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(i+j)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(number[mid]&lt;number[j])&#123;</span><br><span class="line">            j=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(number[mid]&gt;number[j])&#123;</span><br><span class="line">            i=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个排序的链表</title>
    <url>/2020/04/21/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="合并两个排序的链表"><a class="markdownIt-Anchor" href="#合并两个排序的链表"></a> 合并两个排序的链表</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<blockquote>
<p>示例1：</p>
<p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br />
输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4<br />
限制：0 &lt;= 链表长度 &lt;= 1000</p>
</blockquote>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<ul>
<li>
<p>先判断是否L1、L2为空。</p>
</li>
<li>
<p>比较L1，L2的值，小的加入新链表mergeLinklist。</p>
</li>
<li>
<p>当一方已经为空，是否另一方还有未比较的元素，然后直接加入mergeLinklist。</p>
</li>
</ul>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Merge_Two_Linklist</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLinklists</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1==<span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span>(l2==<span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode mergeLink_head=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode mergeNode=mergeLink_head;<span class="comment">//mergeNode在判断过程中会不断往下走，因此需要定义mergeLink_head指向初始结点。</span></span><br><span class="line">        <span class="keyword">while</span> (l1!=<span class="keyword">null</span>&amp;&amp;l2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val&lt;=l2.val)&#123;</span><br><span class="line">                mergeNode.next=l1;<span class="comment">//使用了l1，那么l1遍历到下一个位置。</span></span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                mergeNode.next=l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            mergeNode=mergeNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeNode.next=l1==<span class="keyword">null</span>?l2:l1;</span><br><span class="line">        <span class="keyword">return</span> mergeLink_head.next;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ListNode l1=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        l1.next=<span class="keyword">new</span> ListNode(<span class="number">6</span>);</span><br><span class="line">        l1.next.next=<span class="keyword">new</span> ListNode(<span class="number">9</span>);</span><br><span class="line">        ListNode l2=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        l2.next=<span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        l2.next.next=<span class="keyword">new</span> ListNode(<span class="number">8</span>);</span><br><span class="line">        Merge_Two_Linklist merge_two_linklist=<span class="keyword">new</span> Merge_Two_Linklist();</span><br><span class="line">        merge_two_linklist.mergeTwoLinklists(l1,l2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>树的子结构</title>
    <url>/2020/04/21/%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="树的子结构"><a class="markdownIt-Anchor" href="#树的子结构"></a> 树的子结构</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>
<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例如:</span><br><span class="line">给定的树 A:</span><br><span class="line"></span><br><span class="line">​        3</span><br><span class="line">​       / \</span><br><span class="line">​      4   5</span><br><span class="line">​     / \</span><br><span class="line">     1   2</span><br><span class="line">给定的树 B：</span><br><span class="line"></span><br><span class="line">  4 </span><br><span class="line"> /</span><br><span class="line">1</span><br><span class="line">返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。</span><br></pre></td></tr></table></figure>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<ul>
<li>判断A，B是否为空，</li>
<li>比较A，B的头结点是否相等，若不等，继续比较A的左子结点，右子结点是否与B相等。</li>
<li>使用dfs进行深度查找，如果B为空了，说明匹配成功；如果A为空或者A！=B，匹配失败；</li>
<li>继续深度遍历A和B的左右子结点。</li>
</ul>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubStructrue_Of_Tree</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubTree</span><span class="params">(TreeNode A,TreeNode B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//判断A，B是否为空，</span></span><br><span class="line">        <span class="keyword">return</span> dfs(A,B)||isSubTree(A.left,B)||isSubTree(A.right,B);<span class="comment">//比较A，B的头结点是否相等，若不等，继续比较A的左子结点，右子结点是否与B相等。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode A,TreeNode B)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(B==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;    <span class="comment">//先判断B是否为空，B空意味着匹配完成。</span></span><br><span class="line">        <span class="keyword">if</span>(A==<span class="keyword">null</span>||A.val!=B.val) <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">//若B不空，A为空或者A，B不等，匹配失败。</span></span><br><span class="line">        <span class="keyword">return</span> dfs(A.left,B.left)&amp;&amp;dfs(A.right,B.right);  <span class="comment">//A，B都不空，继续判断A，B的左结点和右结点。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TreeNode A=<span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">        A.left=<span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        A.right=<span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        A.right.right=<span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        TreeNode B=<span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">        B.right=<span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">        SubStructrue_Of_Tree subStructrue_of_tree=<span class="keyword">new</span> SubStructrue_Of_Tree();</span><br><span class="line">        System.out.println(subStructrue_of_tree.isSubTree(A,B));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>调整数组顺序使奇数位于偶数前面</title>
    <url>/2020/04/21/%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="调整数组顺序使奇数位于偶数前面"><a class="markdownIt-Anchor" href="#调整数组顺序使奇数位于偶数前面"></a> 调整数组顺序使奇数位于偶数前面</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>定义两个循环变量i，j，i从数组头开始遍历寻找偶数，j从数组尾开始遍历寻找奇数，然后交换。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Partition_OddAndDouble</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] exchange(<span class="keyword">int</span>[] nums)&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;(nums[i]&amp;<span class="number">1</span>)==<span class="number">1</span>) i++; <span class="comment">//如果为奇数，则继续i++，直到发现偶数。x&amp;1 位运算 等价于x%2取余运算,此处必须继续判断i&lt;j，否则要一直是偶数，就死循环了，i也不可控。</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;j&amp;&amp;nums[j]%<span class="number">2</span>==<span class="number">0</span>) j--; <span class="comment">//如果为偶数，则继续j--，直到发现奇数。</span></span><br><span class="line">            <span class="keyword">int</span> temp=nums[i];   <span class="comment">//交换</span></span><br><span class="line">            nums[i]=nums[j];</span><br><span class="line">            nums[j]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums=&#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        Partition_OddAndDouble partition_oddAndDouble=<span class="keyword">new</span> Partition_OddAndDouble();</span><br><span class="line">        partition_oddAndDouble.exchange(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            System.out.println(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中倒数第k个结点</title>
    <url>/2020/04/21/%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="链表中倒数第k个结点"><a class="markdownIt-Anchor" href="#链表中倒数第k个结点"></a> 链表中倒数第k个结点</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<h3 id="普遍想法"><a class="markdownIt-Anchor" href="#普遍想法"></a> 普遍想法</h3>
<p>首先获取链表的长度，然后将链表指到n-k位置即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head == <span class="keyword">null</span>)    <span class="keyword">return</span> <span class="keyword">null</span>;   <span class="comment">//判断链表是否为空</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次遍历，得到链表长度</span></span><br><span class="line">        ListNode first = head;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(first != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二次遍历，得到倒数第k个元素</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        ListNode second = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((length - k) == index)&#123;</span><br><span class="line">                <span class="keyword">return</span> second;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                index++;</span><br><span class="line">                second = second.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双指针解法"><a class="markdownIt-Anchor" href="#双指针解法"></a> 双指针解法</h3>
<p>定义两个指针former和latter，初始都指向head。然后让former先走k个位置，这样两个指针间距为k，然后两指针同步前进，直到former为空，返回latter，即对应倒数第K个结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**public class ListNode &#123;</span></span><br><span class="line"><span class="comment">      int val;</span></span><br><span class="line"><span class="comment">      ListNode next;</span></span><br><span class="line"><span class="comment">      ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment">  &#125;**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Get_from_Kth_to_end</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getKthToEnd</span><span class="params">(ListNode head , <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ListNode former=head;</span><br><span class="line">        ListNode latter=head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            former=former.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (former!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            former=former.next;</span><br><span class="line">            latter=latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ListNode head=<span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">        head.next=<span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">        head.next.next=<span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">        head.next.next.next=<span class="keyword">new</span> ListNode(<span class="number">7</span>);</span><br><span class="line">        Get_from_Kth_to_end get_from_kth_to_end=<span class="keyword">new</span> Get_from_Kth_to_end();</span><br><span class="line">        System.out.println(get_from_kth_to_end.getKthToEnd(head,<span class="number">3</span>).val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>心迹</title>
    <url>/2020/04/21/%E5%BF%83%E8%BF%B9/</url>
    <content><![CDATA[<p>然后他悄然离去了，从家乡临川坐上开往乌鲁木齐的火车，火车跨过长江，经黄石到襄阳。那日傍晚襄阳城下了很大的雨，雨水浸透了古寂的城郭，继而天色昏暝了起来。</p>
<p>后半夜里，到了西安，这座承载着汉唐文化的古都。火车驶进未央区进入西安站的时候遥遥看见灯火点点的古城墙，曾无数次想象自己身披鹤氅衣立在古城墙上看赭红色的落日。</p>
<p>没有留恋，夜色更深，天色乍白的时候看着窗外打鸣的晨鸡，已经越过了秦岭与渭河，进入绵延西北的甘肃，天水，兰州。靠近兰州的时候，听到对座的妇女说她要去银川，要先下车了。宁夏银川，一听到这个地名，恍然之间感觉自己前世是古西夏逃难出来的贵家王子，路上颠沛流离染了重病，所幸途经皋兰县北一户人家挽救了生命，后来，后来就不知道如何了？</p>
<p>火车开出兰州第一次看见滔滔黄河。沿河西走廊进入古甘州，纷纷然很大的雪落在了甘州城……<br />
逐渐靠近玉门关，似乎感受到了唐人“羌笛何须怨杨柳，春风不度玉门关”的惘然，亦有“黄沙百战穿金甲，不破楼兰终不还”的心惊。</p>
<p>玉门关外，有一座城，名敦煌，在历史的造就下有着无穷的神秘，我知道的。曾经我和敲壁画的匠人有过递夜的长谈。</p>
<p>进入塔克拉玛干沙漠，我弃了车，直接徒步进入大漠，我的水喝干了，在夜里倒在一片沙棘之中，过路的人用骆驼把我载回一个叫鄯善的小城，醒来后问我是哪里人？要去向何方？我说我来自东土，此行欲往天山。他用当地的食物款待我一番后让我走了。</p>
<p>越过天山，进入准噶尔盆地，一直到阿尔泰山脚下的边境城市阿勒泰……<br />
有那么一刻，简直要恸哭起来……<br />
万水千山走遍，故乡还有忘不掉的人吗？</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
      <tags>
        <tag>千山万水身</tag>
      </tags>
  </entry>
  <entry>
    <title>长夏旧忆1</title>
    <url>/2020/04/21/%E9%95%BF%E5%A4%8F%E6%97%A7%E5%BF%861/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200427121255.PNG" alt="八月" /></p>
<p>“我希望你平安”，和好友南山去看《八月》的时候，我们不约而同的打开手机拍下了故事中男主人公爬到树上的一幕。这使我想起我幼时也爬树，只是后来不再爬了，又岂知，在我成长的大半生里，与这一草一木朝夕相对惺惺相惜以至死生萦系。<br />
我对树有着一种莫名的喜欢，爱其春荣秋陨，爱其繁花硕果。后来又多了一种，我喜欢有年代的古树，必要是生满绿苔的，它一定是有长长的故事，我喜欢历史深处被尘埃掩埋的那些物件的故事。当然，这些都是后来才有的感受了。<br />
最初的感受是什么？只知道出生的所在四面有起伏连绵的山丘，近处是田野，是溪流，是竹篱村舍。夏日里一行白鹭从稻田里飞起继而绕着青山的景象我是多见的，山深又闻得那树树鹧鸪的清音。<br />
“你下来，快下来！“母亲略有愠怒的朝我喊着。我反倒得意起来，我竟赤脚爬到了这棵大枫树的梢头，怎又肯轻易就下去呢！微风轻轻的吹动树梢，我也跟着摇晃起来。我的身边簇拥着木荷和苦槠的叶子，因而望不着底下的样子，平行看去到了我家三楼的高度。此时枫叶未丹，尚是一派青绿，叶脉在阳光下清晰可见。我想起了课本中有一篇文章《枫叶如丹》，知道北京香山的红枫是比这更壮美的，嗯 以后长大了我要去看看。想着想着，一只鸟儿投向这枫树来，歇下脚发现我在之后马上飞了出去。<br />
诶，好像过了一段时间了，母亲为什么没有再来赶我下来。<br />
后来，我还没有去到香山，先听闻了落第失意人张继的&quot;江枫渔火对愁眠”，亡国李后主的&quot;相思枫叶丹”。</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
      <tags>
        <tag>故时</tag>
        <tag>夏天</tag>
      </tags>
  </entry>
  <entry>
    <title>长夏旧忆2</title>
    <url>/2020/04/21/%E9%95%BF%E5%A4%8F%E6%97%A7%E5%BF%862/</url>
    <content><![CDATA[<p>我喜欢夏季薄暮时分深蓝色的天空，蓝的那样深沉空灵，每每伏在课桌从窗外仰头看去，总是忍不住要惊叹起来。忍不住想起&quot;槐枝啼宿鸟，冷烟浓。小楼愁倚画阑东。黄昏月，一笛碧云风。&quot; 想起&quot;暝色上高楼，有人楼上愁。玉阶空伫立，宿鸟归飞急。何处是归程，长亭更短亭。&quot;的诗句来。<br />
而此刻窗外，我正好看见了两三只鸟儿飞进了泡桐树的树冠，然后天空中再没有鸟飞过的痕迹。晚读还没有开始，同桌喊我去外面走一下，呼吸一下新鲜空气。我欣然同意了。教学楼前面有几棵高大的雪松，有同学蹲在树底下捡蝉蜕，我好奇的凑过去，“哇！真像一只活的蝉。”&quot;是啊！但是只是它的躯壳，它的肉身已经上树了。&quot;同学回我道。诗词里说蝉是餐风饮露的，生物书上说蝉是会吮吸树干的养分的，而我独感动它这盛夏的长鸣，无关齐女的故事。<br />
国槐树隐约的开出了几束豆科植物的花儿，夏天依旧热烈，一如这花的开放与蝉的嘶鸣。<br />
偌大的校园里，就我们两个班在补习，电铃响了，我们回到教室去。我拿出那本珍藏的张晓风散文集来，看着天上的半轮月，我喜欢读《细细的潮音》:后庭的月光正在涨潮，满园的林木正淹没在发亮的波澜里，我惊讶的坐起，完全不能置信越来越浓的月光。一时不知道自己究竟是在快乐，还是忧愁，只觉得如小舟，悠然浮起，浮向似乎很近又似乎很远的青天，而微风里橄榄树细小的白花正飘着，落着，矮矮的通往后院的阶石在月光下被落花堆积得犹如玉砌一般。我忍不住欢喜起来，活着真是一种极大的幸福——这种晶莹的夜，这样透明的月光，这样温柔的、落着花的树。<br />
复而蝉声又起，而湛蓝的天空逐渐被暮色掩盖。我继而读起《遇》:蝉壳很快就盈握了，我把它放在地下，再去更高的枝头剥取。 小小的蝉壳里，怎么会容得下那长夏不歇的鸣声呢？那鸣声是渴望？是欲求？是无奈的独白？ 是我看蝉壳，看得风多露重，岁月忽已晚呢？还是蝉壳看我，看得花落人亡，地老天荒呢？</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
      <tags>
        <tag>故时</tag>
        <tag>夏天</tag>
      </tags>
  </entry>
  <entry>
    <title>长夏旧忆3</title>
    <url>/2020/04/21/%E9%95%BF%E5%A4%8F%E6%97%A7%E5%BF%863/</url>
    <content><![CDATA[<p><img src="https://gitee.com/Personal-Zoom/my-album/raw/master/photos/psb.webp" alt="" /></p>
<p>林深静谧，万物生长。席地枯叶中忽然飞起来一只枯叶蝶，高树上坠下一粒枯裂的树果传来一刹窸窣的声音。透过树林的罅隙，外头红的蓝的光影模糊起来，我悄悄的在里面，没有人注意到我，我在等风。</p>
<p>风起，万物摇曳，其声，其形，无涯以止，我随之奔跑，跑出了林子，直到脚下一条河流阻去前路，我就蹲坐在河边水草丰满的大石头上，水波在动，水鸟汲水。</p>
<p>此岸，彼岸，风未息，百草挥动。稻田里手持长竹杠赶花粉的人们停下了步子，愉悦的自语道: &quot;起风了。&quot;然后见他收拾好东西，在浅浅的水滩边洗去一脚的泥巴，离去了。我犹不舍，我喜欢这样的风声:<br />
风吹过大树的树叶；风吹过一片接一片的稻田；风吹过水面；风吹过大地……我实在想不出一个贴切的拟声词来，呼呼，哗啦啦，都不贴切的，这样长夏的南风，是饱含静气的，是热烈后的舒缓。</p>
<p>蝴蝶在风中凌乱的飞着，想靠在一根草尖上，可是风不许，于是蝴蝶也远去了。我不再追，就那样坐在那里，我隐藏在芒种日的稻浪里。我身后有一棵高大的皂荚树，树上有一个很大的鸟窝，方才一只黑色羽毛有白纹的大鸟飞了进去。粽叶从里发出了一丝异动，我把头低下去瞧了瞧，是一只白色的大兔子，被我发现之后，它马上就没有了身影。嗯，我就在这守着，说不定它就会晕倒在皂荚树下。禾谷马上就要成熟了，水田的水也干了，渐渐变的坚实。那里面真是一个大森林，森林里住着小精灵。我会变成一个小矮人，只有一粒沙子那么大，她会领我去她的国度。我就跟在她身后，走过一从从的禾谷，涉过一片片的荷叶，乘一枚叶子渡过小溪……忽然传来清悦的声音，是《清平乐》: &quot;别来春半，触目愁肠断，砌下落梅如雪乱……“又有&quot;难言处，良窗淡月……”，“小池寒渌欲生漪。”</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
      <tags>
        <tag>故时</tag>
        <tag>夏天</tag>
      </tags>
  </entry>
  <entry>
    <title>知荼词抄</title>
    <url>/2020/04/21/%E7%9F%A5%E8%8D%BC%E8%AF%8D%E6%8A%84/</url>
    <content><![CDATA[<h1 id="知荼词抄"><a class="markdownIt-Anchor" href="#知荼词抄"></a> 知荼词抄</h1>
<p>此卷系作者读书所录文字思想，于时光悠悠处，细看白鸟绕南山，小池澹澹碧。</p>
<h2 id="第一辑-漱玉词"><a class="markdownIt-Anchor" href="#第一辑-漱玉词"></a> 第一辑  漱玉词</h2>
<p>漱玉之名，源于李清照僦居济南处庭前漱玉泉，泉水清冽，至今汩汩。</p>
<h3 id="渔家傲-天接云涛连晓雾"><a class="markdownIt-Anchor" href="#渔家傲-天接云涛连晓雾"></a> 渔家傲  天接云涛连晓雾</h3>
<p>天接云涛连晓雾。星河欲转千帆舞。仿佛梦魂归帝所。闻天语。殷勤问我归何处。</p>
<p>我报路长嗟日暮。学诗谩有惊人句。九万里风鹏正举。风休住。蓬舟吹取三山去。</p>
<h3 id="渔家傲-雪里已知春信至"><a class="markdownIt-Anchor" href="#渔家傲-雪里已知春信至"></a> 渔家傲 雪里已知春信至</h3>
<p>雪里已知春信至。寒梅点缀琼枝腻。香脸半开娇旖旎。当庭际。玉人浴出新妆洗。</p>
<p>造化可能偏有意。故教明月玲珑地。共赏金尊沈绿蚁。莫辞醉。此花不与群花比。</p>
<h3 id="如梦令-常记溪亭日暮"><a class="markdownIt-Anchor" href="#如梦令-常记溪亭日暮"></a> 如梦令 常记溪亭日暮</h3>
<p>（一题作酒兴）</p>
<p>常记溪亭日暮，沉醉不知归路。兴尽晚回舟，误入藕花深处。争渡，争渡，惊起一滩鸥鹭。</p>
<h3 id="如梦令-昨夜雨疏风骤"><a class="markdownIt-Anchor" href="#如梦令-昨夜雨疏风骤"></a> 如梦令 昨夜雨疏风骤</h3>
<p>（一题作春晚）</p>
<p>昨夜雨疏风骤，浓睡不消残酒。试问卷帘人，却道海棠依旧。知否？知否？应是绿肥红瘦。</p>
<h3 id="如梦令-谁伴明窗独坐"><a class="markdownIt-Anchor" href="#如梦令-谁伴明窗独坐"></a> 如梦令  谁伴明窗独坐</h3>
<p>谁伴明窗独坐，我共影儿俩个。灯尽欲眠时，影也把人抛躲。无那，无那，好个凄凉的我。</p>
<h3 id="浣溪沙-绣面芙蓉一笑开"><a class="markdownIt-Anchor" href="#浣溪沙-绣面芙蓉一笑开"></a> 浣溪沙 绣面芙蓉一笑开</h3>
<p>绣面芙蓉一笑开。斜飞宝鸭衬香腮。眼波才动被人猜。</p>
<p>一面风情深有韵，半笺娇恨寄幽怀。月移花影约重来。</p>
<h3 id="浣溪沙-髻子伤春慵更梳"><a class="markdownIt-Anchor" href="#浣溪沙-髻子伤春慵更梳"></a> 浣溪沙 髻子伤春慵更梳</h3>
<p>髻子伤春慵更梳。晚风庭院落梅初。淡云来往月疏疏。</p>
<p>玉鸭熏炉闲瑞脑，朱樱斗帐掩流苏。通犀还解辟寒无。</p>
<h3 id="一剪梅-红藕香残玉簟秋"><a class="markdownIt-Anchor" href="#一剪梅-红藕香残玉簟秋"></a> 一剪梅 红藕香残玉簟秋</h3>
<p>红藕香残玉簟秋。轻解罗裳，独上兰舟。云中谁寄锦书来，雁字回时，月满西楼。<br />
花自飘零水自流。一种相思，两处闲愁。此情无计可消除，才下眉头，却上心头。</p>
<h3 id="蝶恋花-泪湿罗衣脂粉满"><a class="markdownIt-Anchor" href="#蝶恋花-泪湿罗衣脂粉满"></a> 蝶恋花  泪湿罗衣脂粉满</h3>
<p>泪湿罗衣脂粉满，四叠阳关，唱到千千遍。人道山长山又断，萧萧微雨闻孤馆。<br />
惜别伤离方寸乱，忘了临行，酒盏深和浅。好把音书凭过雁，东莱不似蓬莱远。</p>
<h3 id="鹧鸪天-暗淡轻黄体性柔"><a class="markdownIt-Anchor" href="#鹧鸪天-暗淡轻黄体性柔"></a> 鹧鸪天  暗淡轻黄体性柔</h3>
<p>暗淡轻黄体性柔，情疏迹远只香留。 何须浅碧轻红色，自是花中第一流。</p>
<p>梅定妒，菊应羞，画栏开处冠中秋。 骚人可煞无情思，何事当年不见收。</p>
<h3 id="临江仙-庭院深深深几许"><a class="markdownIt-Anchor" href="#临江仙-庭院深深深几许"></a> 临江仙 庭院深深深几许</h3>
<p>欧阳公作《蝶恋花》，有“深深深几许”之句，予酷爱之。用其语作“庭院深深”数阕，其声即旧《临江仙》也。</p>
<p>庭院深深深几许？云窗雾阁常扃。柳梢梅萼渐分明。春归秣陵树，人老建康城。<br />
感月吟风多少事，如今老去无成。谁怜憔悴更凋零。试灯无意思，踏雪没心情。</p>
<h3 id="醉花阴-薄雾浓云愁永昼"><a class="markdownIt-Anchor" href="#醉花阴-薄雾浓云愁永昼"></a> 醉花阴 薄雾浓云愁永昼</h3>
<p>薄雾浓云愁永昼，瑞脑消金兽。佳节又重阳，玉枕纱橱，半夜凉初透。</p>
<p>东篱把酒黄昏后，有暗香盈袖。莫道不销魂，帘卷西风，人比黄花瘦。</p>
<h3 id="武陵春-风住尘香花已尽"><a class="markdownIt-Anchor" href="#武陵春-风住尘香花已尽"></a> 武陵春  风住尘香花已尽</h3>
<p>风住尘香花已尽，日晚倦梳头。物是人非事事休，欲语泪先流。</p>
<p>闻说双溪春尚好，也拟泛轻舟，只恐双溪舴艋舟，载不动许多愁。</p>
<h3 id="声声慢-寻寻觅觅"><a class="markdownIt-Anchor" href="#声声慢-寻寻觅觅"></a> 声声慢  寻寻觅觅</h3>
<p>寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急？雁过也，正伤心，却是旧时相识。</p>
<p>满地黄花堆积。憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑？梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！</p>
<h3 id="清平乐-年年雪里"><a class="markdownIt-Anchor" href="#清平乐-年年雪里"></a> 清平乐  年年雪里</h3>
<p>年年雪里。常插梅花醉。挼尽梅花无好意。赢得满衣清泪。</p>
<p>今年海角天涯。萧萧两鬓生华。看取晚来风势，故应难看梅花。</p>
<h3 id="点绛唇-蹴罢秋千"><a class="markdownIt-Anchor" href="#点绛唇-蹴罢秋千"></a> 点绛唇  蹴罢秋千</h3>
<p>蹴罢秋千，起来慵整纤纤手。露浓花瘦，薄汗轻衣透。</p>
<p>见客入来，袜刬金钗溜。和羞走，倚门回首，却把青梅嗅。</p>
<h3 id="点绛唇-寂寞深闺"><a class="markdownIt-Anchor" href="#点绛唇-寂寞深闺"></a> 点绛唇  寂寞深闺</h3>
<p>寂寞深闺，柔肠一寸愁千缕。惜春春去。几点催花雨。</p>
<p>倚遍阑干，只是无情绪。人何处。连天衰草，望断归来路。</p>
<h3 id="满庭芳-小阁藏春"><a class="markdownIt-Anchor" href="#满庭芳-小阁藏春"></a> 满庭芳  小阁藏春</h3>
<p>小阁藏春，闲窗锁昼，画堂无限深幽。篆香烧尽，日影下帘钩。手种江梅渐好，又何必、临水登楼。无人到，寂寥浑似，何逊在扬州。</p>
<p>从来，知韵胜，难堪雨藉，不耐风揉。更谁家横笛，吹动浓愁。莫恨香消雪减，须信道、扫迹情留。难言处，良宵淡月，疏影尚风流。</p>
<h3 id="御街行-藤床纸帐朝眠起"><a class="markdownIt-Anchor" href="#御街行-藤床纸帐朝眠起"></a> 御街行  藤床纸帐朝眠起</h3>
<p>藤床纸帐朝眠起。说不尽、无佳思。沈香断续玉炉寒，伴我情怀如水。笛里三弄，梅心惊破，多少春情意。</p>
<p>小风疏雨萧萧地。又催下、千行泪。吹箫人去玉楼空，肠断与谁同倚。一枝折得，人间天上，没个人堪寄。</p>
<h3 id="玉楼春-红酥肯放琼苞碎"><a class="markdownIt-Anchor" href="#玉楼春-红酥肯放琼苞碎"></a> 玉楼春  红酥肯放琼苞碎</h3>
<p>红酥肯放琼苞碎，探著南枝开遍未。不知酝藉几多香，但见包藏无限意。</p>
<p>道人憔悴春窗底，闷损阑干愁不倚。要来小酌便来休，未必明朝风不起。</p>
<h3 id="永遇乐-落日熔金"><a class="markdownIt-Anchor" href="#永遇乐-落日熔金"></a> 永遇乐 落日熔金</h3>
<p>落日熔金，暮云合壁，人在何处。染柳烟浓，吹梅笛怨，春意知几许。元宵佳节，融和天气，次第岂无风雨。来相召、香车宝马，谢他酒朋诗侣。</p>
<p>中州盛日，闺门多暇，记得偏重三五。铺翠冠儿，捻金雪柳，簇带争济楚。如今憔悴，风鬟霜鬓，怕见夜间出去。不如向、帘儿底下，听人笑语。</p>
<h3 id="青玉案-一年春事都来几"><a class="markdownIt-Anchor" href="#青玉案-一年春事都来几"></a> 青玉案  一年春事都来几</h3>
<p>一年春事都来几。早过了、三之二。绿暗红嫣浑可事。绿杨庭院，暖风帘幕，有个人憔悴。</p>
<p>买花载酒长安市。又争似家山见桃李。不枉东风吹客泪，相思难表，梦魂无据，惟有归来是。</p>
<h3 id="添字丑奴儿-窗前谁种芭蕉树"><a class="markdownIt-Anchor" href="#添字丑奴儿-窗前谁种芭蕉树"></a> 添字丑奴儿 窗前谁种芭蕉树</h3>
<p>窗前谁种芭蕉树，阴满中庭。阴满中庭。叶叶心心，舒卷有馀清。</p>
<p>伤心枕上三更雨，点滴霖霪。点滴霖霪。愁损北人，不惯起来听。</p>
<h3 id="摊破浣溪沙-病起萧萧两鬓华"><a class="markdownIt-Anchor" href="#摊破浣溪沙-病起萧萧两鬓华"></a> 摊破浣溪沙  病起萧萧两鬓华</h3>
<p>病起萧萧两鬓华。卧看残月上窗纱。豆蔻连梢煎熟水，莫分茶。</p>
<p>枕上诗书闲处好，门前风景雨来佳。终日向人多藉藉，木犀花。</p>
<h3 id="摊破浣溪沙-揉破黄金万点轻"><a class="markdownIt-Anchor" href="#摊破浣溪沙-揉破黄金万点轻"></a> 摊破浣溪沙  揉破黄金万点轻</h3>
<p>揉破黄金万点轻，剪成碧玉叶层层。风度精神如彦辅，太鲜明。</p>
<p>梅蕊重重何俗甚，丁香千结苦粗生。熏透愁人千里梦，却无情。</p>
<h2 id="第二辑-小山词"><a class="markdownIt-Anchor" href="#第二辑-小山词"></a> 第二辑  小山词</h2>
<p>黄庭坚曰：淮海、小山，真古之伤心人也。余读其词，深情娟丽，真谓痴也。</p>
<h3 id="临江仙-梦后楼台高锁"><a class="markdownIt-Anchor" href="#临江仙-梦后楼台高锁"></a> 临江仙  梦后楼台高锁</h3>
<p>梦后楼台高锁，酒醒帘幕低垂。去年春恨却来时。落花人独立，微雨燕双飞。</p>
<p>记得小苹初见，两重心字罗衣。琵琶弦上说相思。当时明月在，曾照彩云归。</p>
<h3 id="鹧鸪天-彩袖殷勤捧玉钟"><a class="markdownIt-Anchor" href="#鹧鸪天-彩袖殷勤捧玉钟"></a> 鹧鸪天  彩袖殷勤捧玉钟</h3>
<p>彩袖殷勤捧玉钟。当年拚却醉颜红。舞低杨柳楼心月，歌尽桃花扇影风。</p>
<p>从别后，忆相逢。几回魂梦与君同。今宵剩把银红照，犹恐相逢是梦中。</p>
<h3 id="生查子-关山魂梦长"><a class="markdownIt-Anchor" href="#生查子-关山魂梦长"></a> 生查子 关山魂梦长</h3>
<p>关山魂梦长，鱼雁音尘少。两鬓可怜青，只为相思老。</p>
<p>归梦碧纱窗，说与人人道。真个别离难，不似相逢好。</p>
<h3 id="清平乐-留人不住"><a class="markdownIt-Anchor" href="#清平乐-留人不住"></a> 清平乐 留人不住</h3>
<p>留人不住。醉解兰舟去。一棹碧涛春水路。过尽晓莺啼处。</p>
<p>渡头杨柳青青。枝枝叶叶离情。此后锦书休寄，画楼云雨无凭。</p>
<h3 id="木兰花-初心已恨花期远"><a class="markdownIt-Anchor" href="#木兰花-初心已恨花期远"></a> 木兰花 初心已恨花期远</h3>
<p>初心已恨花期晚。别后相思长在眼。兰衾犹有旧时香，每到梦回珠泪满。</p>
<p>多应不信人肠断。几夜夜寒谁共暖。欲将恩爱结来生，只恐来生缘又短。</p>
<h3 id="思远人-红叶黄花秋意晚"><a class="markdownIt-Anchor" href="#思远人-红叶黄花秋意晚"></a> 思远人 红叶黄花秋意晚</h3>
<p>红叶黄花秋意晚，千里念行客。飞云过尽，归鸿无信，何处寄书得。</p>
<p>泪弹不尽临窗滴。就砚旋研墨。渐写到别来，此情深处，红笺为无色。</p>
<h3 id="长相思-长相思"><a class="markdownIt-Anchor" href="#长相思-长相思"></a> 长相思 长相思</h3>
<p>长相思。长相思。若问相思甚了期。除非相见时。</p>
<p>长相思。长相思。欲把相思说似谁。浅情人不知。</p>
<h2 id="第三辑-范仲淹词笔"><a class="markdownIt-Anchor" href="#第三辑-范仲淹词笔"></a> 第三辑  范仲淹词笔</h2>
<h3 id="苏幕遮-怀旧"><a class="markdownIt-Anchor" href="#苏幕遮-怀旧"></a> 苏幕遮  怀旧</h3>
<p>碧云天，黄叶地，秋色连波，波上寒烟翠。山映斜阳天接水，芳草无情，更在斜阳外。</p>
<p>黯乡魂，追旅思，夜夜除非，好梦留人睡。明月楼高休独倚，酒入愁肠，化作相思泪。</p>
<h3 id="渔家傲-秋思"><a class="markdownIt-Anchor" href="#渔家傲-秋思"></a> 渔家傲 秋思</h3>
<p>塞下秋来风景异，衡阳雁去无留意。四面边声连角起。千嶂里，长烟落日孤城闭。</p>
<p>浊酒一杯家万里，燕然未勒归无计。羌管悠悠霜满地。人不寐，将军白发征夫泪。</p>
<h3 id="御街行-秋日怀旧"><a class="markdownIt-Anchor" href="#御街行-秋日怀旧"></a> 御街行 秋日怀旧</h3>
<p>纷纷坠叶飘香砌，夜寂静，寒声碎。真珠帘卷玉楼空，天淡银河垂地。年年今夜，月华如练，长是人千里。</p>
<p>愁肠已断<a href="https://baike.so.com/doc/4299333-4503026.html">无由</a>醉，酒未到，先成泪。残灯明灭枕头敧，谙尽孤眠滋味。都来此事，眉间心上，无计相回避。</p>
<h2 id="第四辑-欧阳修词笔"><a class="markdownIt-Anchor" href="#第四辑-欧阳修词笔"></a> 第四辑  欧阳修词笔</h2>
<h3 id="踏莎行-候馆梅残"><a class="markdownIt-Anchor" href="#踏莎行-候馆梅残"></a> 踏莎行 候馆梅残</h3>
<p>候馆梅残，溪桥柳细。草薰风暖摇征辔。离愁渐远渐无穷，迢迢不断如春水。</p>
<p>寸寸柔肠，盈盈粉泪。楼高莫近危阑倚。平芜尽处是春山，行人更在春山外。</p>
<h3 id="玉楼春-尊前拟把归期说"><a class="markdownIt-Anchor" href="#玉楼春-尊前拟把归期说"></a> 玉楼春 尊前拟把归期说</h3>
<p>尊前拟把归期说。未语春容先惨咽。人生自是有情痴，此恨不关风与月。</p>
<p>离歌且莫翻新阕。一曲能教肠寸结。直须看尽洛城花，始共春风容易别。</p>
<h3 id="玉楼春-别后不知君远近"><a class="markdownIt-Anchor" href="#玉楼春-别后不知君远近"></a> 玉楼春 别后不知君远近</h3>
<p>别后不知君远近。触目凄凉多少闷。渐行渐远渐无书，水阔鱼沈何处问。</p>
<p>夜深风竹敲秋韵。万叶千声皆是恨。故欹单枕梦中寻，梦又不成灯又烬。</p>
<h3 id="南歌子-凤髻金泥带"><a class="markdownIt-Anchor" href="#南歌子-凤髻金泥带"></a> 南歌子 凤髻金泥带</h3>
<p>凤髻金泥带，龙纹玉掌梳。走来窗下笑相扶。爱道画眉深浅入时无。</p>
<p>弄笔偎人久，描花试手初。等闲妨了绣功夫。笑问鸳鸯二字怎生书。</p>
<h3 id="临江仙-记得金銮同唱第"><a class="markdownIt-Anchor" href="#临江仙-记得金銮同唱第"></a> 临江仙 记得金銮同唱第</h3>
<p>记得金銮同唱第，春风上国繁华。如今薄宦老天涯。十年岐路，空负曲江花。</p>
<p>闻说阆山通阆苑，楼高不见君家。孤城寒日等闲斜。离愁难尽，红树远连霞。</p>
<h3 id="浪淘沙-把酒祝东风"><a class="markdownIt-Anchor" href="#浪淘沙-把酒祝东风"></a> 浪淘沙 把酒祝东风</h3>
<p>把酒祝东风。且共从容。垂杨紫陌洛城东。总是当时携手处，游遍芳丛。</p>
<p>聚散苦匆匆。此恨无穷。今年花胜去年红。可惜明年花更好，知与谁同。</p>
<h3 id="浣溪沙-堤上游人逐画船"><a class="markdownIt-Anchor" href="#浣溪沙-堤上游人逐画船"></a> 浣溪沙 堤上游人逐画船</h3>
<p>堤上游人逐画船。拍堤春水四垂天。绿杨楼外出秋千。</p>
<p>白发戴花君莫笑，六么催拍盏频传。人生何处似尊前。</p>
<h2 id="第五辑-姜白石词曲"><a class="markdownIt-Anchor" href="#第五辑-姜白石词曲"></a> 第五辑  姜白石词曲</h2>
<h3 id="扬州慢-淮左名都"><a class="markdownIt-Anchor" href="#扬州慢-淮左名都"></a> 扬州慢 淮左名都</h3>
<p>淳熙丙申至日，予过维扬。夜雪初霁，荠麦弥望。入其城，则四顾萧条，寒水自碧，暮色渐起，戍角悲吟。予怀怆然，感慨今昔，因自度此曲。千岩老人以为有“黍离”之悲也。</p>
<p>淮左名都，竹西佳处，解鞍少驻初程。过春风十里，尽荠麦青青。自胡马窥江去后，废池乔木，犹厌言兵。渐黄昏，清角吹寒，都在空城。</p>
<p>杜郎俊赏，算而今、重到须惊。纵豆蔻词工，青楼梦好，难赋深情。二十四桥仍在，波心荡、冷月无声。念桥边红药，年年知为谁生？</p>
<h3 id="点绛唇-丁未冬过吴松作"><a class="markdownIt-Anchor" href="#点绛唇-丁未冬过吴松作"></a> 点绛唇  丁未冬过吴松作</h3>
<p>燕雁无心，太湖西畔随云去。数峰清苦。商略黄昏雨。</p>
<p>第四桥边，拟共天随住。今何许。凭阑怀古。残柳参差舞。</p>
<h3 id="暗香-旧时月色"><a class="markdownIt-Anchor" href="#暗香-旧时月色"></a> 暗香  旧时月色</h3>
<p>辛亥之冬，余载雪诣石湖。止既月，授简索句，且征新声，作此两曲，石湖把玩不已，使二妓肆习之，音节谐婉，乃名之曰《暗香》、《疏影》。</p>
<p>旧时月色，算几番照我，梅边吹笛？唤起玉人，不管清寒与攀摘。何逊而今渐老，都忘却春风词笔。但怪得竹外疏花，香冷入瑶席。</p>
<p>江国，正寂寂，叹寄与路遥，夜雪初积。翠尊易泣，红萼无言耿相忆。长记曾携手处，千树压、西湖寒碧。又片片、吹尽也，几时见得？</p>
<h3 id="鹧鸪天-元夕有所梦"><a class="markdownIt-Anchor" href="#鹧鸪天-元夕有所梦"></a> 鹧鸪天  元夕有所梦</h3>
<p>肥水东流无尽期。当初不合种相思。梦中未比丹青见，暗里忽惊山鸟啼。</p>
<p>春未绿，鬓先丝。人间别久不成悲。谁教岁岁红莲夜，两处沉吟各自知。</p>
<h3 id="疏影-苔枝缀玉"><a class="markdownIt-Anchor" href="#疏影-苔枝缀玉"></a> 疏影  苔枝缀玉</h3>
<p>辛亥之冬，余载雪诣石湖。止既月，授简索句，且征新声，作此两曲，石湖把玩不已，使二妓肆习之，音节谐婉，乃名之曰《暗香》、《疏影》。</p>
<p>苔枝缀玉，有翠禽小小，枝上同宿。客里相逢，篱角黄昏，无言自倚修竹。昭君不惯胡沙远，但暗忆、江南江北。想佩环、月夜归来，化作此花幽独。</p>
<p>犹记深宫旧事，那人正睡里，飞近蛾绿。莫似春风，不管盈盈，早与安排金屋。还教一片随波去，又却怨、玉龙哀曲。等恁时、重觅幽香，已入小窗横幅</p>
<h3 id="鹧鸪天-正月十一日观灯"><a class="markdownIt-Anchor" href="#鹧鸪天-正月十一日观灯"></a> 鹧鸪天  正月十一日观灯</h3>
<p>巷陌风光纵赏时。笼纱未出马先嘶。白头居士无呵殿，只有乘肩小女随。</p>
<p>花满市，月侵衣。少年情事老来悲。沙河塘上春寒浅，看了游人缓缓归</p>
<h3 id="齐天乐-蟋蟀"><a class="markdownIt-Anchor" href="#齐天乐-蟋蟀"></a> 齐天乐  蟋蟀</h3>
<p>丙辰岁，与张功父会饮张达可之堂。闻屋壁间蟋蟀有声，功父约予同赋，以授歌者。功父先成，辞甚美。予裴回末利花间，仰见秋月，顿起幽思，寻亦得此。蟋蟀，中都呼为促织，善斗。好事者或以三二十万钱致一枚，镂象齿为楼观以贮之。</p>
<p>庾郎先自吟愁赋，凄凄更闻私语。露湿铜铺，苔侵石井，都是曾听伊处。哀音似诉。正思妇无眠，起寻机杼。曲曲屏山，夜凉独自甚情绪？</p>
<p>西窗又吹暗雨。为谁频断续，相和砧杵？候馆迎秋，离宫吊月，别有伤心无数。豳诗漫与。笑篱落呼灯，世间儿女。写入琴丝，一声声更苦。</p>
<h3 id="长亭怨慢-渐吹尽"><a class="markdownIt-Anchor" href="#长亭怨慢-渐吹尽"></a> 长亭怨慢  渐吹尽</h3>
<p>余颇喜自制曲。初率意为长短句，然后协以律，故前后阕多不同。桓大司马云：“昔年种柳，依依汉南。今看摇落，凄怆江潭：树犹如此，人何以堪？”此语余深爱之。</p>
<p>渐吹尽，枝头香絮，是处人家，绿深门户。远浦萦回，暮帆零乱向何许？阅人多矣，谁得似长亭树？树若有情时，不会得青青如此！</p>
<p>日暮，望高城不见，只见乱山无数。韦郎去也，怎忘得、玉环分付：第一是早早归来，怕红萼无人为主。算空有并刀，难剪离愁千缕。</p>
<h3 id="淡黄柳-空城晓角"><a class="markdownIt-Anchor" href="#淡黄柳-空城晓角"></a> 淡黄柳  空城晓角</h3>
<p>客居合肥南城赤阑桥之西，巷陌凄凉，与江左异。唯柳色夹道，依依可怜。因度此阕，以纾客怀。</p>
<p>空城晓角，吹入垂杨陌。马上单衣寒恻恻。看尽鹅黄嫩绿，都是江南旧相识。</p>
<p>正岑寂，明朝又寒食。强携酒、小桥宅。怕梨花落尽成秋色。燕燕飞来，问春何在？唯有池塘自碧。</p>
<h3 id="江梅引-人间离别易多时"><a class="markdownIt-Anchor" href="#江梅引-人间离别易多时"></a> 江梅引  人间离别易多时</h3>
<p>丙辰之冬，予留梁溪，将诣淮南不得，因梦思以述志。</p>
<p>人间离别易多时。见梅枝，忽相思。几度小窗幽梦手同携。今夜梦中无觅处，漫徘徊，寒侵被，尚未知。</p>
<p>湿红恨墨浅封题。宝筝空，无雁飞。俊游巷陌，算空有、古木斜晖。旧约扁舟，心事已成非。歌罢淮南春草赋，又萋萋。漂零客，泪满衣。</p>
<h2 id="第六辑-淮海集"><a class="markdownIt-Anchor" href="#第六辑-淮海集"></a> 第六辑  淮海集</h2>
<p>淮海集系秦观所作，秦观，北宋时人，字太虚、海若。江苏高邮人。</p>
<h3 id="鹊桥仙-纤云弄巧"><a class="markdownIt-Anchor" href="#鹊桥仙-纤云弄巧"></a> 鹊桥仙 纤云弄巧</h3>
<p>纤云弄巧，飞星传恨，银汉迢迢暗度。金风玉露一相逢，便胜却人间无数。</p>
<p>柔情似水，佳期如梦，忍顾鹊桥归路。两情若是久长时，又岂在朝朝暮暮。</p>
<h3 id="浣溪沙-漠漠轻寒上小楼"><a class="markdownIt-Anchor" href="#浣溪沙-漠漠轻寒上小楼"></a> 浣溪沙  漠漠轻寒上小楼</h3>
<p>漠漠轻寒上小楼。晓阴无赖似穷秋。淡烟流水画屏幽。</p>
<p>自在飞花轻似梦，无边丝雨细如愁。宝帘闲挂小银钩。</p>
<h3 id="满庭芳-山抹微云"><a class="markdownIt-Anchor" href="#满庭芳-山抹微云"></a> 满庭芳  山抹微云</h3>
<p>山抹微云，天连衰草，画角声断谯门。暂停征棹，聊共引离尊。多少蓬莱旧事，空回首、烟霭纷纷。斜阳外，寒鸦万点，流水绕孤村。</p>
<p>销魂。当此际，香囊暗解，罗带轻分。谩赢得、青楼薄幸名存。此去何时见也，襟袖上、空惹啼痕。伤情处，高城望断，灯火已黄昏。</p>
<h3 id="踏莎行-雾失楼台"><a class="markdownIt-Anchor" href="#踏莎行-雾失楼台"></a> 踏莎行  雾失楼台</h3>
<p>雾失楼台，月迷津渡，桃源望断无寻处。可堪孤馆闭春寒，杜鹃声里斜阳暮。</p>
<p>驿寄梅花，鱼传尺素，砌成此恨无重数。郴江幸自绕郴山，为谁流下潇湘去？</p>
<h3 id="江城子-西城杨柳弄春柔"><a class="markdownIt-Anchor" href="#江城子-西城杨柳弄春柔"></a> 江城子  西城杨柳弄春柔</h3>
<p>西城杨柳弄春柔。动离忧。泪难收。犹记多情，曾为系归舟。碧野朱桥当日事，人不见，水空流。</p>
<p>韶华不为少年留。恨悠悠。几时休。飞絮落花时候、一登楼。便做春江都是泪，流不尽，许多愁。</p>
<h3 id="行香子-树绕村庄"><a class="markdownIt-Anchor" href="#行香子-树绕村庄"></a> 行香子  树绕村庄</h3>
<p>树绕村庄，水满陂塘。倚东风、豪兴徜徉。小园几许，收尽春光。有桃花红，李花白，菜花黄。</p>
<p>远远围墙，隐隐茅堂。飏青旗、流水桥旁。偶然乘兴、步过东冈。正莺儿啼，燕儿舞，蝶儿忙</p>
<h3 id="八六子-倚危亭"><a class="markdownIt-Anchor" href="#八六子-倚危亭"></a> 八六子  倚危亭</h3>
<p>倚危亭。恨如芳草，萋萋刬尽还生。念柳外青骢别后，水边红袂分时，怆然暗惊。</p>
<p>无端天与娉婷。夜月一帘幽梦，春风十里柔情。</p>
<p>怎奈向、欢娱渐随流水，素弦声断，翠绡香减，那堪片片飞花弄晚，蒙蒙残雨笼晴。正销凝。黄鹂又啼数声</p>
<h3 id="望海潮-梅英疏淡"><a class="markdownIt-Anchor" href="#望海潮-梅英疏淡"></a> 望海潮  梅英疏淡</h3>
<p>梅英疏淡，冰澌溶泄，东风暗换年华。金谷俊游，铜驼巷陌，新晴细履平沙。长记误随车。正絮翻蝶舞，芳思交加。柳下桃蹊，乱分春色到人家。</p>
<p>西园夜饮鸣笳。有华灯碍月，飞盖妨花。兰苑未空，行人渐老，重来是事堪嗟。烟暝酒旗斜。但倚楼极目，时见栖鸦。无奈归心，暗随流水到天涯。</p>
<h3 id="南乡子-妙手写徽真"><a class="markdownIt-Anchor" href="#南乡子-妙手写徽真"></a> 南乡子  妙手写徽真</h3>
<p>妙手写徽真，水剪双眸点绛唇。疑是昔年窥宋玉，东邻，只露墙头一半身。</p>
<p>往事已酸辛，谁记当年翠黛颦？尽道有些堪恨处，无情，任是无情也动人。</p>
<h3 id="临江仙-千里潇湘挼蓝浦"><a class="markdownIt-Anchor" href="#临江仙-千里潇湘挼蓝浦"></a> 临江仙  千里潇湘挼蓝浦</h3>
<p>千里潇湘挼蓝浦，兰桡昔日曾经。月高风定露华清。微波澄不动，冷浸一天星。</p>
<p>独倚危樯情悄悄，遥闻妃瑟泠泠。新声含尽古今情。曲终人不见，江上数峰青。</p>
<h3 id="江城子-南来飞燕北归鸿"><a class="markdownIt-Anchor" href="#江城子-南来飞燕北归鸿"></a> 江城子  南来飞燕北归鸿</h3>
<p>南来飞燕北归鸿，偶相逢，惨愁容。绿鬓朱颜重见两衰翁。别后悠悠君莫问，无限事，不言中。</p>
<p>小槽春酒滴珠红，莫匆匆，满金钟。饮散落花流水各西东。后会不知何处是？烟浪远，暮云重。</p>
<h3 id="阮郎归-春风吹雨绕残枝"><a class="markdownIt-Anchor" href="#阮郎归-春风吹雨绕残枝"></a> 阮郎归  春风吹雨绕残枝</h3>
<p>春风吹雨绕残枝，落花无可飞。小池寒绿欲生漪，雨晴还日西。</p>
<p>帘半卷，燕双归，讳愁无奈眉。翻身整顿着残棋，沉吟应劫迟。</p>
<h3 id="鹧鸪天-枝上流莺和泪闻"><a class="markdownIt-Anchor" href="#鹧鸪天-枝上流莺和泪闻"></a> 鹧鸪天  枝上流莺和泪闻</h3>
<p>枝上流莺和泪闻，新啼痕间旧啼痕。一春鱼鸟无消息，千里关山劳梦魂。</p>
<p>无一语，对芳尊。安排肠断到黄昏。甫能炙得灯儿了，雨打梨花深闭门。</p>
<h2 id="第七辑-温飞卿诗集"><a class="markdownIt-Anchor" href="#第七辑-温飞卿诗集"></a> 第七辑  温飞卿诗集</h2>
<h3 id="商山早行"><a class="markdownIt-Anchor" href="#商山早行"></a> <a href="https://so.gushiwen.org/shiwenv_8d18260838e2.aspx">商山早行</a></h3>
<p>晨起动征铎，客行悲故乡。鸡声茅店月，人迹板桥霜。<br />
槲叶落山路，枳花明驿墙。因思杜陵梦，凫雁满回塘。</p>
<h3 id="望江南-梳洗罢"><a class="markdownIt-Anchor" href="#望江南-梳洗罢"></a> <a href="https://so.gushiwen.org/shiwenv_6e0fcfd7a813.aspx">望江南 梳洗罢</a></h3>
<p>梳洗罢，独倚望江楼。过尽千帆皆不是，斜晖脉脉水悠悠。肠断白蘋洲。</p>
<h3 id="菩萨蛮-小山重叠金明灭"><a class="markdownIt-Anchor" href="#菩萨蛮-小山重叠金明灭"></a> <a href="https://so.gushiwen.org/shiwenv_91843a09f605.aspx">菩萨蛮 小山重叠金明灭</a></h3>
<p>小山重叠金明灭，鬓云欲度香腮雪。懒起画蛾眉，弄妆梳洗迟。照花前后镜，花面交相映。新帖绣罗襦，双双金鹧鸪。</p>
<h3 id="梦江南-千万恨"><a class="markdownIt-Anchor" href="#梦江南-千万恨"></a> <a href="https://so.gushiwen.org/shiwenv_108ce1408715.aspx">梦江南 千万恨</a></h3>
<p>千万恨，恨极在天涯。山月不知心里事，水风空落眼前花，摇曳碧云斜</p>
<h2 id="第八辑-浣花词"><a class="markdownIt-Anchor" href="#第八辑-浣花词"></a> 第八辑  浣花词</h2>
<p>浣花词为韦庄所作词，韦庄，字端已。五代蜀人。</p>
<h3 id="菩萨蛮-人人尽说江南好"><a class="markdownIt-Anchor" href="#菩萨蛮-人人尽说江南好"></a> <a href="https://so.gushiwen.org/shiwenv_74ecdd7f533b.aspx">菩萨蛮 人人尽说江南好</a></h3>
<p>人人尽说江南好，游人只合江南老。春水碧于天，画船听雨眠。<br />
垆边人似月，皓腕凝霜雪。未老莫还乡，还乡须断肠。</p>
<h3 id="思帝乡-春日游"><a class="markdownIt-Anchor" href="#思帝乡-春日游"></a> <a href="https://so.gushiwen.org/shiwenv_06b7f46f1f4d.aspx">思帝乡 春日游</a></h3>
<p>春日游，杏花吹满头。陌上谁家年少足风流？</p>
<p>妾拟将身嫁与一生休。纵被无情弃，不能羞。</p>
<h3 id="菩萨蛮-劝君今夜须沉醉"><a class="markdownIt-Anchor" href="#菩萨蛮-劝君今夜须沉醉"></a> <a href="https://so.gushiwen.org/shiwenv_117d24b290c9.aspx">菩萨蛮 劝君今夜须沉醉</a></h3>
<p>劝君今夜须沉醉，尊前莫话明朝事。珍重主人心，酒深情亦深。<br />
须愁春漏短，莫诉金杯满。遇酒且呵呵，人生能几何。</p>
<h3 id="女冠子-四月十七"><a class="markdownIt-Anchor" href="#女冠子-四月十七"></a> <a href="https://so.gushiwen.org/shiwenv_c5239fb584d8.aspx">女冠子 四月十七</a></h3>
<p>四月十七，正是去年今日，别君时。忍泪佯低面，含羞半敛眉。<br />
不知魂已断，空有梦相随。除却天边月，没人知。</p>
<h3 id="谒金门-春雨足"><a class="markdownIt-Anchor" href="#谒金门-春雨足"></a> <a href="https://so.gushiwen.org/shiwenv_f7aa06a1014c.aspx">谒金门 春雨足</a></h3>
<p>春雨足，染就一溪新绿。柳外飞来双羽玉，弄晴相对浴。<br />
楼外翠帘高轴，倚遍阑干几曲。云淡水平烟树簇，寸心千里目。</p>
<h2 id="第九辑-竹山词"><a class="markdownIt-Anchor" href="#第九辑-竹山词"></a> 第九辑  竹山词</h2>
<p>竹山词为蒋捷所作，蒋捷，南宋时人。</p>
<h3 id="虞美人-听雨"><a class="markdownIt-Anchor" href="#虞美人-听雨"></a> 虞美人  听雨</h3>
<p>[宋] 蒋捷</p>
<p>少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低，断雁叫西风。</p>
<p>而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前，点滴到天明。</p>
<h3 id="一剪梅-舟过吴江"><a class="markdownIt-Anchor" href="#一剪梅-舟过吴江"></a> 一剪梅  舟过吴江</h3>
<p>[宋] 蒋捷</p>
<p>一片春愁待酒浇。江上舟摇，楼上帘招。秋娘渡与泰娘桥，风又飘飘，雨又萧萧。</p>
<p>何日归家洗客袍？银字笙调，心字香烧。流光容易把人抛，红了樱桃，绿了芭蕉。</p>
<h3 id="声声慢-秋声"><a class="markdownIt-Anchor" href="#声声慢-秋声"></a> 声声慢 秋声</h3>
<p>黄花深巷，红叶低窗，凄凉一片秋声。豆雨声来，中间夹带风声。疏疏二十五点，丽谯门、不锁更声。故人远，问谁摇玉佩，檐底铃声？</p>
<p>彩角声吹月堕，渐连营马动，四起笳声。闪烁邻灯，灯前尚有砧声。知他诉愁到晓，碎哝哝、多少蛩声！诉未了，把一半、分与雁声。</p>
<h3 id="贺新郎-兵后寓吴"><a class="markdownIt-Anchor" href="#贺新郎-兵后寓吴"></a> 贺新郎 兵后寓吴</h3>
<p>深阁帘垂绣，记家人、软语灯边，笑涡红透。万叠城头哀怨角，吹落霜花满袖。影厮伴、东奔西走。望断乡关知何处?羡寒鸦、到著黄昏后。一点点，归杨柳。</p>
<p>相看只有山如旧。叹浮云、本是无心，也成苍狗。明日枯荷包冷饭，又过前头小阜。趁未发、且尝村酒。醉探枵囊毛锥在，问邻翁、要写牛经否?翁不应，但摇手。</p>
<h2 id="第十辑-刘辰翁词笔"><a class="markdownIt-Anchor" href="#第十辑-刘辰翁词笔"></a> 第十辑  刘辰翁词笔</h2>
<h3 id="柳梢青春感"><a class="markdownIt-Anchor" href="#柳梢青春感"></a> 柳梢青·春感</h3>
<p>铁马蒙毡，银花洒泪，春入愁城。笛里番腔，街头戏鼓，不是歌声。<br />
那堪独坐青灯。想故国、高台月明。辇下风光，山中岁月，海上心情。</p>
<h3 id="山花子此处情怀欲问天"><a class="markdownIt-Anchor" href="#山花子此处情怀欲问天"></a> 山花子·此处情怀欲问天</h3>
<p>此处情怀欲问天，相期相就复何年。行过章江三十里，泪依然。<br />
早宿半程芳草路，犹寒欲雨暮春天。小小桃花三两处，得人怜。</p>
<h3 id="唐多令明月满沧洲"><a class="markdownIt-Anchor" href="#唐多令明月满沧洲"></a> 唐多令·明月满沧洲</h3>
<p>明月满沧洲。长江一意流。更何人、横笛危楼。天地不知兴废事，三十万、八千秋。</p>
<p>落叶女墙头。铜驼无恙不。看青山、白骨堆愁。除却月宫花树下，尘坱莽、欲何游。</p>
<h2 id="第十一辑-山谷词"><a class="markdownIt-Anchor" href="#第十一辑-山谷词"></a> 第十一辑  山谷词</h2>
<p>山谷词为江西诗派开山之祖黄庭坚所作，黄庭坚，字鲁直，号山谷道人。文学家，书法家。</p>
<h3 id="清平乐春归何处"><a class="markdownIt-Anchor" href="#清平乐春归何处"></a> 清平乐·春归何处</h3>
<p>春归何处。寂寞无行路。若有人知春去处。唤取归来同住。</p>
<p>春无踪迹谁知。除非问取黄鹂。百啭无人能解，因风飞过蔷薇</p>
<h3 id="虞美人宜州见梅作"><a class="markdownIt-Anchor" href="#虞美人宜州见梅作"></a> 虞美人·宜州见梅作</h3>
<p>天涯也有江南信。梅破知春近。夜阑风细得香迟。不道晓来开遍、向南枝。</p>
<p>玉台弄粉花应妒。飘到眉心住。平生个里愿杯深。去国十年老尽、少年心。</p>
<h3 id="鹧鸪天座中有眉山隐客史应之和前韵即席答之"><a class="markdownIt-Anchor" href="#鹧鸪天座中有眉山隐客史应之和前韵即席答之"></a> 鹧鸪天·座中有眉山隐客史应之和前韵即席答之</h3>
<p>黄菊枝头生晓寒。人生莫放酒杯干。风前横笛斜吹雨，醉里簪花倒著冠。</p>
<p>身健在，且加餐。舞裙歌板尽清欢。黄花白发相牵挽，付与时人冷眼看</p>
<h3 id="菩萨蛮半烟半雨溪桥畔"><a class="markdownIt-Anchor" href="#菩萨蛮半烟半雨溪桥畔"></a> 菩萨蛮·半烟半雨溪桥畔</h3>
<p>半烟半雨溪桥畔，渔翁醉着无人唤。疏懒意何长，春风花草香。</p>
<p>江山如有待，此意陶潜解。问我去何之，君行到自知。</p>
<h3 id="赠衡阳妓陈湘"><a class="markdownIt-Anchor" href="#赠衡阳妓陈湘"></a> 赠衡阳妓陈湘</h3>
<p>鸳鸯翡翠，小小思珍偶。眉黛敛秋波，尽湖南、山明水秀。娉娉袅袅，恰近十三余。春未透，花枝瘦，正是愁时候。</p>
<p>寻花载酒，肯落谁人后？只恐远归来，绿成阴、青梅如豆。心期得处，每自不由人，长亭柳，君知否，千里犹回首。</p>
<h2 id="第十二辑-稼轩长短句"><a class="markdownIt-Anchor" href="#第十二辑-稼轩长短句"></a> 第十二辑  稼轩长短句</h2>
<p>辛弃疾，字幼安，号稼轩，善为词，可谓篇篇佳作，余读其词，拊手频频。选之一二示下。</p>
<h3 id="鹧鸪天代人赋"><a class="markdownIt-Anchor" href="#鹧鸪天代人赋"></a> 鹧鸪天·代人赋</h3>
<p>晚日寒鸦一片愁。柳塘新绿却温柔。若教眼底无离恨，不信人间有白头。</p>
<p>肠已断，泪难收。相思重上小红楼。情知已被山遮断，频倚阑干不自由。</p>
<h3 id="鹧鸪天陌上柔桑破嫩芽"><a class="markdownIt-Anchor" href="#鹧鸪天陌上柔桑破嫩芽"></a> 鹧鸪天·陌上柔桑破嫩芽</h3>
<p>陌上柔桑破嫩芽，东邻蚕种已生些。平冈细草鸣黄犊，斜日寒林点暮鸦。</p>
<p>山远近，路横斜，青旗沽酒有人家。城中桃李愁风雨，春在溪头荠菜花。</p>
<h3 id="水调歌头壬子三山被召陈端仁给事饮饯席上作"><a class="markdownIt-Anchor" href="#水调歌头壬子三山被召陈端仁给事饮饯席上作"></a> 水调歌头·壬子三山被召陈端仁给事饮饯席上作</h3>
<p>长恨复长恨，裁作短歌行。何人为我楚舞，听我楚狂声？余既滋兰九畹，又树蕙之百亩，秋菊更餐英。门外沧浪水，可以濯吾缨。<br />
一杯酒，问何似，身后名？人间万事，毫发常重泰山轻。悲莫悲生离别，乐莫乐新相识，儿女古今情。富贵非吾事，归与白鸥盟。</p>
<h2 id="第十三辑-东坡词"><a class="markdownIt-Anchor" href="#第十三辑-东坡词"></a> 第十三辑 东坡词</h2>
<p>放眼北宋文坛，惟东坡一人而已。其造诣所及之处，可谓全矣。</p>
<h3 id="浣溪沙细雨斜风作晓寒"><a class="markdownIt-Anchor" href="#浣溪沙细雨斜风作晓寒"></a> 浣溪沙·细雨斜风作晓寒</h3>
<p>元丰七年十二月二十四日，从泗州刘倩叔游南山</p>
<p>细雨斜风作晓寒，淡烟疏柳媚晴滩。入淮清洛渐漫漫。<br />
雪沫乳花浮午盏，蓼茸蒿笋试春盘。人间有味是清欢。</p>
<h3 id="西江月顷在黄州"><a class="markdownIt-Anchor" href="#西江月顷在黄州"></a> 西江月·顷在黄州</h3>
<p>顷在黄州，春夜行蕲水中，过酒家饮，酒醉，乘月至一溪桥上，解鞍，由肱醉卧少休。及觉已晓，乱山攒拥，流水锵然，疑非尘世也。书此语桥柱上。</p>
<p>照野弥弥浅浪，横空隐隐层霄。障泥未解玉骢骄，我欲醉眠芳草。<br />
可惜一溪风月，莫教踏碎琼瑶。解鞍欹枕绿杨桥，杜宇一声春晓。</p>
<h3 id="蝶恋花暮春别李公择"><a class="markdownIt-Anchor" href="#蝶恋花暮春别李公择"></a> 蝶恋花·暮春别李公择</h3>
<p>簌簌无风花自堕。寂寞园林，柳老樱桃过。落日有情还照坐，山青一点横云破。<br />
路尽河回人转舵。系缆渔村，月暗孤灯火。凭仗飞魂招楚些，我思君处君思我。</p>
<h3 id="临江仙夜饮东坡醒复醉"><a class="markdownIt-Anchor" href="#临江仙夜饮东坡醒复醉"></a> 临江仙·夜饮东坡醒复醉</h3>
<p>夜饮东坡醒复醉，归来仿佛三更。家童鼻息已雷鸣。敲门都不应，倚杖听江声。<br />
长恨此身非我有，何时忘却营营。夜阑风静縠纹平。小舟从此逝，江海寄余生。</p>
<h3 id="临江仙送钱穆父"><a class="markdownIt-Anchor" href="#临江仙送钱穆父"></a> 临江仙·送钱穆父</h3>
<p>一别都门三改火，天涯踏尽红尘。依然一笑作春温。无波真古井，有节是秋筠。<br />
惆怅孤帆连夜发，送行淡月微云。尊前不用翠眉颦。人生如逆旅，我亦是行人。</p>
<h3 id="定风波南海归赠王定国侍人寓娘"><a class="markdownIt-Anchor" href="#定风波南海归赠王定国侍人寓娘"></a> 定风波·南海归赠王定国侍人寓娘</h3>
<p>常羡人间琢玉郎，天应乞与点酥娘。尽道清歌传皓齿，风起，雪飞炎海变清凉。</p>
<p>万里归来颜愈少，微笑，笑时犹带岭梅香。试问岭南应不好，却道：此心安处是吾乡。</p>
<h3 id="南乡子和杨元素时移守密州"><a class="markdownIt-Anchor" href="#南乡子和杨元素时移守密州"></a> 南乡子·和杨元素时移守密州</h3>
<p>东武望余杭，云海天涯两渺茫。何日功成名遂了，还乡，醉笑陪公三万场。<br />
不用诉离觞，痛饮从来别有肠。今夜送归灯火冷，河塘，堕泪羊公却姓杨。</p>
<h2 id="第十四辑-元曲摘选"><a class="markdownIt-Anchor" href="#第十四辑-元曲摘选"></a> 第十四辑  元曲摘选</h2>
<h3 id="折桂令春情"><a class="markdownIt-Anchor" href="#折桂令春情"></a> 折桂令·春情</h3>
<p><a href="https://www.gushiwen.org/shiwen/default.aspx?cstr=%E5%85%83%E4%BB%A3">元代</a>：<a href="https://so.gushiwen.org/authorv_79bc07db1e74.aspx">徐再思</a></p>
<p>平生不会相思，才会相思，便害相思。身似浮云，心如飞絮，气若游丝。<br />
空一缕余香在此，盼千金游子何之。证候来时，正是何时？灯半昏时，月半明时。</p>
<h3 id="人月圆山中书事"><a class="markdownIt-Anchor" href="#人月圆山中书事"></a> 人月圆·山中书事</h3>
<p><a href="https://www.gushiwen.org/shiwen/default.aspx?cstr=%E5%85%83%E4%BB%A3">元代</a>：<a href="https://so.gushiwen.org/authorv_a56fa849ea37.aspx">张可久</a></p>
<p>兴亡千古繁华梦，诗眼倦天涯。孔林乔木，吴宫蔓草，楚庙寒鸦。<br />
数间茅舍，藏书万卷，投老村家。山中何事？松花酿酒，春水煎茶。</p>
]]></content>
      <categories>
        <category>芳林拾记</category>
      </categories>
      <tags>
        <tag>古典诗词</tag>
      </tags>
  </entry>
  <entry>
    <title>两个栈实现队列</title>
    <url>/2020/04/15/%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="两个栈实现队列"><a class="markdownIt-Anchor" href="#两个栈实现队列"></a> 两个栈实现队列</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>设计其中一个栈为主栈，另一栈为辅助栈，然后根据队列先进先出的特性，我们需要保持每次入主栈元素放入栈底，这样最先进入的元素位于栈顶，实现了先进先出。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        B = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        A.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!B.isEmpty()) <span class="keyword">return</span> B.removeLast();</span><br><span class="line">        <span class="keyword">if</span>(A.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!A.isEmpty())</span><br><span class="line">            B.addLast(A.removeLast());</span><br><span class="line">        <span class="keyword">return</span> B.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoStack_To_Queue</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1;  <span class="comment">//变量声明</span></span><br><span class="line">    Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStack_To_Queue</span><span class="params">()</span></span>&#123;          <span class="comment">//构造函数</span></span><br><span class="line">        stack1=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2=<span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        size=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		stack1.add(value);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (stack1.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (!stack1.isEmpty()) &#123;</span><br><span class="line">				stack2.add(stack1.pop());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> stack2.pop();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">return</span> stack2.pop();</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            System.out.print(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TwoStack_To_Queue twoStack_To_Queue=<span class="keyword">new</span> TwoStack_To_Queue();</span><br><span class="line">        twoStack_To_Queue.appendtail(<span class="number">4</span>);</span><br><span class="line">        twoStack_To_Queue.appendtail(<span class="number">3</span>);</span><br><span class="line">        twoStack_To_Queue.deleteHead();</span><br><span class="line">        twoStack_To_Queue.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>快速幂应用</title>
    <url>/2020/04/15/%E5%BF%AB%E9%80%9F%E5%B9%82%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="快速幂应用"><a class="markdownIt-Anchor" href="#快速幂应用"></a> 快速幂应用</h1>
<p>快速幂，也称平方求幂，可以在O(nlogn)时间复杂度内计算乘方，在许多算法中如大数求余中被广泛应用。</p>
<h2 id="问题引出"><a class="markdownIt-Anchor" href="#问题引出"></a> 问题引出</h2>
<p>如计算7的10次方，怎么算比较快？</p>
<p>普遍的想法是10个7一直乘下去，共执行9次乘法运算。这样是比较慢的，而且也没发挥出cpu的高性能计算。</p>
<p>于是，我们可以进行一个拆分操作。先7×7=49，然后7的5次方49×49×7=16807，再然后7的5次方乘7的5次方，计算得到7的10次方。</p>
<h2 id="算法思路"><a class="markdownIt-Anchor" href="#算法思路"></a> 算法思路</h2>
<p>以上可概述为一个二分的思想，并且得到一个递归方程：<br />
<img src="https://cdn.jsdelivr.net/gh/Zhi-Tu/My-Album/photos/20200426164156.PNG" alt="" /></p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<h3 id="原理代码"><a class="markdownIt-Anchor" href="#原理代码"></a> 原理代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_pow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> quick_pow(a, n - <span class="number">1</span>) * a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = quick_pow(a, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> temp * temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这个temp变量是必要的，因为如果不把<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D" alt="[公式]" />记录下来，直接写成quick_pow(a, n /2)*quick_pow(a, n /2)，那会计算两次<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D" alt="[公式]" />，整个算法就退化为了 <img src="https://www.zhihu.com/equation?tex=O%28n%29" alt="[公式]" /> 。</p>
<h3 id="快速幂模板"><a class="markdownIt-Anchor" href="#快速幂模板"></a> 快速幂模板</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>, temp = x;</span><br><span class="line">        <span class="keyword">int</span> exp = n;</span><br><span class="line">        <span class="keyword">while</span> (exp != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((exp % <span class="number">2</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                ans = ans * temp;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp * temp;</span><br><span class="line">            exp /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? ans : <span class="number">1</span> / ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//题解：快速幂</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=n;</span><br><span class="line">        <span class="keyword">while</span>(i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;<span class="number">1</span>)res*=x;  <span class="comment">//i的低位存在，res*x</span></span><br><span class="line">            x*=x;           <span class="comment">//x扩大为它的平方，因为二进制每位的差距是平方关系</span></span><br><span class="line">            i/=<span class="number">2</span>;           <span class="comment">//i向0靠近</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n&lt;<span class="number">0</span>?<span class="number">1</span>/res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h2>
<p>在实际问题中，题目常常会要求对一个大素数取模(%1000000007)，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是<strong>步步取模</strong>，如果MOD较大，还应当<strong>开long long</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归快速幂（对大素数取模）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">qpow</span>(a, n - <span class="number">1</span>) * a % MOD;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ll temp = <span class="built_in">qpow</span>(a, n / <span class="number">2</span>) % MOD;</span><br><span class="line">        <span class="keyword">return</span> temp * temp % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例题</p>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = n % <span class="number">3</span>, p = <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">long</span> rem = <span class="number">1</span>, x = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> a = n / <span class="number">3</span> - <span class="number">1</span>; a &gt; <span class="number">0</span>; a /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//快速幂取模</span></span><br><span class="line">            <span class="keyword">if</span>(a % <span class="number">2</span> == <span class="number">1</span>) rem = (rem * x) % p;</span><br><span class="line">            x = (x * x) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">3</span> % p);</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">4</span> % p);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(rem * <span class="number">6</span> % p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的路径问题</title>
    <url>/2020/04/10/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="矩阵中的路径"><a class="markdownIt-Anchor" href="#矩阵中的路径"></a> 矩阵中的路径</h1>
<h2 id="问题要求"><a class="markdownIt-Anchor" href="#问题要求"></a> 问题要求</h2>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p>
<p>示例：</p>
<p>输入：board =<br />
(“A”,“B”,“C”,“E”),<br />
(“S”,“F”,“C”,“S”),<br />
(“A”,“D”,“E”,“E”),<br />
//board定义一个二维数组，此处（ 等同于花括号，由于与markdown内置标签冲突，故使用括号代替花括号。<br />
word = “ABCCED”<br />
输出：true</p>
<h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2>
<blockquote>
<p>本问题是典型的矩阵搜索问题，可使用 <strong>深度优先搜索（DFS）+ 剪枝</strong> 解决。</p>
</blockquote>
<h3 id="算法原理"><a class="markdownIt-Anchor" href="#算法原理"></a> 算法原理</h3>
<ul>
<li><strong>深度优先搜索：</strong> 可以理解为暴力法遍历矩阵中所有字符串可能性。DFS 通过递归，先朝一个方向搜到底，再回溯至上个节点，沿另一个方向搜索，以此类推。</li>
<li><strong>剪枝：</strong> 在搜索中，遇到 <code>这条路不可能和目标字符串匹配成功</code> 的情况（<em>例如：此矩阵元素和目标字符不同、此元素已被访问）</em>，则应立即返回，称之为 <code>可行性剪枝</code> 。</li>
</ul>
<h3 id="算法剖析"><a class="markdownIt-Anchor" href="#算法剖析"></a> 算法剖析</h3>
<ul>
<li>递归参数： 当前元素在矩阵 board 中的行列索引 i 和 j ，当前目标字符在 word 中的索引 k 。</li>
<li>终止条件：<br />
返回 false ： ① 行或列索引越界 或 ② 当前矩阵元素与目标字符不同 或 ③ 当前矩阵元素已访问过 （③ 可合并至 ② ） 。<br />
返回 true ： 字符串 word 已全部匹配，即 k = length(word) - 1 。</li>
<li>递推工作：<br />
标记当前矩阵元素： 将 board[i][j]值暂存于变量 tmp ，并修改为字符 ‘/’ ，代表此元素已访问过，防止之后搜索时重复访问。 搜索下一单元格： 朝当前元素的 上、下、左、右 四个方向开启下层递归，使用 或 连接 （代表只需一条可行路径） ，并记录结果至 res 。 还原当前矩阵元素： 将 tmp 暂存值还原至 board[i][j] 元素。</li>
<li>回溯返回值： 返回 <code>res</code> ，代表是否搜索到目标字符串。</li>
</ul>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path_in_Mat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(<span class="keyword">char</span>[][] boardpanel,String word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words=word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;boardpanel.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;boardpanel[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dfs(boardpanel,words,i,j,<span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] boardpanel,<span class="keyword">char</span>[] word,<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=boardpanel.length||j&lt;<span class="number">0</span>||j&gt;=boardpanel[<span class="number">0</span>].length||boardpanel[i][j]!=word[k]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k==word.length-<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">char</span> temp=boardpanel[i][j];</span><br><span class="line">        boardpanel[i][j]=<span class="string">&#x27;/&#x27;</span>;<span class="comment">//将访问过的元素标记为/，以防再次访问。</span></span><br><span class="line">        <span class="keyword">boolean</span> res=dfs(boardpanel,word,i+<span class="number">1</span>,j,k+<span class="number">1</span>)||dfs(boardpanel,word,i-<span class="number">1</span>,j,k+<span class="number">1</span>)||</span><br><span class="line">                dfs(boardpanel,word,i,j+<span class="number">1</span>,k+<span class="number">1</span>)||dfs(boardpanel,word,i,j-<span class="number">1</span>,k+<span class="number">1</span>);</span><br><span class="line">        boardpanel[i][j]=temp;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[][] boardpanel=&#123;&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;,&#123;<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;,&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;&#125;;</span><br><span class="line">        String words=<span class="string">&quot;abcced&quot;</span>;</span><br><span class="line">        Path_in_Mat path_in_mat=<span class="keyword">new</span> Path_in_Mat();</span><br><span class="line">        System.out.println(path_in_mat.exists(boardpanel,words));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c"><a class="markdownIt-Anchor" href="#c"></a> C++</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//vector&lt;vector&lt;char&gt;&gt;&amp; board为 char型二维数组</span></span><br><span class="line">        <span class="keyword">if</span>(board.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;board.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;board[<span class="number">0</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">dfs</span>(board,word,i,j,<span class="number">0</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string&amp; word, <span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="comment">//string&amp; word表示word的引用；另c++中char型数组和string等价。</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;=board.<span class="built_in">size</span>()||j&gt;=board[<span class="number">0</span>].<span class="built_in">size</span>()||i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||length&gt;=word.<span class="built_in">size</span>()||word[length]!=board[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(length==word.<span class="built_in">size</span>()<span class="number">-1</span>&amp;&amp;word[length]==board[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> temp=board[i][j];</span><br><span class="line">        board[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">bool</span> flag=<span class="built_in">dfs</span>(board,word,i,j+<span class="number">1</span>,length+<span class="number">1</span>)||<span class="built_in">dfs</span>(board,word,i,j<span class="number">-1</span>,length+<span class="number">1</span>)||<span class="built_in">dfs</span>(board,word,i+<span class="number">1</span>,j,length+<span class="number">1</span>)||<span class="built_in">dfs</span>(board,word,i<span class="number">-1</span>,j,length+<span class="number">1</span>);</span><br><span class="line">        board[i][j]=temp;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>删除链表的结点及反向打印链表</title>
    <url>/2020/04/10/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h1 id="删除链表的结点"><a class="markdownIt-Anchor" href="#删除链表的结点"></a> 删除链表的结点</h1>
<h2 id="问题陈述"><a class="markdownIt-Anchor" href="#问题陈述"></a> 问题陈述</h2>
<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点，并返回删除后的链表的头节点。</p>
<h2 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h2>
<p>可定义一个结点，该结点的下一结点指向单链表的头结点head，以便于处理第一个元素。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        val=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solustion</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        ListNode firstNode=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);  <span class="comment">//定义一个新节点</span></span><br><span class="line">        firstNode.next=head;</span><br><span class="line">        ListNode curr=firstNode;        <span class="comment">//定义初始当前结点为新节点</span></span><br><span class="line">        <span class="keyword">if</span>(curr!=null&amp;&amp;curr.next!=null)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.next.val=val)&#123;</span><br><span class="line">                curr.next=curr.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr=curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="从尾到头打印链表"><a class="markdownIt-Anchor" href="#从尾到头打印链表"></a> 从尾到头打印链表</h1>
<h2 id="问题陈述-2"><a class="markdownIt-Anchor" href="#问题陈述-2"></a> 问题陈述</h2>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h2 id="思路分析-2"><a class="markdownIt-Anchor" href="#思路分析-2"></a> 思路分析</h2>
<p>利用栈后进先出的特性，我们可以把链表的元素逐一存入栈，然后弹栈以输出。</p>
<h2 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] <span class="built_in">reversePrint</span>(ListNode head)&#123;</span><br><span class="line">    Stack&lt;ListNode&gt; stack=<span class="keyword">new</span> Stack&lt;ListNode&gt;(); <span class="comment">//栈存储结点类型的数值</span></span><br><span class="line">    ListNode tmp=head;</span><br><span class="line">    <span class="keyword">if</span>(tmp!=null)&#123;   <span class="comment">//定义当前结点为head，并进行判断。</span></span><br><span class="line">        stack.<span class="built_in">push</span>(tmp);</span><br><span class="line">        tmp=tmp.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size=stack.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span>[] print=<span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">        print[i]=stack.<span class="built_in">pop</span>().val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> print;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="keyword">int</span>[] num=<span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            num[i]=list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recur</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        recur(head.next);</span><br><span class="line">        list.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>剪绳子问题</title>
    <url>/2020/04/10/%E5%89%AA%E7%BB%B3%E5%AD%90%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="剪绳子问题"><a class="markdownIt-Anchor" href="#剪绳子问题"></a> 剪绳子问题</h1>
<h2 id="问题概述"><a class="markdownIt-Anchor" href="#问题概述"></a> 问题概述</h2>
<p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m] 。请问 k[0]<em>k[1]</em>…*k[m] 可能的最大乘积是多少？</p>
<p>例如，当绳子的长度是8时， 我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h2>
<h3 id="数学推论"><a class="markdownIt-Anchor" href="#数学推论"></a> 数学推论</h3>
<p>推论一： 将绳子 以相等的长度等分为多段 ，得到的乘积最大<br />
推论二： 尽可能将绳子以长度 3 等分为多段时，乘积最大。</p>
<h3 id="切分规则"><a class="markdownIt-Anchor" href="#切分规则"></a> 切分规则</h3>
<p><strong>最优</strong>：3。把绳子尽可能切为多个长度为 3的片段，留下的最后一段绳子的长度可能为 0,1,2三种情况。<br />
<strong>次优</strong>：2 。若最后一段绳子长度为 2；则保留，不再拆为 1+1。<br />
<strong>最差</strong>：1 。若最后一段绳子长度为 1；则应把一份 3+1 替换为 2+2，因为 2×2&gt;3×1。</p>
<h3 id="算法步骤"><a class="markdownIt-Anchor" href="#算法步骤"></a> 算法步骤</h3>
<p>当 n≤3时，按照规则应不切分，但由于题目要求必须剪成 m段，因此必须剪出一段长度为 1的绳子，即返回 n−1 。<br />
当 n&gt;3时，求 n除以 3的 整数部分 a和 余数部分 b。即 n=3^a+b，并分为以下三种情况：<br />
当 b=0时，直接返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mi>a</mi></msup></mrow><annotation encoding="application/x-tex">3^a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span></span></span>；<br />
当 b=1时，要将一个 1+3转换为 2+2，因此返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>3</mn><mrow><mi>a</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">3^{a-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>×4；<br />
当 b=2时，返回$ 3^a$×2。</p>
<h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2>
<h3 id="java"><a class="markdownIt-Anchor" href="#java"></a> Java</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cut_Rope</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxMultiple</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> a=n/<span class="number">3</span>;    <span class="comment">//这里之后就是n&gt;3的情况</span></span><br><span class="line">        <span class="keyword">int</span> b=n%<span class="number">3</span>;</span><br><span class="line">        <span class="comment">//在上述条件成立下继续判断b</span></span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)  <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a);         </span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>)  <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>;             </span><br><span class="line">        <span class="comment">//这里即b不满足上述两种情况，默认b=2,不能再写判断了，</span></span><br><span class="line">        <span class="comment">// 否则没有最终的返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Cut_Rope cut_rope=<span class="keyword">new</span> Cut_Rope();      System.out.println(cut_rope.getMaxMultiple(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c"><a class="markdownIt-Anchor" href="#c"></a> c++</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a=n/<span class="number">3</span>;       <span class="comment">//这里之后就是n&gt;3的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> b=n%<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//在上述条件成立下继续判断b</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>,a);     </span><br><span class="line">    <span class="comment">//c++下求幂直接用pow（a，b）</span></span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>,a<span class="number">-1</span>)*<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(<span class="number">3</span>,a)*<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>大数取模</strong></p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基于贪心的思路</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mod = (<span class="keyword">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            res *= <span class="number">3</span>;</span><br><span class="line">            res %= mod;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(res * n % mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>和为s的两个数字</title>
    <url>/2020/04/10/%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="和为s的两个数字"><a class="markdownIt-Anchor" href="#和为s的两个数字"></a> 和为s的两个数字</h1>
<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[2,7] 或者 [7,2]</span><br></pre></td></tr></table></figure>
<h2 id="问题解法"><a class="markdownIt-Anchor" href="#问题解法"></a> 问题解法</h2>
<p><strong>思路一</strong></p>
<p>两个for循环。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&lt;nums.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]+nums[j]==target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],nums[j]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],nums[j]&#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//时间复杂度不好，可能超时。</span></span><br></pre></td></tr></table></figure>
<p><strong>思路二</strong></p>
<p>一次遍历。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]&lt;target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]&gt;target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],nums[j]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;nums[i],nums[j]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>剑指offer</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>故时喜欢看夜空中的烟火</title>
    <url>/2020/04/01/%E6%95%85%E6%97%B6%E5%96%9C%E6%AC%A2%E7%9C%8B%E5%A4%9C%E7%A9%BA%E4%B8%AD%E7%9A%84%E7%83%9F%E7%81%AB/</url>
    <content><![CDATA[<p>你知道吗？我喜欢夜空中的烟花。在那样漆黑的寂寂的夜里，她毫不隐秘的出现了！出现的那样的叫人惊喜交加！那是一种怎样的声色之美！我痴迷着，仰着头在一个刚刚远的距离痴痴的望着，她一定发现不了我。渐渐的，我喜欢上了抬头看烟花的姿态，也爱上了这个世界的五光十色。</p>
<p>你知道有一首歌《我》吗？我特别喜欢它的歌词，是林夕写的。</p>
<blockquote>
<p>I am what I am<br />
我永远都爱这样的我<br />
快乐是快乐的方式不只一种<br />
最荣幸是谁都是造物者的光荣<br />
不用闪躲 为我喜欢的生活而活<br />
不用粉墨 就站在光明的角落<br />
我就是我是颜色不一样的烟火<br />
天空海阔 要做最坚强的泡沫<br />
我喜欢我 让蔷薇开出一种结果<br />
孤独的沙漠里 一样盛放的赤裸裸</p>
</blockquote>
<p>一字一句，写成了我喜欢的样子！想来我的生命，又何尝不是如此。我在别人的眼中也许是个异数，又或许说沉浸于文字中的我是个异数。孤独的沙漠里，我愿是那荒丘，当西下的落日照着我一片赭金。四下静悄悄的，闻不到商队驼铃的叮当，没有狂风携沙来肆虐，只觉得一阵飒飒的晚风吹拂我的肌缕……</p>
<p>深夜里，如果我突然的惊醒，然后再也无法安睡了！那一定是我内心在百转千回，一个少年在成长的历程里，该是会遇见很多不安与荒愁吧！辗转反侧后戴上耳机，听林夕的这首《我》，是这样的一种声音，竟让我心潮澎湃！</p>
<p>遥想 故时在乡居的时候，出于好奇的玩乐，在过年玩烟花是一件让人幸福的事情！当然，看烟花更是。一听到声响，便激动到什么都可以不顾的跑出去，看那一束一束的花火，在夜空中绽放又转而湮灭，然后留下了寂寥的我在期盼着她还会再来。那个时候的小小的我总恨屋檐高树遮去了我的视线，后来家里建了三层小楼房，大年晚上一吃完年夜饭便爬上顶层的天台，抚着栏杆，我可以平视烟花了！四野的暮光下，有灯火星星点点的人家，更有看不完的烟花，这边停了，那边又起，直到被爸妈叫下来洗脸洗脚开始睡啦……<br />
而光阴辗转，后来的岁月不饶我再多有一点恣意，倏忽间堪觉烟花易冷，等而再等是伽蓝檐角的风铃摇摆；是雨纷纷旧故里草木深；是一个人执伞走在遍地涓涤的大地，看着斑驳的老树根……</p>
<p>后来的 后来总归一个人的千山万水，海阔天空的世界，我不再躲闪，也毋须粉墨。我愿在那夜空，不同于白天的耀眼，然后开出灿比孤星的花火。你会在某个地方，静静的看着我，然后许下一个美好的不愿醒来的梦。</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
      <tags>
        <tag>故时</tag>
        <tag>烟火</tag>
      </tags>
  </entry>
  <entry>
    <title>暮春游富春江</title>
    <url>/2020/04/01/%E6%9A%AE%E6%98%A5%E6%B8%B8%E5%AF%8C%E6%98%A5%E6%B1%9F/</url>
    <content><![CDATA[<p>忽想暮春某日，与友自桐庐览富春江，吾辈纵舟江上，任之东西，一路落英缤纷，鸟声上下。抬眼处千峰万壑，碧色涟涟，花树自芳菲。时有烟村四五家，柴门小径，令人有隐逸之想。</p>
<p>吾与友相坐船尾，倏忽游鱼跃出水面，又潜入水中与吾舟并游，余大喜指之告友曰:“此鱼之乐也。”友欣然笑曰:“昔日庄子与惠子游于濠梁之上，见鱼儿悠然游弋，有此一对，今已千年，物是人非，而情之相似若此。”余欣然其言，肃然端坐取所藏素琴援琴应之。</p>
<p>日中，至乌龙，为兰江与新安江并流处，水湍清澈，山色竞秀，中有高峰一簇，丘峦环之。至其下，吾与友弃舟访岸，着屐而上。山石细碎，萦纡环回。半途歇于桐花树下，桐花扑嗒落肩上，叫人一怔。远处双鸟飞来，相随起落枝头，令人往羡。友自唱清歌，声环万籁。余执朱笔于一青岩处书曰: 山川静毓，行歌相答。</p>
<p>稍留片刻，复行，不觉至峰顶，眼界始阔，苍苍莽莽，榛榛葱葱，无穷无极。余二人渺立，呼啸山风。当是时，振臂一呼，仿佛纵身一赴，便染得，千寻碧。世间万种羁縻何所谓也，旋即泪下，是无由，也无因。</p>
]]></content>
      <categories>
        <category>细雨湿流光</category>
      </categories>
      <tags>
        <tag>富春江</tag>
        <tag>山花</tag>
      </tags>
  </entry>
</search>
